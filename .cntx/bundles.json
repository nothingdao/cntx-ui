{
  "master": {
    "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<cntx:bundle xmlns:cntx=\"https://cntx.dev/schema\" name=\"master\" generated=\"2025-06-26T23:06:21.911Z\">\n  <cntx:project>\n    <cntx:name>cntx-ui</cntx:name>\n    <cntx:version>2.0.12</cntx:version>\n    <cntx:description>File context management tool with web UI and MCP server for AI development workflows - bundle project files for LLM consumption</cntx:description>\n  </cntx:project>\n  <cntx:overview>\n    <cntx:purpose>Complete project overview with all source files</cntx:purpose>\n    <cntx:file-types>\n      <cntx:type name=\"components\" count=\"28\" />\n      <cntx:type name=\"hooks\" count=\"2\" />\n      <cntx:type name=\"utilities\" count=\"2\" />\n      <cntx:type name=\"configuration\" count=\"9\" />\n      <cntx:type name=\"styles\" count=\"2\" />\n      <cntx:type name=\"tests\" count=\"5\" />\n      <cntx:type name=\"documentation\" count=\"3\" />\n      <cntx:type name=\"other\" count=\"16\" />\n    </cntx:file-types>\n    <cntx:entry-points>\n      <cntx:file>server.js</cntx:file>\n      <cntx:file>web/index.html</cntx:file>\n      <cntx:file>web/src/App.css</cntx:file>\n      <cntx:file>web/src/App.tsx</cntx:file>\n      <cntx:file>web/src/index.css</cntx:file>\n      <cntx:file>web/src/main.tsx</cntx:file>\n      <cntx:file>web/tsconfig.app.json</cntx:file>\n    </cntx:entry-points>\n  </cntx:overview>\n  <cntx:files count=\"67\">\n    <cntx:group type=\"entry-points\" description=\"Main entry files for this bundle\">\n      <cntx:file path=\"server.js\" ext=\".js\" role=\"server-entry\">\n        <cntx:meta size=\"71642\" modified=\"2025-06-26T22:26:54.262Z\" lines=\"2164\" />\n        <cntx:content><![CDATA[import { readFileSync, writeFileSync, existsSync, mkdirSync, watch, readdirSync, statSync } from 'fs';\nimport { join, dirname, relative, extname, basename } from 'path';\nimport { createServer } from 'http';\nimport { WebSocketServer } from 'ws';\nimport { fileURLToPath } from 'url';\nimport path from 'path';\nimport { startMCPTransport } from './lib/mcp-transport.js';\nimport SemanticSplitter from './lib/semantic-splitter.js';\nimport { homedir } from 'os';\n\nconst __dirname = dirname(fileURLToPath(import.meta.url));\n\nfunction getContentType(filePath) {\n  const ext = path.extname(filePath).toLowerCase();\n  const contentTypes = {\n    '.html': 'text/html',\n    '.js': 'application/javascript',\n    '.css': 'text/css',\n    '.json': 'application/json',\n    '.png': 'image/png',\n    '.jpg': 'image/jpeg',\n    '.gif': 'image/gif',\n    '.svg': 'image/svg+xml',\n    '.ico': 'image/x-icon'\n  };\n  return contentTypes[ext] || 'text/plain';\n}\n\nexport class CntxServer {\n  constructor(cwd = process.cwd(), options = {}) {\n    this.CWD = cwd;\n    this.CNTX_DIR = join(cwd, '.cntx');\n    this.isQuietMode = options.quiet || false;\n    this.CONFIG_FILE = join(this.CNTX_DIR, 'config.json');\n    this.BUNDLES_FILE = join(this.CNTX_DIR, 'bundles.json');\n    this.HIDDEN_FILES_CONFIG = join(this.CNTX_DIR, 'hidden-files.json');\n    this.IGNORE_FILE = join(cwd, '.cntxignore');\n    this.CURSOR_RULES_FILE = join(cwd, '.cursorrules');\n    this.CLAUDE_MD_FILE = join(cwd, 'CLAUDE.md');\n\n    this.bundles = new Map();\n    this.ignorePatterns = [];\n    this.watchers = [];\n    this.clients = new Set();\n    this.isScanning = false;\n    this.mcpServer = null;\n    this.mcpServerStarted = false;\n\n    this.hiddenFilesConfig = {\n      globalHidden: [], // Files hidden across all bundles\n      bundleSpecific: {}, // Files hidden per bundle: { bundleName: [filePaths] }\n      userIgnorePatterns: [], // User-added ignore patterns\n      disabledSystemPatterns: [] // System patterns the user disabled\n    };\n\n    // Semantic splitting (parallel to bundle system)\n    this.semanticSplitter = new SemanticSplitter({\n      maxChunkSize: 2000,\n      includeContext: true,\n      groupRelated: true,\n      minFunctionSize: 50\n    });\n    this.semanticCache = null;\n    this.lastSemanticAnalysis = null;\n  }\n\n  init() {\n    if (!existsSync(this.CNTX_DIR)) mkdirSync(this.CNTX_DIR, { recursive: true });\n    this.loadConfig();\n    this.loadHiddenFilesConfig();\n    this.loadIgnorePatterns();\n    this.loadBundleStates();\n    this.startWatching();\n    this.generateAllBundles();\n  }\n\n  loadConfig() {\n    // Clear existing bundles to ensure deleted ones are removed\n    this.bundles.clear();\n\n    if (existsSync(this.CONFIG_FILE)) {\n      const config = JSON.parse(readFileSync(this.CONFIG_FILE, 'utf8'));\n      Object.entries(config.bundles || {}).forEach(([name, patterns]) => {\n        this.bundles.set(name, {\n          patterns: Array.isArray(patterns) ? patterns : [patterns],\n          files: [],\n          content: '',\n          changed: false,\n          lastGenerated: null,\n          size: 0\n        });\n      });\n    }\n\n    if (!this.bundles.has('master')) {\n      this.bundles.set('master', {\n        patterns: ['**/*'],\n        files: [],\n        content: '',\n        changed: false,\n        lastGenerated: null,\n        size: 0\n      });\n    }\n  }\n\n  loadHiddenFilesConfig() {\n    if (existsSync(this.HIDDEN_FILES_CONFIG)) {\n      try {\n        const config = JSON.parse(readFileSync(this.HIDDEN_FILES_CONFIG, 'utf8'));\n        this.hiddenFilesConfig = { ...this.hiddenFilesConfig, ...config };\n      } catch (e) {\n        if (!this.isQuietMode) console.warn('Could not load hidden files config:', e.message);\n      }\n    }\n  }\n\n  saveHiddenFilesConfig() {\n    try {\n      writeFileSync(this.HIDDEN_FILES_CONFIG, JSON.stringify(this.hiddenFilesConfig, null, 2));\n    } catch (e) {\n      if (!this.isQuietMode) console.error('Failed to save hidden files config:', e.message);\n    }\n  }\n\n  isFileHidden(filePath, bundleName = null) {\n    // Check global hidden files\n    if (this.hiddenFilesConfig.globalHidden.includes(filePath)) {\n      return true;\n    }\n\n    // Check bundle-specific hidden files\n    if (bundleName && this.hiddenFilesConfig.bundleSpecific[bundleName]) {\n      return this.hiddenFilesConfig.bundleSpecific[bundleName].includes(filePath);\n    }\n\n    return false;\n  }\n\n  toggleFileVisibility(filePath, bundleName = null, forceHide = null) {\n    if (bundleName) {\n      // Bundle-specific hiding\n      if (!this.hiddenFilesConfig.bundleSpecific[bundleName]) {\n        this.hiddenFilesConfig.bundleSpecific[bundleName] = [];\n      }\n\n      const bundleHidden = this.hiddenFilesConfig.bundleSpecific[bundleName];\n      const isCurrentlyHidden = bundleHidden.includes(filePath);\n\n      if (forceHide === null) {\n        // Toggle current state\n        if (isCurrentlyHidden) {\n          this.hiddenFilesConfig.bundleSpecific[bundleName] = bundleHidden.filter(f => f !== filePath);\n        } else {\n          bundleHidden.push(filePath);\n        }\n      } else {\n        // Force to specific state\n        if (forceHide && !isCurrentlyHidden) {\n          bundleHidden.push(filePath);\n        } else if (!forceHide && isCurrentlyHidden) {\n          this.hiddenFilesConfig.bundleSpecific[bundleName] = bundleHidden.filter(f => f !== filePath);\n        }\n      }\n    } else {\n      // Global hiding\n      const isCurrentlyHidden = this.hiddenFilesConfig.globalHidden.includes(filePath);\n\n      if (forceHide === null) {\n        // Toggle current state\n        if (isCurrentlyHidden) {\n          this.hiddenFilesConfig.globalHidden = this.hiddenFilesConfig.globalHidden.filter(f => f !== filePath);\n        } else {\n          this.hiddenFilesConfig.globalHidden.push(filePath);\n        }\n      } else {\n        // Force to specific state\n        if (forceHide && !isCurrentlyHidden) {\n          this.hiddenFilesConfig.globalHidden.push(filePath);\n        } else if (!forceHide && isCurrentlyHidden) {\n          this.hiddenFilesConfig.globalHidden = this.hiddenFilesConfig.globalHidden.filter(f => f !== filePath);\n        }\n      }\n    }\n\n    this.saveHiddenFilesConfig();\n  }\n\n  bulkToggleFileVisibility(filePaths, bundleName = null, forceHide = null) {\n    filePaths.forEach(filePath => {\n      this.toggleFileVisibility(filePath, bundleName, forceHide);\n    });\n  }\n\n  addUserIgnorePattern(pattern) {\n    if (!this.hiddenFilesConfig.userIgnorePatterns.includes(pattern)) {\n      this.hiddenFilesConfig.userIgnorePatterns.push(pattern);\n      this.saveHiddenFilesConfig();\n      this.loadIgnorePatterns();\n      this.generateAllBundles();\n      return true;\n    }\n    return false;\n  }\n\n  removeUserIgnorePattern(pattern) {\n    const index = this.hiddenFilesConfig.userIgnorePatterns.indexOf(pattern);\n    if (index > -1) {\n      this.hiddenFilesConfig.userIgnorePatterns.splice(index, 1);\n      this.saveHiddenFilesConfig();\n      this.loadIgnorePatterns();\n      this.generateAllBundles();\n      return true;\n    }\n    return false;\n  }\n\n  toggleSystemIgnorePattern(pattern) {\n    const index = this.hiddenFilesConfig.disabledSystemPatterns.indexOf(pattern);\n    if (index > -1) {\n      // Re-enable the pattern\n      this.hiddenFilesConfig.disabledSystemPatterns.splice(index, 1);\n    } else {\n      // Disable the pattern\n      this.hiddenFilesConfig.disabledSystemPatterns.push(pattern);\n    }\n\n    this.saveHiddenFilesConfig();\n    this.loadIgnorePatterns();\n    this.generateAllBundles();\n  }\n\n  loadIgnorePatterns() {\n    const systemPatterns = [\n      // Version control\n      '**/.git/**',\n      '**/.svn/**',\n      '**/.hg/**',\n\n      // Dependencies\n      '**/node_modules/**',\n      '**/vendor/**',\n      '**/.pnp/**',\n\n      // Build outputs\n      '**/dist/**',\n      '**/build/**',\n      '**/out/**',\n      '**/.next/**',\n      '**/.nuxt/**',\n      '**/target/**',\n\n      // Package files\n      '**/*.tgz',\n      '**/*.tar.gz',\n      '**/*.zip',\n      '**/*.rar',\n      '**/*.7z',\n\n      // Logs\n      '**/*.log',\n      '**/logs/**',\n\n      // Cache directories\n      '**/.cache/**',\n      '**/.parcel-cache/**',\n      '**/.nyc_output/**',\n      '**/coverage/**',\n      '**/.pytest_cache/**',\n      '**/__pycache__/**',\n\n      // IDE/Editor files\n      '**/.vscode/**',\n      '**/.idea/**',\n      '**/*.swp',\n      '**/*.swo',\n      '**/*~',\n\n      // OS files\n      '**/.DS_Store',\n      '**/Thumbs.db',\n      '**/desktop.ini',\n\n      // Environment files\n      '**/.env',\n      '**/.env.local',\n      '**/.env.*.local',\n\n      // Lock files\n      '**/package-lock.json',\n      '**/yarn.lock',\n      '**/pnpm-lock.yaml',\n      '**/Cargo.lock',\n\n      // cntx-ui specific\n      '**/.cntx/**'\n    ];\n\n    // Read from .cntxignore file\n    let filePatterns = [];\n    if (existsSync(this.IGNORE_FILE)) {\n      filePatterns = readFileSync(this.IGNORE_FILE, 'utf8')\n        .split('\\n')\n        .map(line => line.trim())\n        .filter(line => line && !line.startsWith('#'));\n    }\n\n    // Combine all patterns\n    this.ignorePatterns = [\n      // System patterns (filtered by disabled list)\n      ...systemPatterns.filter(pattern =>\n        !this.hiddenFilesConfig.disabledSystemPatterns.includes(pattern)\n      ),\n      // File patterns\n      ...filePatterns.filter(pattern =>\n        !systemPatterns.includes(pattern) &&\n        !this.hiddenFilesConfig.userIgnorePatterns.includes(pattern)\n      ),\n      // User-added patterns\n      ...this.hiddenFilesConfig.userIgnorePatterns\n    ];\n\n    // Update .cntxignore file with current patterns\n    const allPatterns = [\n      '# System patterns',\n      ...systemPatterns.map(pattern =>\n        this.hiddenFilesConfig.disabledSystemPatterns.includes(pattern)\n          ? `# ${pattern}`\n          : pattern\n      ),\n      '',\n      '# User patterns',\n      ...this.hiddenFilesConfig.userIgnorePatterns,\n      '',\n      '# File-specific patterns (edit manually)',\n      ...filePatterns.filter(pattern =>\n        !systemPatterns.includes(pattern) &&\n        !this.hiddenFilesConfig.userIgnorePatterns.includes(pattern)\n      )\n    ];\n\n    writeFileSync(this.IGNORE_FILE, allPatterns.join('\\n'));\n  }\n\n  loadBundleStates() {\n    if (existsSync(this.BUNDLES_FILE)) {\n      try {\n        const savedBundles = JSON.parse(readFileSync(this.BUNDLES_FILE, 'utf8'));\n        Object.entries(savedBundles).forEach(([name, data]) => {\n          if (this.bundles.has(name)) {\n            const bundle = this.bundles.get(name);\n            bundle.content = data.content || '';\n            bundle.lastGenerated = data.lastGenerated;\n            bundle.size = data.size || 0;\n          }\n        });\n      } catch (e) {\n        if (!this.isQuietMode) console.warn('Could not load bundle states:', e.message);\n      }\n    }\n  }\n\n  saveBundleStates() {\n    const bundleStates = {};\n    this.bundles.forEach((bundle, name) => {\n      bundleStates[name] = {\n        content: bundle.content,\n        lastGenerated: bundle.lastGenerated,\n        size: bundle.size\n      };\n    });\n    writeFileSync(this.BUNDLES_FILE, JSON.stringify(bundleStates, null, 2));\n  }\n\n  // Cursor Rules Methods\n  loadCursorRules() {\n    if (existsSync(this.CURSOR_RULES_FILE)) {\n      return readFileSync(this.CURSOR_RULES_FILE, 'utf8');\n    }\n    return this.getDefaultCursorRules();\n  }\n\n  getDefaultCursorRules() {\n    // Get project info for context\n    let projectInfo = { name: 'unknown', description: '', type: 'general' };\n    const pkgPath = join(this.CWD, 'package.json');\n\n    if (existsSync(pkgPath)) {\n      try {\n        const pkg = JSON.parse(readFileSync(pkgPath, 'utf8'));\n        projectInfo = {\n          name: pkg.name || 'unknown',\n          description: pkg.description || '',\n          type: this.detectProjectType(pkg)\n        };\n      } catch (e) {\n        // Use defaults\n      }\n    }\n\n    return this.generateCursorRulesTemplate(projectInfo);\n  }\n\n  detectProjectType(pkg) {\n    const deps = { ...pkg.dependencies, ...pkg.devDependencies };\n\n    if (deps.react || deps['@types/react']) return 'react';\n    if (deps.vue || deps['@vue/cli']) return 'vue';\n    if (deps.angular || deps['@angular/core']) return 'angular';\n    if (deps.express || deps.fastify || deps.koa) return 'node';\n    if (deps.next || deps.nuxt || deps.gatsby) return 'fullstack';\n    if (deps.typescript || deps['@types/node']) return 'typescript';\n    if (pkg.type === 'module' || deps.vite || deps.webpack) return 'modern-js';\n\n    return 'general';\n  }\n\n  generateCursorRulesTemplate(projectInfo) {\n    const bundlesList = Array.from(this.bundles.keys()).join(', ');\n\n    const templates = {\n      react: `# ${projectInfo.name} - React Project Rules\n\n## Project Context\n- **Project**: ${projectInfo.name}\n- **Type**: React Application\n- **Description**: ${projectInfo.description}\n\n## Development Guidelines\n\n### Code Style\n- Use TypeScript for all new components\n- Prefer functional components with hooks\n- Use Tailwind CSS for styling\n- Follow React best practices and hooks rules\n\n### File Organization\n- Components in \\`src/components/\\`\n- Custom hooks in \\`src/hooks/\\`\n- Utilities in \\`src/lib/\\`\n- Types in \\`src/types/\\`\n\n### Naming Conventions\n- PascalCase for components\n- camelCase for functions and variables\n- kebab-case for files and folders\n- Use descriptive, meaningful names\n\n### Bundle Context\nThis project uses cntx-ui for file bundling. Current bundles: ${bundlesList}\n- **ui**: React components and styles\n- **api**: API routes and utilities  \n- **config**: Configuration files\n- **docs**: Documentation\n\n### AI Assistant Instructions\n- When suggesting code changes, consider the current bundle structure\n- Prioritize TypeScript and modern React patterns\n- Suggest Tailwind classes for styling\n- Keep components focused and reusable\n- Always include proper TypeScript types\n- Consider bundle organization when suggesting file locations\n\n## Custom Rules\nAdd your specific project rules and preferences below:\n\n### Team Preferences\n- [Add team coding standards]\n- [Add preferred libraries/frameworks]\n- [Add project-specific guidelines]\n\n### Architecture Notes\n- [Document key architectural decisions]\n- [Note important patterns to follow]\n- [List critical dependencies]\n`,\n\n      node: `# ${projectInfo.name} - Node.js Project Rules\n\n## Project Context\n- **Project**: ${projectInfo.name}\n- **Type**: Node.js Backend\n- **Description**: ${projectInfo.description}\n\n## Development Guidelines\n\n### Code Style\n- Use ES modules (import/export)\n- TypeScript preferred for type safety\n- Follow Node.js best practices\n- Use async/await over promises\n\n### File Organization\n- Routes in \\`src/routes/\\`\n- Middleware in \\`src/middleware/\\`\n- Models in \\`src/models/\\`\n- Utilities in \\`src/utils/\\`\n\n### Bundle Context\nThis project uses cntx-ui for file bundling. Current bundles: ${bundlesList}\n- **api**: Core API logic and routes\n- **config**: Environment and configuration\n- **docs**: API documentation\n\n### AI Assistant Instructions\n- Focus on scalable backend architecture\n- Suggest proper error handling\n- Consider security best practices\n- Optimize for performance and maintainability\n- Consider bundle organization when suggesting file locations\n\n## Custom Rules\nAdd your specific project rules and preferences below:\n\n### Team Preferences\n- [Add team coding standards]\n- [Add preferred libraries/frameworks]\n- [Add project-specific guidelines]\n\n### Architecture Notes\n- [Document key architectural decisions]\n- [Note important patterns to follow]\n- [List critical dependencies]\n`,\n\n      general: `# ${projectInfo.name} - Project Rules\n\n## Project Context\n- **Project**: ${projectInfo.name}\n- **Description**: ${projectInfo.description}\n\n## Development Guidelines\n\n### Code Quality\n- Write clean, readable code\n- Follow consistent naming conventions\n- Add comments for complex logic\n- Maintain proper file organization\n\n### Bundle Management\nThis project uses cntx-ui for intelligent file bundling. Current bundles: ${bundlesList}\n- **master**: Complete project overview\n- **config**: Configuration and setup files\n- **docs**: Documentation and README files\n\n### AI Assistant Instructions\n- When helping with code, consider the project structure\n- Suggest improvements for maintainability\n- Follow established patterns in the codebase\n- Help optimize bundle configurations when needed\n- Consider bundle organization when suggesting file locations\n\n## Custom Rules\nAdd your specific project rules and preferences below:\n\n### Team Preferences\n- [Add team coding standards]\n- [Add preferred libraries/frameworks]\n- [Add project-specific guidelines]\n\n### Architecture Notes\n- [Document key architectural decisions]\n- [Note important patterns to follow]\n- [List critical dependencies]\n`\n    };\n\n    return templates[projectInfo.type] || templates.general;\n  }\n\n  saveCursorRules(content) {\n    writeFileSync(this.CURSOR_RULES_FILE, content, 'utf8');\n  }\n\n  loadClaudeMd() {\n    if (existsSync(this.CLAUDE_MD_FILE)) {\n      return readFileSync(this.CLAUDE_MD_FILE, 'utf8');\n    }\n    return this.getDefaultClaudeMd();\n  }\n\n  getDefaultClaudeMd() {\n    // Get project info for context\n    let projectInfo = { name: 'unknown', description: '', type: 'general' };\n    const pkgPath = join(this.CWD, 'package.json');\n\n    if (existsSync(pkgPath)) {\n      try {\n        const pkg = JSON.parse(readFileSync(pkgPath, 'utf8'));\n        projectInfo = {\n          name: pkg.name || 'unknown',\n          description: pkg.description || '',\n          type: this.detectProjectType(pkg)\n        };\n      } catch (e) {\n        // Use defaults if package.json is invalid\n      }\n    }\n\n    return this.generateClaudeMdTemplate(projectInfo);\n  }\n\n  generateClaudeMdTemplate(projectInfo) {\n    const { name, description, type } = projectInfo;\n\n    let template = `# ${name}\n\n${description ? `${description}\\n\\n` : ''}## Project Structure\n\nThis project uses cntx-ui for bundle management and AI context organization.\n\n### Bundles\n\n`;\n\n    // Add bundle information\n    this.bundles.forEach((bundle, bundleName) => {\n      template += `- **${bundleName}**: ${bundle.files.length} files\\n`;\n    });\n\n    template += `\n### Development Guidelines\n\n- Follow the existing code style and patterns\n- Use TypeScript for type safety\n- Write meaningful commit messages\n- Test changes thoroughly\n\n### Key Files\n\n- \\`.cntx/config.json\\` - Bundle configuration\n- \\`.cursorrules\\` - AI assistant rules\n- \\`CLAUDE.md\\` - Project context for Claude\n`;\n\n    if (type === 'react') {\n      template += `\n### React Specific\n\n- Use functional components with hooks\n- Follow React best practices\n- Use TypeScript interfaces for props\n`;\n    } else if (type === 'node') {\n      template += `\n### Node.js Specific\n\n- Use ES modules (import/export)\n- Follow async/await patterns\n- Proper error handling\n`;\n    }\n\n    return template;\n  }\n\n  saveClaudeMd(content) {\n    writeFileSync(this.CLAUDE_MD_FILE, content, 'utf8');\n  }\n\n  shouldIgnoreFile(filePath) {\n    const relativePath = relative(this.CWD, filePath).replace(/\\\\\\\\/g, '/');\n\n    // Hard-coded critical ignores\n    if (relativePath.startsWith('node_modules/')) return true;\n    if (relativePath.startsWith('.git/')) return true;\n    if (relativePath.startsWith('.cntx/')) return true;\n\n    return this.ignorePatterns.some(pattern => this.matchesPattern(relativePath, pattern));\n  }\n\n  matchesPattern(path, pattern) {\n    if (pattern === '**/*') return true;\n    if (pattern === '*') return !path.includes('/');\n    if (pattern === path) return true;\n\n    let regexPattern = pattern\n      .replace(/\\\\/g, '/')\n      .replace(/\\./g, '\\\\.')\n      .replace(/\\?/g, '.');\n\n    regexPattern = regexPattern.replace(/\\*\\*/g, 'DOUBLESTAR');\n    regexPattern = regexPattern.replace(/\\*/g, '[^/]*');\n    regexPattern = regexPattern.replace(/DOUBLESTAR/g, '.*');\n\n    try {\n      const regex = new RegExp('^' + regexPattern + '$');\n      return regex.test(path);\n    } catch (e) {\n      if (!this.isQuietMode) console.log(`Regex error for pattern \"${pattern}\": ${e.message}`);\n      return false;\n    }\n  }\n\n  shouldIgnoreAnything(itemName, fullPath) {\n    // DIRECTORY NAME IGNORES (anywhere in the project)\n    const badDirectories = [\n      'node_modules',\n      '.git',\n      '.svn',\n      '.hg',\n      'vendor',\n      '__pycache__',\n      '.pytest_cache',\n      '.venv',\n      'venv',\n      'env',\n      '.env',\n      'dist',\n      'build',\n      'out',\n      '.next',\n      '.nuxt',\n      'coverage',\n      '.nyc_output',\n      '.cache',\n      '.parcel-cache',\n      '.vercel',\n      '.netlify',\n      'tmp',\n      'temp',\n      '.tmp',\n      '.temp',\n      'logs',\n      '*.egg-info',\n      '.cntx'\n    ];\n\n    if (badDirectories.includes(itemName)) {\n      return true;\n    }\n\n    // FILE EXTENSION IGNORES\n    const badExtensions = [\n      // Logs\n      '.log', '.logs',\n      // OS files\n      '.DS_Store', '.Thumbs.db', 'desktop.ini',\n      // Editor files\n      '.vscode', '.idea', '*.swp', '*.swo', '*~',\n      // Media files (large and useless for AI)\n      '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.webp', '.svg',\n      '.mp4', '.avi', '.mov', '.wmv', '.flv', '.webm', '.mkv',\n      '.mp3', '.wav', '.flac', '.aac', '.ogg', '.wma',\n      '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx',\n      '.zip', '.tar', '.gz', '.rar', '.7z', '.bz2',\n      '.exe', '.dll', '.so', '.dylib', '.app', '.dmg', '.pkg',\n      // Cache/temp files\n      '.cache', '.tmp', '.temp', '.lock',\n      // Compiled files\n      '.pyc', '.pyo', '.class', '.o', '.obj', '.a', '.lib'\n    ];\n\n    const fileExt = extname(itemName).toLowerCase();\n    if (badExtensions.includes(fileExt)) {\n      return true;\n    }\n\n    // FILE NAME PATTERNS\n    const badFilePatterns = [\n      /^\\..*/, // Hidden files starting with .\n      /.*\\.lock$/, // Lock files\n      /.*\\.min\\.js$/, // Minified JS\n      /.*\\.min\\.css$/, // Minified CSS\n      /.*\\.map$/, // Source maps\n      /package-lock\\.json$/,\n      /yarn\\.lock$/,\n      /pnpm-lock\\.yaml$/,\n      /Thumbs\\.db$/,\n      /\\.DS_Store$/\n    ];\n\n    if (badFilePatterns.some(pattern => pattern.test(itemName))) {\n      return true;\n    }\n\n    // PATH-BASED IGNORES (from your .cntxignore)\n    return this.ignorePatterns.some(pattern => this.matchesPattern(fullPath, pattern));\n  }\n\n  getAllFiles(dir = this.CWD, files = []) {\n    try {\n      const items = readdirSync(dir);\n      for (const item of items) {\n        const fullPath = join(dir, item);\n        const relativePath = relative(this.CWD, fullPath).replace(/\\\\\\\\/g, '/');\n\n        // BULLETPROOF IGNORES - check directory/file names directly\n        const shouldIgnore = this.shouldIgnoreAnything(item, relativePath);\n\n        if (shouldIgnore) {\n          continue; // Don't even log it, just skip\n        }\n\n        const stat = statSync(fullPath);\n        if (stat.isDirectory()) {\n          this.getAllFiles(fullPath, files);\n        } else {\n          files.push(relativePath);\n        }\n      }\n    } catch (e) {\n      // Skip directories we can't read\n    }\n\n    return files;\n  }\n\n  startWatching() {\n    const watcher = watch(this.CWD, { recursive: true }, (eventType, filename) => {\n      if (filename && !this.isScanning) {\n        const fullPath = join(this.CWD, filename);\n        if (!this.shouldIgnoreFile(fullPath)) {\n          if (!this.isQuietMode) console.log(`File ${eventType}: ${filename}`);\n          this.markBundlesChanged(filename.replace(/\\\\\\\\/g, '/'));\n          this.invalidateSemanticCache(); // Invalidate semantic cache on file changes\n          this.broadcastUpdate();\n        }\n      }\n    });\n    this.watchers.push(watcher);\n  }\n\n  getFileTree() {\n    const allFiles = this.getAllFiles();\n    const fileData = allFiles.map(file => {\n      const fullPath = join(this.CWD, file);\n      try {\n        const stat = statSync(fullPath);\n        return {\n          path: file,\n          size: stat.size,\n          modified: stat.mtime\n        };\n      } catch (e) {\n        return {\n          path: file,\n          size: 0,\n          modified: new Date()\n        };\n      }\n    });\n    return fileData;\n  }\n\n  markBundlesChanged(filename) {\n    this.bundles.forEach((bundle, name) => {\n      if (bundle.patterns.some(pattern => this.matchesPattern(filename, pattern))) {\n        bundle.changed = true;\n      }\n    });\n  }\n\n  generateAllBundles() {\n    this.isScanning = true;\n    if (!this.isQuietMode) console.log('Scanning files and generating bundles...');\n\n    this.bundles.forEach((bundle, name) => {\n      this.generateBundle(name);\n    });\n\n    this.saveBundleStates();\n    this.isScanning = false;\n    if (!this.isQuietMode) console.log('Bundle generation complete');\n  }\n\n  generateBundle(name) {\n    const bundle = this.bundles.get(name);\n    if (!bundle) return;\n\n    if (!this.isQuietMode) console.log(`Generating bundle: ${name}`);\n    const allFiles = this.getAllFiles();\n\n    // Filter files by bundle patterns\n    let bundleFiles = allFiles.filter(file =>\n      bundle.patterns.some(pattern => this.matchesPattern(file, pattern))\n    );\n\n    // Remove hidden files\n    bundleFiles = bundleFiles.filter(file => !this.isFileHidden(file, name));\n\n    bundle.files = bundleFiles;\n    bundle.content = this.generateBundleXML(name, bundle.files);\n    bundle.changed = false;\n    bundle.lastGenerated = new Date().toISOString();\n    bundle.size = Buffer.byteLength(bundle.content, 'utf8');\n\n    if (!this.isQuietMode) console.log(`Generated bundle '${name}' with ${bundle.files.length} files (${(bundle.size / 1024).toFixed(1)}kb)`);\n  }\n\n  generateBundleXML(bundleName, files) {\n    let xml = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<cntx:bundle xmlns:cntx=\"https://cntx.dev/schema\" name=\"${bundleName}\" generated=\"${new Date().toISOString()}\">\n`;\n\n    // Project information\n    const pkgPath = join(this.CWD, 'package.json');\n    if (existsSync(pkgPath)) {\n      try {\n        const pkg = JSON.parse(readFileSync(pkgPath, 'utf8'));\n        xml += `  <cntx:project>\n    <cntx:name>${this.escapeXml(pkg.name || 'unknown')}</cntx:name>\n    <cntx:version>${pkg.version || '0.0.0'}</cntx:version>\n`;\n        if (pkg.description) xml += `    <cntx:description>${this.escapeXml(pkg.description)}</cntx:description>\n`;\n        xml += `  </cntx:project>\n`;\n      } catch (e) {\n        xml += `  <cntx:project><cntx:error>Could not parse package.json</cntx:error></cntx:project>\n`;\n      }\n    }\n\n    // Bundle overview section\n    const filesByType = this.categorizeFiles(files);\n    const entryPoints = this.identifyEntryPoints(files);\n\n    xml += `  <cntx:overview>\n    <cntx:purpose>${this.escapeXml(this.getBundlePurpose(bundleName))}</cntx:purpose>\n    <cntx:file-types>\n`;\n\n    Object.entries(filesByType).forEach(([type, typeFiles]) => {\n      xml += `      <cntx:type name=\"${type}\" count=\"${typeFiles.length}\" />\n`;\n    });\n\n    xml += `    </cntx:file-types>\n`;\n\n    if (entryPoints.length > 0) {\n      xml += `    <cntx:entry-points>\n`;\n      entryPoints.forEach(file => {\n        xml += `      <cntx:file>${file}</cntx:file>\n`;\n      });\n      xml += `    </cntx:entry-points>\n`;\n    }\n\n    xml += `  </cntx:overview>\n`;\n\n    // Files organized by type\n    xml += `  <cntx:files count=\"${files.length}\">\n`;\n\n    // Entry points first\n    if (entryPoints.length > 0) {\n      xml += `    <cntx:group type=\"entry-points\" description=\"Main entry files for this bundle\">\n`;\n      entryPoints.forEach(file => {\n        xml += this.generateFileXML(file);\n      });\n      xml += `    </cntx:group>\n`;\n    }\n\n    // Then organize by file type\n    Object.entries(filesByType).forEach(([type, typeFiles]) => {\n      if (type === 'entry-points') return; // Already handled above\n\n      const remainingFiles = typeFiles.filter(file => !entryPoints.includes(file));\n      if (remainingFiles.length > 0) {\n        xml += `    <cntx:group type=\"${type}\" description=\"${this.getTypeDescription(type)}\">\n`;\n        remainingFiles.forEach(file => {\n          xml += this.generateFileXML(file);\n        });\n        xml += `    </cntx:group>\n`;\n      }\n    });\n\n    xml += `  </cntx:files>\n</cntx:bundle>`;\n    return xml;\n  }\n\n  categorizeFiles(files) {\n    const categories = {\n      'components': [],\n      'hooks': [],\n      'utilities': [],\n      'configuration': [],\n      'styles': [],\n      'types': [],\n      'tests': [],\n      'documentation': [],\n      'other': []\n    };\n\n    files.forEach(file => {\n      const ext = extname(file).toLowerCase();\n      const basename = file.toLowerCase();\n\n      if (basename.includes('component') || file.includes('/components/') ||\n        ext === '.jsx' || ext === '.tsx' && !basename.includes('test')) {\n        categories.components.push(file);\n      } else if (basename.includes('hook') || file.includes('/hooks/')) {\n        categories.hooks.push(file);\n      } else if (basename.includes('util') || file.includes('/utils/') ||\n        basename.includes('helper') || file.includes('/lib/')) {\n        categories.utilities.push(file);\n      } else if (ext === '.json' || basename.includes('config') ||\n        ext === '.yaml' || ext === '.yml' || ext === '.toml') {\n        categories.configuration.push(file);\n      } else if (ext === '.css' || ext === '.scss' || ext === '.less') {\n        categories.styles.push(file);\n      } else if (basename.includes('type') || ext === '.d.ts' ||\n        file.includes('/types/')) {\n        categories.types.push(file);\n      } else if (basename.includes('test') || basename.includes('spec') ||\n        file.includes('/test/') || file.includes('/__tests__/')) {\n        categories.tests.push(file);\n      } else if (ext === '.md' || basename.includes('readme') ||\n        basename.includes('doc')) {\n        categories.documentation.push(file);\n      } else {\n        categories.other.push(file);\n      }\n    });\n\n    // Remove empty categories\n    Object.keys(categories).forEach(key => {\n      if (categories[key].length === 0) {\n        delete categories[key];\n      }\n    });\n\n    return categories;\n  }\n\n  identifyEntryPoints(files) {\n    const entryPoints = [];\n\n    files.forEach(file => {\n      const basename = file.toLowerCase();\n\n      // Common entry point patterns\n      if (basename.includes('main.') || basename.includes('index.') ||\n        basename.includes('app.') || basename === 'server.js' ||\n        file.endsWith('/App.tsx') || file.endsWith('/App.jsx') ||\n        file.endsWith('/main.tsx') || file.endsWith('/main.js') ||\n        file.endsWith('/index.tsx') || file.endsWith('/index.js')) {\n        entryPoints.push(file);\n      }\n    });\n\n    return entryPoints;\n  }\n\n  getBundlePurpose(bundleName) {\n    const purposes = {\n      'master': 'Complete project overview with all source files',\n      'frontend': 'User interface components, pages, and client-side logic',\n      'backend': 'Server-side logic, APIs, and backend services',\n      'api': 'API endpoints, routes, and server communication logic',\n      'server': 'Main server application and core backend functionality',\n      'components': 'Reusable UI components and interface elements',\n      'ui-components': 'User interface components and design system elements',\n      'config': 'Configuration files, settings, and environment setup',\n      'docs': 'Documentation, README files, and project guides',\n      'utils': 'Utility functions, helpers, and shared libraries',\n      'types': 'TypeScript type definitions and interfaces',\n      'tests': 'Test files, test utilities, and testing configuration'\n    };\n\n    return purposes[bundleName] || `Bundle containing ${bundleName}-related files`;\n  }\n\n  getTypeDescription(type) {\n    const descriptions = {\n      'components': 'React/UI components and interface elements',\n      'hooks': 'Custom React hooks and state management',\n      'utilities': 'Helper functions, utilities, and shared libraries',\n      'configuration': 'Configuration files, settings, and build configs',\n      'styles': 'CSS, SCSS, and styling files',\n      'types': 'TypeScript type definitions and interfaces',\n      'tests': 'Test files and testing utilities',\n      'documentation': 'README files, docs, and guides',\n      'other': 'Additional project files'\n    };\n\n    return descriptions[type] || `Files categorized as ${type}`;\n  }\n\n  generateFileXML(file) {\n    const fullPath = join(this.CWD, file);\n    let fileXml = `      <cntx:file path=\"${file}\" ext=\"${extname(file)}\">\n`;\n\n    try {\n      const stat = statSync(fullPath);\n      const content = readFileSync(fullPath, 'utf8');\n\n      // Add role indicator for certain files\n      const role = this.getFileRole(file);\n      const roleAttr = role ? ` role=\"${role}\"` : '';\n\n      fileXml = `      <cntx:file path=\"${file}\" ext=\"${extname(file)}\"${roleAttr}>\n`;\n      fileXml += `        <cntx:meta size=\"${stat.size}\" modified=\"${stat.mtime.toISOString()}\" lines=\"${content.split('\\n').length}\" />\n        <cntx:content><![CDATA[${content}]]></cntx:content>\n`;\n    } catch (e) {\n      fileXml += `        <cntx:error>Could not read file: ${e.message}</cntx:error>\n`;\n    }\n\n    fileXml += `      </cntx:file>\n`;\n    return fileXml;\n  }\n\n  getFileRole(file) {\n    const basename = file.toLowerCase();\n\n    if (basename.includes('main.') || basename.includes('index.')) return 'entry-point';\n    if (basename.includes('app.')) return 'main-component';\n    if (file === 'server.js') return 'server-entry';\n    if (basename.includes('config')) return 'configuration';\n    if (basename.includes('package.json')) return 'package-config';\n    if (basename.includes('readme')) return 'documentation';\n\n    return null;\n  }\n\n  escapeXml(text) {\n    return String(text)\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&apos;');\n  }\n\n  getFileStats(filePath) {\n    try {\n      const fullPath = join(this.CWD, filePath);\n      const stat = statSync(fullPath);\n      return {\n        size: stat.size,\n        mtime: stat.mtime\n      };\n    } catch (e) {\n      return {\n        size: 0,\n        mtime: new Date()\n      };\n    }\n  }\n\n  getFileListWithVisibility(bundleName = null) {\n    const allFiles = this.getAllFiles();\n\n    return allFiles.map(filePath => {\n      const fileStats = this.getFileStats(filePath);\n      const isGloballyHidden = this.hiddenFilesConfig.globalHidden.includes(filePath);\n      const bundleHidden = bundleName ? this.isFileHidden(filePath, bundleName) : false;\n\n      // Determine which bundles this file appears in\n      const inBundles = [];\n      this.bundles.forEach((bundle, name) => {\n        const matchesPattern = bundle.patterns.some(pattern => this.matchesPattern(filePath, pattern));\n        const notHidden = !this.isFileHidden(filePath, name);\n        if (matchesPattern && notHidden) {\n          inBundles.push(name);\n        }\n      });\n\n      return {\n        path: filePath,\n        size: fileStats.size,\n        modified: fileStats.mtime,\n        visible: !isGloballyHidden && !bundleHidden,\n        globallyHidden: isGloballyHidden,\n        bundleHidden: bundleHidden,\n        inBundles: inBundles,\n        matchesIgnorePattern: this.shouldIgnoreFile(join(this.CWD, filePath))\n      };\n    });\n  }\n\n  startServer(port = 3333) {\n    const server = createServer((req, res) => {\n      const url = new URL(req.url, `http://localhost:${port}`);\n\n      // CORS headers for ALL requests - MUST be first\n      res.setHeader('Access-Control-Allow-Origin', '*');\n      res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');\n      res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n      res.setHeader('Access-Control-Max-Age', '86400');\n\n      // Handle preflight OPTIONS requests\n      if (req.method === 'OPTIONS') {\n        res.writeHead(200);\n        res.end();\n        return;\n      }\n\n      // Serve static files for web interface\n      if (url.pathname === '/' || url.pathname.startsWith('/assets/') || url.pathname.endsWith('.js') || url.pathname.endsWith('.css') || url.pathname.endsWith('.ico')) {\n        const webDistPath = path.join(__dirname, 'web', 'dist');\n\n        if (url.pathname === '/') {\n          // Serve index.html for root\n          const indexPath = path.join(webDistPath, 'index.html');\n          if (existsSync(indexPath)) {\n            try {\n              const content = readFileSync(indexPath, 'utf8');\n              res.writeHead(200, { 'Content-Type': 'text/html' });\n              res.end(content);\n              return;\n            } catch (e) {\n              if (!this.isQuietMode) console.error('Error serving index.html:', e);\n            }\n          }\n\n          // Fallback if no web interface built\n          res.writeHead(200, { 'Content-Type': 'text/html' });\n          res.end(`\n          <!DOCTYPE html>\n          <html>\n            <head>\n              <title>cntx-ui Server</title>\n              <style>\n                body { font-family: system-ui, sans-serif; margin: 40px; }\n                .container { max-width: 600px; }\n                .api-link { background: #f5f5f5; padding: 10px; border-radius: 5px; margin: 10px 0; }\n                code { background: #f0f0f0; padding: 2px 5px; border-radius: 3px; }\n              </style>\n            </head>\n            <body>\n              <div class=\"container\">\n                <h1>🚀 cntx-ui Server Running</h1>\n                <p>Your cntx-ui server is running successfully!</p>\n                \n                <h2>Available APIs:</h2>\n                <div class=\"api-link\">\n                  <strong>Bundles:</strong> <a href=\"/api/bundles\">/api/bundles</a>\n                </div>\n                <div class=\"api-link\">\n                  <strong>Configuration:</strong> <a href=\"/api/config\">/api/config</a>\n                </div>\n                <div class=\"api-link\">\n                  <strong>Files:</strong> <a href=\"/api/files\">/api/files</a>\n                </div>\n                <div class=\"api-link\">\n                  <strong>Status:</strong> <a href=\"/api/status\">/api/status</a>\n                </div>\n                \n                <h2>Web Interface:</h2>\n                <p>The web interface is not available because it wasn't built when this package was published.</p>\n                <p>To enable the web interface, the package maintainer needs to run:</p>\n                <pre><code>cd web && npm install && npm run build</code></pre>\n                \n                <h2>CLI Usage:</h2>\n                <p>You can still use all CLI commands:</p>\n                <ul>\n                  <li><code>cntx-ui status</code> - Check current status</li>\n                  <li><code>cntx-ui bundle master</code> - Generate specific bundle</li>\n                  <li><code>cntx-ui init</code> - Initialize configuration</li>\n                </ul>\n              </div>\n            </body>\n          </html>\n        `);\n          return;\n        } else {\n          // Serve other static assets\n          const filePath = path.join(webDistPath, url.pathname);\n          if (existsSync(filePath)) {\n            try {\n              const content = readFileSync(filePath);\n              const contentType = getContentType(filePath);\n              res.writeHead(200, { 'Content-Type': contentType });\n              res.end(content);\n              return;\n            } catch (e) {\n              if (!this.isQuietMode) console.error('Error serving static file:', e);\n            }\n          }\n        }\n      }\n\n      // API Routes\n      console.log('🔍 Processing API request:', url.pathname);\n\n      if (url.pathname === '/api/bundles') {\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        const bundleData = Array.from(this.bundles.entries()).map(([name, bundle]) => ({\n          name,\n          changed: bundle.changed,\n          fileCount: bundle.files.length,\n          content: bundle.content.substring(0, 5000) + (bundle.content.length > 5000 ? '...' : ''),\n          files: bundle.files,\n          lastGenerated: bundle.lastGenerated,\n          size: bundle.size\n        }));\n        res.end(JSON.stringify(bundleData));\n\n      } else if (url.pathname === '/api/semantic-chunks') {\n        console.log('🔍 Semantic chunks route matched! URL:', url.pathname);\n        this.getSemanticAnalysis()\n          .then(analysis => {\n            console.log('✅ Semantic analysis successful');\n            res.writeHead(200, { 'Content-Type': 'application/json' });\n            res.end(JSON.stringify(analysis));\n          })\n          .catch(error => {\n            console.error('❌ Semantic analysis failed:', error.message);\n            res.writeHead(500, { 'Content-Type': 'application/json' });\n            res.end(JSON.stringify({ error: error.message }));\n          });\n\n      } else if (url.pathname === '/api/semantic-chunks/export') {\n        if (req.method === 'POST') {\n          let body = '';\n          req.on('data', chunk => body += chunk);\n          req.on('end', () => {\n            try {\n              const { chunkName } = JSON.parse(body);\n              this.exportSemanticChunk(chunkName)\n                .then(xmlContent => {\n                  res.writeHead(200, { 'Content-Type': 'application/xml' });\n                  res.end(xmlContent);\n                })\n                .catch(error => {\n                  res.writeHead(500, { 'Content-Type': 'application/json' });\n                  res.end(JSON.stringify({ error: error.message }));\n                });\n            } catch (error) {\n              res.writeHead(500, { 'Content-Type': 'application/json' });\n              res.end(JSON.stringify({ error: error.message }));\n            }\n          });\n        } else {\n          res.writeHead(405);\n          res.end('Method not allowed');\n        }\n\n      } else if (url.pathname === '/api/bundles-from-chunk') {\n        if (req.method === 'POST') {\n          let body = '';\n          req.on('data', chunk => body += chunk);\n          req.on('end', () => {\n            try {\n              const { chunkName, files } = JSON.parse(body);\n              this.createBundleFromChunk(chunkName, files)\n                .then(() => {\n                  res.writeHead(200, { 'Content-Type': 'application/json' });\n                  res.end(JSON.stringify({ success: true }));\n                })\n                .catch(error => {\n                  res.writeHead(500, { 'Content-Type': 'application/json' });\n                  res.end(JSON.stringify({ error: error.message }));\n                });\n            } catch (error) {\n              res.writeHead(500, { 'Content-Type': 'application/json' });\n              res.end(JSON.stringify({ error: error.message }));\n            }\n          });\n        } else {\n          res.writeHead(405);\n          res.end('Method not allowed');\n        }\n\n      } else if (url.pathname.startsWith('/api/bundles/')) {\n        const bundleName = url.pathname.split('/').pop();\n        const bundle = this.bundles.get(bundleName);\n        if (bundle) {\n          res.writeHead(200, { 'Content-Type': 'application/xml' });\n          res.end(bundle.content);\n        } else {\n          res.writeHead(404);\n          res.end('Bundle not found');\n        }\n\n      } else if (url.pathname.startsWith('/api/regenerate/')) {\n        const bundleName = url.pathname.split('/').pop();\n        if (this.bundles.has(bundleName)) {\n          this.generateBundle(bundleName);\n          this.saveBundleStates();\n          this.broadcastUpdate();\n          res.writeHead(200);\n          res.end('OK');\n        } else {\n          res.writeHead(404);\n          res.end('Bundle not found');\n        }\n\n      } else if (url.pathname === '/api/files') {\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        const fileTree = this.getFileTree();\n        res.end(JSON.stringify(fileTree));\n\n      } else if (url.pathname === '/api/config') {\n        if (req.method === 'GET') {\n          res.writeHead(200, { 'Content-Type': 'application/json' });\n          if (existsSync(this.CONFIG_FILE)) {\n            const config = readFileSync(this.CONFIG_FILE, 'utf8');\n            res.end(config);\n          } else {\n            const defaultConfig = {\n              bundles: {\n                master: ['**/*'],\n                api: ['src/api.js'],\n                ui: ['src/component.jsx', 'src/*.jsx'],\n                config: ['package.json', 'package-lock.json', '*.config.*'],\n                docs: ['README.md', '*.md']\n              }\n            };\n            res.end(JSON.stringify(defaultConfig));\n          }\n        } else if (req.method === 'POST') {\n          let body = '';\n          req.on('data', chunk => body += chunk);\n          req.on('end', () => {\n            try {\n              if (!this.isQuietMode) console.log('🔍 Received config save request');\n              const config = JSON.parse(body);\n              if (!this.isQuietMode) console.log('📝 Config to save:', JSON.stringify(config, null, 2));\n\n              // Ensure .cntx directory exists\n              if (!existsSync(this.CNTX_DIR)) {\n                if (!this.isQuietMode) console.log('📁 Creating .cntx directory...');\n                mkdirSync(this.CNTX_DIR, { recursive: true });\n              }\n\n              // Write config file\n              if (!this.isQuietMode) console.log('💾 Writing config to:', this.CONFIG_FILE);\n              writeFileSync(this.CONFIG_FILE, JSON.stringify(config, null, 2));\n              if (!this.isQuietMode) console.log('✅ Config file written successfully');\n\n              // Reload configuration\n              this.loadConfig();\n              this.generateAllBundles();\n              this.broadcastUpdate();\n\n              res.writeHead(200, { 'Content-Type': 'text/plain' });\n              res.end('OK');\n              if (!this.isQuietMode) console.log('✅ Config save response sent');\n\n            } catch (e) {\n              if (!this.isQuietMode) console.error('❌ Config save error:', e);\n              res.writeHead(400, { 'Content-Type': 'text/plain' });\n              res.end(`Error: ${e.message}`);\n            }\n          });\n\n          req.on('error', (err) => {\n            if (!this.isQuietMode) console.error('❌ Request error:', err);\n            if (!res.headersSent) {\n              res.writeHead(500, { 'Content-Type': 'text/plain' });\n              res.end('Internal Server Error');\n            }\n          });\n        }\n\n      } else if (url.pathname === '/api/cursor-rules') {\n        if (req.method === 'GET') {\n          res.writeHead(200, { 'Content-Type': 'text/plain' });\n          const rules = this.loadCursorRules();\n          res.end(rules);\n        } else if (req.method === 'POST') {\n          let body = '';\n          req.on('data', chunk => body += chunk);\n          req.on('end', () => {\n            try {\n              const { content } = JSON.parse(body);\n              this.saveCursorRules(content);\n              res.writeHead(200);\n              res.end('OK');\n            } catch (e) {\n              res.writeHead(400);\n              res.end('Invalid request');\n            }\n          });\n        }\n\n      } else if (url.pathname === '/api/cursor-rules/templates') {\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        const templates = {\n          react: this.generateCursorRulesTemplate({ name: 'My React App', description: 'React application', type: 'react' }),\n          node: this.generateCursorRulesTemplate({ name: 'My Node App', description: 'Node.js backend', type: 'node' }),\n          general: this.generateCursorRulesTemplate({ name: 'My Project', description: 'General project', type: 'general' })\n        };\n        res.end(JSON.stringify(templates));\n\n      } else if (url.pathname === '/api/claude-md') {\n        if (req.method === 'GET') {\n          res.writeHead(200, { 'Content-Type': 'text/plain' });\n          const claudeMd = this.loadClaudeMd();\n          res.end(claudeMd);\n        } else if (req.method === 'POST') {\n          let body = '';\n          req.on('data', chunk => body += chunk);\n          req.on('end', () => {\n            try {\n              const { content } = JSON.parse(body);\n              this.saveClaudeMd(content);\n              res.writeHead(200);\n              res.end('OK');\n            } catch (e) {\n              res.writeHead(400);\n              res.end('Invalid request');\n            }\n          });\n        }\n\n      } else if (url.pathname === '/api/test-pattern') {\n        if (req.method === 'POST') {\n          let body = '';\n          req.on('data', chunk => body += chunk);\n          req.on('end', () => {\n            try {\n              const { pattern } = JSON.parse(body);\n              const allFiles = this.getAllFiles();\n              const matchingFiles = allFiles.filter(file =>\n                this.matchesPattern(file, pattern)\n              );\n\n              res.writeHead(200, { 'Content-Type': 'application/json' });\n              res.end(JSON.stringify(matchingFiles));\n            } catch (e) {\n              res.writeHead(400);\n              res.end('Invalid request');\n            }\n          });\n        } else {\n          res.writeHead(405);\n          res.end('Method not allowed');\n        }\n\n      } else if (url.pathname === '/api/hidden-files') {\n        if (req.method === 'GET') {\n          res.writeHead(200, { 'Content-Type': 'application/json' });\n          const stats = {\n            totalFiles: this.getAllFiles().length,\n            globallyHidden: this.hiddenFilesConfig.globalHidden.length,\n            bundleSpecificHidden: this.hiddenFilesConfig.bundleSpecific,\n            ignorePatterns: {\n              system: [\n                { pattern: '**/.git/**', active: !this.hiddenFilesConfig.disabledSystemPatterns.includes('**/.git/**') },\n                { pattern: '**/node_modules/**', active: !this.hiddenFilesConfig.disabledSystemPatterns.includes('**/node_modules/**') },\n                { pattern: '**/.cntx/**', active: !this.hiddenFilesConfig.disabledSystemPatterns.includes('**/.cntx/**') }\n              ],\n              user: this.hiddenFilesConfig.userIgnorePatterns,\n              disabled: this.hiddenFilesConfig.disabledSystemPatterns\n            }\n          };\n          res.end(JSON.stringify(stats));\n        } else if (req.method === 'POST') {\n          let body = '';\n          req.on('data', chunk => body += chunk);\n          req.on('end', () => {\n            try {\n              const { action, filePath, filePaths, bundleName, forceHide } = JSON.parse(body);\n\n              if (action === 'toggle' && filePath) {\n                this.toggleFileVisibility(filePath, bundleName, forceHide);\n              } else if (action === 'bulk-toggle' && filePaths) {\n                this.bulkToggleFileVisibility(filePaths, bundleName, forceHide);\n              }\n\n              this.generateAllBundles();\n              this.broadcastUpdate();\n\n              res.writeHead(200, { 'Content-Type': 'application/json' });\n              res.end(JSON.stringify({ success: true }));\n            } catch (e) {\n              res.writeHead(400, { 'Content-Type': 'application/json' });\n              res.end(JSON.stringify({ error: e.message }));\n            }\n          });\n        }\n\n      } else if (url.pathname === '/api/files-with-visibility') {\n        const bundleName = url.searchParams.get('bundle');\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        const files = this.getFileListWithVisibility(bundleName);\n        res.end(JSON.stringify(files));\n\n      } else if (url.pathname === '/api/ignore-patterns') {\n        if (req.method === 'GET') {\n          res.writeHead(200, { 'Content-Type': 'application/json' });\n\n          // Read file patterns\n          let filePatterns = [];\n          if (existsSync(this.IGNORE_FILE)) {\n            filePatterns = readFileSync(this.IGNORE_FILE, 'utf8')\n              .split('\\n')\n              .map(line => line.trim())\n              .filter(line => line && !line.startsWith('#'));\n          }\n\n          const systemPatterns = ['**/.git/**', '**/node_modules/**', '**/.cntx/**'];\n\n          const patterns = {\n            system: systemPatterns.map(pattern => ({\n              pattern,\n              active: !this.hiddenFilesConfig.disabledSystemPatterns.includes(pattern)\n            })),\n            user: this.hiddenFilesConfig.userIgnorePatterns.map(pattern => ({ pattern, active: true })),\n            file: filePatterns.filter(pattern =>\n              !systemPatterns.includes(pattern) &&\n              !this.hiddenFilesConfig.userIgnorePatterns.includes(pattern)\n            ).map(pattern => ({ pattern, active: true }))\n          };\n          res.end(JSON.stringify(patterns));\n\n        } else if (req.method === 'POST') {\n          let body = '';\n          req.on('data', chunk => body += chunk);\n          req.on('end', () => {\n            try {\n              const { action, pattern } = JSON.parse(body);\n              let success = false;\n\n              switch (action) {\n                case 'add':\n                  success = this.addUserIgnorePattern(pattern);\n                  break;\n                case 'remove':\n                  success = this.removeUserIgnorePattern(pattern);\n                  break;\n                case 'toggle-system':\n                  this.toggleSystemIgnorePattern(pattern);\n                  success = true;\n                  break;\n              }\n\n              this.broadcastUpdate();\n              res.writeHead(200, { 'Content-Type': 'application/json' });\n              res.end(JSON.stringify({ success }));\n            } catch (e) {\n              res.writeHead(400, { 'Content-Type': 'application/json' });\n              res.end(JSON.stringify({ error: e.message }));\n            }\n          });\n        }\n\n      } else if (url.pathname === '/api/bundle-visibility-stats') {\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        const stats = {};\n\n        this.bundles.forEach((bundle, bundleName) => {\n          const allFiles = this.getAllFiles();\n          const matchingFiles = allFiles.filter(file =>\n            bundle.patterns.some(pattern => this.matchesPattern(file, pattern))\n          );\n\n          const visibleFiles = matchingFiles.filter(file => !this.isFileHidden(file, bundleName));\n          const hiddenFiles = matchingFiles.length - visibleFiles.length;\n\n          stats[bundleName] = {\n            total: matchingFiles.length,\n            visible: visibleFiles.length,\n            hidden: hiddenFiles,\n            patterns: bundle.patterns\n          };\n        });\n\n        res.end(JSON.stringify(stats));\n\n      } else if (url.pathname.startsWith('/api/bundle-categories/')) {\n        const bundleName = url.pathname.split('/').pop();\n        const bundle = this.bundles.get(bundleName);\n\n        if (bundle) {\n          const filesByType = this.categorizeFiles(bundle.files);\n          const entryPoints = this.identifyEntryPoints(bundle.files);\n\n          res.writeHead(200, { 'Content-Type': 'application/json' });\n          res.end(JSON.stringify({\n            purpose: this.getBundlePurpose(bundleName),\n            filesByType,\n            entryPoints,\n            totalFiles: bundle.files.length\n          }));\n        } else {\n          res.writeHead(404);\n          res.end('Bundle not found');\n        }\n\n      } else if (url.pathname === '/api/reset-hidden-files') {\n        if (req.method === 'POST') {\n          let body = '';\n          req.on('data', chunk => body += chunk);\n          req.on('end', () => {\n            try {\n              const { scope, bundleName } = JSON.parse(body);\n\n              if (scope === 'global') {\n                this.hiddenFilesConfig.globalHidden = [];\n              } else if (scope === 'bundle' && bundleName) {\n                delete this.hiddenFilesConfig.bundleSpecific[bundleName];\n              } else if (scope === 'all') {\n                this.hiddenFilesConfig.globalHidden = [];\n                this.hiddenFilesConfig.bundleSpecific = {};\n              }\n\n              this.saveHiddenFilesConfig();\n              this.generateAllBundles();\n              this.broadcastUpdate();\n\n              res.writeHead(200, { 'Content-Type': 'application/json' });\n              res.end(JSON.stringify({ success: true }));\n            } catch (e) {\n              res.writeHead(400, { 'Content-Type': 'application/json' });\n              res.end(JSON.stringify({ error: e.message }));\n            }\n          });\n        }\n\n      } else if (url.pathname === '/api/mcp-status') {\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n\n        // Simple check - MCP is available if we can find package.json\n        let isAccessible = true;\n        let testResult = 'available';\n\n        // Check if package.json exists using existing imports\n        try {\n          const packagePath = join(this.CWD, 'package.json');\n          if (existsSync(packagePath)) {\n            testResult = 'local_package_found';\n          } else {\n            testResult = 'using_global_npx';\n          }\n        } catch (error) {\n          testResult = 'check_failed';\n        }\n\n        const mcpStatus = {\n          running: isAccessible,\n          accessible: isAccessible,\n          testResult: testResult,\n          command: 'npx cntx-ui mcp',\n          workingDirectory: this.CWD,\n          lastChecked: new Date().toISOString(),\n          trackingEnabled: this.mcpServerStarted || false\n        };\n        res.end(JSON.stringify(mcpStatus, null, 2));\n\n      } else if (url.pathname === '/api/status') {\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        const statusInfo = {\n          server: {\n            version: '2.0.8',\n            workingDirectory: this.CWD,\n            startTime: new Date().toISOString(),\n            isScanning: this.isScanning\n          },\n          bundles: {\n            count: this.bundles.size,\n            names: Array.from(this.bundles.keys()),\n            totalFiles: Array.from(this.bundles.values()).reduce((sum, bundle) => sum + bundle.files.length, 0)\n          },\n          mcp: {\n            available: true,\n            serverStarted: this.mcpServerStarted,\n            command: 'npx cntx-ui mcp',\n            setupScript: './examples/claude-mcp-setup.sh'\n          },\n          files: {\n            total: this.getAllFiles().length,\n            hiddenGlobally: this.hiddenFilesConfig.globalHidden.length,\n            ignorePatterns: this.ignorePatterns.length\n          }\n        };\n        res.end(JSON.stringify(statusInfo, null, 2));\n\n      } else {\n        res.writeHead(404);\n        res.end('Not found');\n      }\n    });\n\n    const wss = new WebSocketServer({ server });\n    wss.on('connection', (ws) => {\n      this.clients.add(ws);\n      ws.on('close', () => this.clients.delete(ws));\n      this.sendUpdate(ws);\n    });\n\n    server.listen(port, () => {\n      if (!this.isQuietMode) {\n        console.log(`🚀 cntx-ui API running at http://localhost:${port}`);\n        console.log(`📁 Watching: ${this.CWD}`);\n        console.log(`📦 Bundles: ${Array.from(this.bundles.keys()).join(', ')}`);\n      }\n    });\n\n    return server;\n  }\n\n  broadcastUpdate() {\n    this.clients.forEach(client => this.sendUpdate(client));\n  }\n\n  sendUpdate(client) {\n    if (client.readyState === 1) {\n      const bundleData = Array.from(this.bundles.entries()).map(([name, bundle]) => ({\n        name,\n        changed: bundle.changed,\n        fileCount: bundle.files.length,\n        content: bundle.content.substring(0, 2000) + (bundle.content.length > 2000 ? '...' : ''),\n        files: bundle.files,\n        lastGenerated: bundle.lastGenerated,\n        size: bundle.size\n      }));\n      client.send(JSON.stringify(bundleData));\n    }\n  }\n\n  cleanup() {\n    this.watchers.forEach(watcher => watcher.close());\n    this.saveBundleStates();\n  }\n\n  // Semantic Chunking Methods\n  async getSemanticAnalysis() {\n    // Force refresh always for now (TODO: implement proper cache invalidation)\n    this.semanticCache = null // Clear cache\n    const shouldRefresh = true\n    \n    console.log('🔍 Cache check - shouldRefresh:', shouldRefresh, 'lastAnalysis:', this.lastSemanticAnalysis, 'now:', Date.now());\n\n    if (shouldRefresh) {\n      try {\n        // Auto-discover JavaScript/TypeScript files in the entire project\n        const patterns = ['**/*.{js,jsx,ts,tsx,mjs}'];\n        \n        // Load bundle configuration for chunk grouping\n        let bundleConfig = null;\n        if (existsSync(this.CONFIG_FILE)) {\n          bundleConfig = JSON.parse(readFileSync(this.CONFIG_FILE, 'utf8'));\n        }\n        \n        this.semanticCache = await this.semanticSplitter.extractSemanticChunks(this.CWD, patterns, bundleConfig);\n        this.lastSemanticAnalysis = Date.now();\n        \n        // Debug logging\n        console.log('🔍 Semantic analysis complete. Sample chunk keys:', \n          this.semanticCache.chunks.length > 0 ? Object.keys(this.semanticCache.chunks[0]) : 'No chunks');\n        if (this.semanticCache.chunks.length > 0) {\n          console.log('🔍 Sample chunk businessDomains:', this.semanticCache.chunks[0].businessDomains);\n        }\n      } catch (error) {\n        console.error('Semantic analysis failed:', error.message);\n        throw new Error(`Semantic analysis failed: ${error.message}`);\n      }\n    }\n\n    return this.semanticCache;\n  }\n\n  async exportSemanticChunk(chunkName) {\n    const analysis = await this.getSemanticAnalysis();\n    const chunk = analysis.chunks.find(c => c.name === chunkName);\n\n    if (!chunk) {\n      throw new Error(`Chunk \"${chunkName}\" not found`);\n    }\n\n    // Generate XML content for the chunk files\n    let xmlContent = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n`;\n    xmlContent += `<codebase_context semantic_chunk=\"${chunkName}\">\\n`;\n    xmlContent += `  <chunk_info>\\n`;\n    xmlContent += `    <name>${chunkName}</name>\\n`;\n    xmlContent += `    <purpose>${chunk.purpose || 'No description'}</purpose>\\n`;\n    xmlContent += `    <file_count>${chunk.files.length}</file_count>\\n`;\n    xmlContent += `    <size>${chunk.size} bytes</size>\\n`;\n    xmlContent += `    <complexity>${chunk.complexity?.level || 'unknown'}</complexity>\\n`;\n    xmlContent += `    <tags>${(chunk.tags || []).join(', ')}</tags>\\n`;\n    xmlContent += `  </chunk_info>\\n\\n`;\n\n    // Add each function in the chunk\n    if (chunk.functions) {\n      for (const func of chunk.functions) {\n        xmlContent += `  <function name=\"${func.name}\" file=\"${func.filePath}\">\\n`;\n        xmlContent += `    <signature>${func.signature}</signature>\\n`;\n        xmlContent += `    <type>${func.type}</type>\\n`;\n        xmlContent += `    <lines>${func.startLine}-${func.endLine}</lines>\\n`;\n        \n        if (func.context.imports.length > 0) {\n          xmlContent += `    <imports>${func.context.imports.join(', ')}</imports>\\n`;\n        }\n        \n        xmlContent += `    <code>\\n`;\n        xmlContent += func.code\n          .split('\\n')\n          .map((line, i) => `${(func.startLine + i).toString().padStart(3)}  ${line}`)\n          .join('\\n');\n        xmlContent += `\\n    </code>\\n`;\n        xmlContent += `  </function>\\n\\n`;\n      }\n    } else {\n      // Fallback for file-based chunks\n      for (const filePath of chunk.files || []) {\n        const fullPath = join(this.CWD, filePath);\n        if (existsSync(fullPath)) {\n          try {\n            const content = readFileSync(fullPath, 'utf8');\n            xmlContent += `  <file path=\"${filePath}\">\\n`;\n            xmlContent += content\n              .split('\\n')\n              .map((line, i) => `${(i + 1).toString().padStart(3)}  ${line}`)\n              .join('\\n');\n            xmlContent += `\\n  </file>\\n\\n`;\n          } catch (error) {\n            console.warn(`Could not read file ${filePath}:`, error.message);\n          }\n        }\n      }\n    }\n\n    xmlContent += `</codebase_context>`;\n    return xmlContent;\n  }\n\n  async createBundleFromChunk(chunkName, files) {\n    // Load current config\n    let config = {};\n    if (existsSync(this.CONFIG_FILE)) {\n      config = JSON.parse(readFileSync(this.CONFIG_FILE, 'utf8'));\n    }\n\n    if (!config.bundles) {\n      config.bundles = {};\n    }\n\n    // Create bundle with the chunk name and files\n    const bundleName = chunkName.toLowerCase().replace(/[-\\s]+/g, '-');\n    config.bundles[bundleName] = files;\n\n    // Save config\n    writeFileSync(this.CONFIG_FILE, JSON.stringify(config, null, 2));\n\n    // Reload bundles\n    this.loadConfig();\n    this.generateAllBundles();\n    this.saveBundleStates();\n    this.broadcastUpdate();\n  }\n\n  invalidateSemanticCache() {\n    this.semanticCache = null;\n    this.lastSemanticAnalysis = null;\n  }\n}\n\nexport function startServer(options = {}) {\n  const server = new CntxServer(options.cwd, { quiet: options.quiet });\n  server.init();\n\n  if (options.withMcp) {\n    server.mcpServerStarted = true;\n    if (!server.isQuietMode) {\n      console.log('🔗 MCP server tracking enabled - use /api/status to check MCP configuration');\n    }\n  }\n\n  return server.startServer(options.port);\n}\n\nexport function startMCPServer(options = {}) {\n  const server = new CntxServer(options.cwd, { quiet: true });\n  server.init();\n  startMCPTransport(server);\n  return server;\n}\n\nexport function generateBundle(name = 'master', cwd = process.cwd(), options = {}) {\n  const server = new CntxServer(cwd, { quiet: options.quiet });\n  server.init();\n  server.generateBundle(name);\n  server.saveBundleStates();\n}\n\nexport function initConfig(cwd = process.cwd(), options = {}) {\n  const isQuiet = options.quiet || false;\n  if (!isQuiet) {\n    console.log('🚀 Starting initConfig...');\n    console.log('📂 Working directory:', cwd);\n  }\n\n  const server = new CntxServer(cwd, { quiet: isQuiet });\n  if (!isQuiet) {\n    console.log('📁 CNTX_DIR:', server.CNTX_DIR);\n    console.log('📄 CONFIG_FILE path:', server.CONFIG_FILE);\n  }\n\n  const defaultConfig = {\n    bundles: {\n      master: ['**/*']\n    }\n  };\n\n  try {\n    // Create .cntx directory\n    if (!isQuiet) console.log('🔍 Checking if .cntx directory exists...');\n    if (!existsSync(server.CNTX_DIR)) {\n      if (!isQuiet) console.log('📁 Creating .cntx directory...');\n      mkdirSync(server.CNTX_DIR, { recursive: true });\n      if (!isQuiet) console.log('✅ .cntx directory created');\n    } else {\n      if (!isQuiet) console.log('✅ .cntx directory already exists');\n    }\n\n    // List directory contents before writing config\n    if (!isQuiet) {\n      console.log('📋 Directory contents before writing config:');\n      const beforeFiles = readdirSync(server.CNTX_DIR);\n      console.log('Files:', beforeFiles);\n    }\n\n    // Write config.json\n    if (!isQuiet) {\n      console.log('📝 Writing config.json...');\n      console.log('📄 Config content:', JSON.stringify(defaultConfig, null, 2));\n      console.log('📍 Writing to path:', server.CONFIG_FILE);\n    }\n\n    writeFileSync(server.CONFIG_FILE, JSON.stringify(defaultConfig, null, 2));\n    if (!isQuiet) console.log('✅ writeFileSync completed');\n\n    // Verify file was created\n    if (!isQuiet) {\n      console.log('🔍 Checking if config.json exists...');\n      const configExists = existsSync(server.CONFIG_FILE);\n      console.log('Config exists?', configExists);\n\n      if (configExists) {\n        const configContent = readFileSync(server.CONFIG_FILE, 'utf8');\n        console.log('✅ Config file created successfully');\n        console.log('📖 Config content:', configContent);\n      } else {\n        console.log('❌ Config file was NOT created');\n      }\n\n      // List directory contents after writing config\n      console.log('📋 Directory contents after writing config:');\n      const afterFiles = readdirSync(server.CNTX_DIR);\n      console.log('Files:', afterFiles);\n    }\n\n  } catch (error) {\n    if (!isQuiet) {\n      console.error('❌ Error in initConfig:', error);\n      console.error('Stack trace:', error.stack);\n    }\n    throw error;\n  }\n\n  // Create cursor rules if they don't exist\n  try {\n    if (!existsSync(server.CURSOR_RULES_FILE)) {\n      if (!isQuiet) console.log('📋 Creating cursor rules...');\n      const cursorRules = server.getDefaultCursorRules();\n      server.saveCursorRules(cursorRules);\n      if (!isQuiet) console.log(`📋 Created ${relative(cwd, server.CURSOR_RULES_FILE)} with project-specific rules`);\n    }\n  } catch (error) {\n    if (!isQuiet) console.error('❌ Error creating cursor rules:', error);\n  }\n\n  if (!isQuiet) {\n    console.log('✅ cntx-ui initialized successfully!');\n    console.log('');\n    console.log('🚀 Next step: Start the web interface');\n    console.log('   Run: cntx-ui watch');\n    console.log('');\n    console.log('📱 Then visit: http://localhost:3333');\n    console.log('   Follow the setup guide to create your first bundles');\n    console.log('');\n    console.log('💡 The web interface handles everything - no manual file editing needed!');\n  }\n}\n\nexport function getStatus(cwd = process.cwd(), options = {}) {\n  const server = new CntxServer(cwd, { quiet: options.quiet });\n  server.init();\n\n  if (!options.quiet) {\n    console.log(`📁 Working directory: ${server.CWD}`);\n    console.log(`📦 Bundles configured: ${server.bundles.size}`);\n    server.bundles.forEach((bundle, name) => {\n      const status = bundle.changed ? '🔄 CHANGED' : '✅ SYNCED';\n      console.log(`  ${name}: ${bundle.files.length} files ${status}`);\n    });\n\n    const hasCursorRules = existsSync(server.CURSOR_RULES_FILE);\n    console.log(`🤖 Cursor rules: ${hasCursorRules ? '✅ Configured' : '❌ Not found'}`);\n  }\n}\n\nexport function setupMCP(cwd = process.cwd(), options = {}) {\n  const isQuiet = options.quiet || false;\n  const projectDir = cwd;\n  const projectName = basename(projectDir);\n  const configFile = join(homedir(), 'Library', 'Application Support', 'Claude', 'claude_desktop_config.json');\n\n  if (!isQuiet) {\n    console.log('🔗 Setting up MCP for Claude Desktop...');\n    console.log(`📁 Project: ${projectName} (${projectDir})`);\n  }\n\n  // Create config directory if it doesn't exist\n  const configDir = dirname(configFile);\n  if (!existsSync(configDir)) {\n    mkdirSync(configDir, { recursive: true });\n  }\n\n  // Read existing config or create empty one\n  let config = { mcpServers: {} };\n  if (existsSync(configFile)) {\n    try {\n      const configContent = readFileSync(configFile, 'utf8');\n      config = JSON.parse(configContent);\n      if (!config.mcpServers) config.mcpServers = {};\n    } catch (error) {\n      if (!isQuiet) console.warn('⚠️  Could not parse existing config, creating new one');\n      config = { mcpServers: {} };\n    }\n  }\n\n  // Add this project's MCP server using shell command format that works with Claude Desktop\n  const serverName = `cntx-ui-${projectName}`;\n  config.mcpServers[serverName] = {\n    command: 'sh',\n    args: ['-c', `cd ${projectDir} && npx cntx-ui mcp`],\n    cwd: projectDir\n  };\n\n  // Write updated config\n  try {\n    writeFileSync(configFile, JSON.stringify(config, null, 2));\n\n    if (!isQuiet) {\n      console.log(`✅ Added MCP server: ${serverName}`);\n      console.log('📋 Your Claude Desktop config now includes:');\n\n      Object.keys(config.mcpServers).forEach(name => {\n        if (name.startsWith('cntx-ui-')) {\n          console.log(`  • ${name}: ${config.mcpServers[name].cwd}`);\n        }\n      });\n\n      console.log('🔄 Please restart Claude Desktop to use the updated configuration');\n    }\n  } catch (error) {\n    if (!isQuiet) {\n      console.error('❌ Error writing Claude Desktop config:', error.message);\n      console.error('💡 Make sure Claude Desktop is not running and try again');\n    }\n    throw error;\n  }\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/index.html\" ext=\".html\" role=\"entry-point\">\n        <cntx:meta size=\"629\" modified=\"2025-06-19T17:10:17.425Z\" lines=\"17\" />\n        <cntx:content><![CDATA[<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/vite.svg\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>cntx-ui</title>\n    <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n    <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n    <link href=\"https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap\" rel=\"stylesheet\">\n  </head>\n  <body>\n    <div id=\"root\"></div>\n    <script type=\"module\" src=\"/src/main.tsx\"></script>\n  </body>\n</html>\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/App.css\" ext=\".css\" role=\"main-component\">\n        <cntx:meta size=\"652\" modified=\"2025-06-25T06:22:37.442Z\" lines=\"43\" />\n        <cntx:content><![CDATA[#root {\n  max-width: 1280px;\n  margin: 0 auto;\n  padding: 2rem;\n  text-align: center;\n}\n\n.logo {\n  height: 6em;\n  padding: 1.5em;\n  will-change: filter;\n  transition: filter 300ms;\n}\n.logo:hover {\n  filter: drop-shadow(0 0 2em var(--color-primary));\n}\n.logo.react:hover {\n  filter: drop-shadow(0 0 2em var(--color-accent));\n}\n\n@keyframes logo-spin {\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n}\n\n@media (prefers-reduced-motion: no-preference) {\n  a:nth-of-type(2) .logo {\n    animation: logo-spin infinite 20s linear;\n  }\n}\n\n.card {\n  padding: 2em;\n}\n\n.read-the-docs {\n  color: var(--color-muted-foreground);\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/App.tsx\" ext=\".tsx\" role=\"main-component\">\n        <cntx:meta size=\"9520\" modified=\"2025-06-26T01:00:24.620Z\" lines=\"290\" />\n        <cntx:content><![CDATA[// web/src/App.tsx - Sidebar Navigation with shadcn/ui\nimport { useEffect, useState } from 'react'\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query'\nimport { BundleList } from './components/BundleList'\nimport { FileTree } from './components/FileTree'\nimport { EnhancedBundleConfig } from './components/EnhancedBundleConfig'\nimport { AIRulesManager } from './components/AIRulesManager'\nimport { HiddenFilesManager } from './components/HiddenFilesManager'\nimport { SemanticChunks } from './components/SemanticChunks'\nimport { SetupChecklist, UsageGuidance, WorkflowInstructions, QuickCliReference } from './components/SetupComponents'\nimport SetupScreen from './components/SetupScreen'\nimport { Card, CardHeader, CardTitle, CardContent } from './components/ui/card'\nimport { Button } from './components/ui/button'\nimport {\n  Layers,\n  Sparkles,\n  CheckCircle,\n  HelpCircle,\n  Rocket,\n  EyeOff\n} from 'lucide-react'\nimport { ThemeToggle } from './components/theme-toggle'\n\nconst queryClient = new QueryClient()\n\nconst navigationItems = [\n  {\n    id: 'bundles',\n    label: 'Bundles & Files',\n    icon: Layers\n  },\n  {\n    id: 'semantic',\n    label: 'Semantic Chunks',\n    icon: Sparkles\n  },\n  {\n    id: 'settings',\n    label: 'Settings',\n    icon: EyeOff\n  },\n  {\n    id: 'ai-rules',\n    label: 'AI Rules',\n    icon: Sparkles\n  },\n  {\n    id: 'setup',\n    label: 'Setup Status',\n    icon: CheckCircle\n  },\n  {\n    id: 'help',\n    label: 'Help',\n    icon: HelpCircle\n  },\n  {\n    id: 'setup-guide',\n    label: 'Setup Guide',\n    icon: Rocket\n  }\n]\n\nfunction App() {\n  const [webStatus, setWebStatus] = useState<'connecting' | 'connected' | 'disconnected'>('connecting')\n  const [mcpStatus, setMcpStatus] = useState<'unknown' | 'running' | 'stopped'>('unknown')\n  const [activeSection, setActiveSection] = useState('bundles')\n  const [showFullSetupGuide, setShowFullSetupGuide] = useState(false)\n\n  useEffect(() => {\n    // Web server status via WebSocket\n    const ws = new WebSocket('ws://localhost:3333')\n    ws.onopen = () => setWebStatus('connected')\n    ws.onclose = () => setWebStatus('disconnected')\n\n    // Check MCP server status\n    const checkMcpStatus = async () => {\n      try {\n        const response = await fetch('/api/mcp-status')\n        if (response.ok) {\n          const { running } = await response.json()\n          setMcpStatus(running ? 'running' : 'stopped')\n        } else {\n          setMcpStatus('stopped')\n        }\n      } catch {\n        setMcpStatus('stopped')\n      }\n    }\n\n    checkMcpStatus()\n    const mcpInterval = setInterval(checkMcpStatus, 10000) // Check every 10s\n\n    return () => {\n      ws.close()\n      clearInterval(mcpInterval)\n    }\n  }, [])\n\n  if (showFullSetupGuide) {\n    return (\n      <QueryClientProvider client={queryClient}>\n        <div className=\"relative\">\n          <Button\n            variant=\"ghost\"\n            onClick={() => setShowFullSetupGuide(false)}\n            className=\"absolute top-4 right-4 z-10\"\n          >\n            ← Back to Dashboard\n          </Button>\n          <SetupScreen />\n        </div>\n      </QueryClientProvider>\n    )\n  }\n\n  const renderContent = () => {\n    switch (activeSection) {\n      case 'bundles':\n        return (\n          <div className=\"space-y-6\">\n            <div>\n              <h1 className=\"text-lg font-medium tracking-tight\">Bundles & Files</h1>\n              <p className=\"text-xs text-muted-foreground font-normal\">Manage your file bundles and project structure</p>\n            </div>\n            <BundleList />\n            <Card>\n              <CardHeader>\n                <CardTitle>Project Files</CardTitle>\n              </CardHeader>\n              <CardContent>\n                <FileTree />\n              </CardContent>\n            </Card>\n          </div>\n        )\n      case 'semantic':\n        return (\n          <div className=\"space-y-6\">\n            <div>\n              <h1 className=\"text-lg font-medium tracking-tight\">Semantic Chunks</h1>\n              <p className=\"text-xs text-muted-foreground font-normal\">AI-powered code organization and intelligent bundles</p>\n            </div>\n            <SemanticChunks />\n          </div>\n        )\n      case 'settings':\n        return (\n          <div className=\"space-y-6\">\n            <div>\n              <h1 className=\"text-lg font-medium tracking-tight\">Settings</h1>\n              <p className=\"text-xs text-muted-foreground font-normal\">Configure file visibility and bundle patterns</p>\n            </div>\n            <HiddenFilesManager />\n            <EnhancedBundleConfig />\n          </div>\n        )\n      case 'ai-rules':\n        return (\n          <div className=\"space-y-6\">\n            <div>\n              <h1 className=\"text-lg font-medium tracking-tight\">AI Rules</h1>\n              <p className=\"text-xs text-muted-foreground font-normal\">Configure AI context and project guidelines</p>\n            </div>\n            <AIRulesManager />\n          </div>\n        )\n      case 'setup':\n        return (\n          <div className=\"space-y-6\">\n            <div>\n              <h1 className=\"text-lg font-medium tracking-tight\">Setup Status</h1>\n              <p className=\"text-xs text-muted-foreground font-normal\">Project configuration checklist</p>\n            </div>\n            <SetupChecklist onOpenFullSetup={() => setShowFullSetupGuide(true)} />\n          </div>\n        )\n      case 'help':\n        return (\n          <div className=\"space-y-6\">\n            <div>\n              <h1 className=\"text-lg font-medium tracking-tight\">Help & Documentation</h1>\n              <p className=\"text-xs text-muted-foreground font-normal\">Usage guides and workflow instructions</p>\n            </div>\n            <UsageGuidance />\n            <WorkflowInstructions />\n            <QuickCliReference />\n          </div>\n        )\n      default:\n        return null\n    }\n  }\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <div className=\"h-screen bg-background overflow-hidden\">\n        <div className=\"flex h-full\">\n          {/* Sidebar */}\n          <div className=\"w-64 border-r bg-muted/10 flex flex-col h-full\">\n            {/* Header */}\n            <div className=\"p-4 border-b flex-shrink-0\">\n              <div className=\"flex items-center gap-2\">\n                <div className=\"w-6 h-6 rounded-md bg-primary flex items-center justify-center\">\n                  <Layers className=\"w-3 h-3 text-primary-foreground\" />\n                </div>\n                <div>\n                  <h2 className=\"text-sm font-medium\">cntx-ui</h2>\n                  <p className=\"text-xs text-muted-foreground font-normal\">Context Manager</p>\n                </div>\n              </div>\n            </div>\n\n            {/* Navigation */}\n            <nav className=\"p-4 space-y-1 flex-1 overflow-y-auto\">\n              {navigationItems.map((item) => {\n                const Icon = item.icon\n                const isActive = activeSection === item.id\n\n                return (\n                  <Button\n                    key={item.id}\n                    variant={isActive ? \"secondary\" : \"ghost\"}\n                    className=\"w-full justify-start h-8 text-xs font-normal\"\n                    onClick={() => {\n                      if (item.id === 'setup-guide') {\n                        setShowFullSetupGuide(true)\n                      } else {\n                        setActiveSection(item.id)\n                      }\n                    }}\n                  >\n                    <Icon className=\"w-3 h-3 mr-2\" />\n                    {item.label}\n                  </Button>\n                )\n              })}\n            </nav>\n\n          </div>\n\n          {/* Main Content */}\n          <div className=\"flex-1 overflow-y-auto pb-12\">\n            <main className=\"p-6 max-w-6xl\">\n              {renderContent()}\n            </main>\n          </div>\n        </div>\n\n        {/* Full-width Status Bar */}\n        <div className=\"fixed bottom-0 left-0 right-0 h-10 bg-card border-t border-border px-4 flex items-center justify-between z-40\">\n          <div className=\"flex items-center gap-6\">\n            {/* Web Server Status */}\n            <div className=\"flex items-center gap-2\">\n              <div className={`w-2 h-2 rounded-full ${webStatus === 'connected' ? 'bg-[color:var(--color-success)]' :\n                  webStatus === 'connecting' ? 'bg-[color:var(--color-warning)]' : 'bg-destructive'\n                }`} />\n              <span className=\"text-xs font-normal\">\n                Web: {webStatus === 'connected' ? 'Live' :\n                  webStatus === 'connecting' ? 'Connecting' : 'Offline'}\n              </span>\n            </div>\n\n            {/* MCP Server Status */}\n            <div className=\"flex items-center gap-2\">\n              <div className={`w-2 h-2 rounded-full ${mcpStatus === 'running' ? 'bg-[color:var(--color-success)]' :\n                  mcpStatus === 'stopped' ? 'bg-destructive' : 'bg-muted-foreground'\n                }`} />\n              <span className=\"text-xs font-normal\">\n                MCP: {mcpStatus === 'running' ? 'Running' :\n                  mcpStatus === 'stopped' ? 'Stopped' : 'Unknown'}\n              </span>\n            </div>\n          </div>\n\n          <div className=\"flex items-center gap-4\">\n            <div className=\"text-xs text-muted-foreground\">\n              cntx-ui v2.0.12\n            </div>\n            <ThemeToggle />\n          </div>\n        </div>\n\n      </div>\n    </QueryClientProvider>\n  )\n}\n\nexport default App\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/index.css\" ext=\".css\" role=\"entry-point\">\n        <cntx:meta size=\"5585\" modified=\"2025-06-25T06:27:10.282Z\" lines=\"156\" />\n        <cntx:content><![CDATA[@import \"tailwindcss\";\n@import \"tw-animate-css\";\n\n@custom-variant dark (&:is(.dark *));\n\n@theme inline {\n  --radius-sm: calc(var(--radius) - 1px);\n  --radius-md: calc(var(--radius) - 1px);\n  --radius-lg: var(--radius);\n  --radius-xl: calc(var(--radius) + 1px);\n  --color-background: var(--background);\n  --color-foreground: var(--foreground);\n  --color-card: var(--card);\n  --color-card-foreground: var(--card-foreground);\n  --color-popover: var(--popover);\n  --color-popover-foreground: var(--popover-foreground);\n  --color-primary: var(--primary);\n  --color-primary-foreground: var(--primary-foreground);\n  --color-secondary: var(--secondary);\n  --color-secondary-foreground: var(--secondary-foreground);\n  --color-muted: var(--muted);\n  --color-muted-foreground: var(--muted-foreground);\n  --color-accent: var(--accent);\n  --color-accent-foreground: var(--accent-foreground);\n  --color-destructive: var(--destructive);\n  --color-border: var(--border);\n  --color-input: var(--input);\n  --color-ring: var(--ring);\n  --color-chart-1: var(--chart-1);\n  --color-chart-2: var(--chart-2);\n  --color-chart-3: var(--chart-3);\n  --color-chart-4: var(--chart-4);\n  --color-chart-5: var(--chart-5);\n  --color-sidebar: var(--sidebar);\n  --color-sidebar-foreground: var(--sidebar-foreground);\n  --color-sidebar-primary: var(--sidebar-primary);\n  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);\n  --color-sidebar-accent: var(--sidebar-accent);\n  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);\n  --color-sidebar-border: var(--sidebar-border);\n  --color-sidebar-ring: var(--sidebar-ring);\n  \n  /* File type colors */\n  --color-type-components: var(--chart-2);\n  --color-type-components-fg: var(--chart-2);\n  --color-type-hooks: var(--chart-3);\n  --color-type-hooks-fg: var(--chart-3);\n  --color-type-utilities: var(--chart-1);\n  --color-type-utilities-fg: var(--chart-1);\n  --color-type-configuration: var(--chart-5);\n  --color-type-configuration-fg: var(--chart-5);\n  --color-type-styles: var(--chart-4);\n  --color-type-styles-fg: var(--chart-4);\n  --color-type-types: var(--primary);\n  --color-type-types-fg: var(--primary);\n  --color-type-tests: var(--accent);\n  --color-type-tests-fg: var(--accent);\n  --color-type-documentation: var(--muted);\n  --color-type-documentation-fg: var(--muted-foreground);\n  \n  /* Status colors */\n  --color-success: oklch(0.75 0.12 140);\n  --color-success-foreground: oklch(0.98 0.005 240);\n  --color-warning: oklch(0.8 0.12 65);\n  --color-warning-foreground: oklch(0.15 0.01 240);\n  --color-info: var(--primary);\n  --color-info-foreground: var(--primary-foreground);\n}\n\n:root {\n  --radius: 0.225rem;\n  --background: oklch(0.98 0.005 240);\n  --foreground: oklch(0.25 0.02 240);\n  --card: oklch(0.99 0.003 240);\n  --card-foreground: oklch(0.25 0.02 240);\n  --popover: oklch(0.99 0.003 240);\n  --popover-foreground: oklch(0.25 0.02 240);\n  --primary: oklch(0.65 0.08 200);\n  --primary-foreground: oklch(0.98 0.005 240);\n  --secondary: oklch(0.92 0.02 240);\n  --secondary-foreground: oklch(0.35 0.03 240);\n  --muted: oklch(0.94 0.01 240);\n  --muted-foreground: oklch(0.55 0.02 240);\n  --accent: oklch(0.88 0.03 220);\n  --accent-foreground: oklch(0.25 0.02 240);\n  --destructive: oklch(0.75 0.15 25);\n  --border: oklch(0.88 0.01 240);\n  --input: oklch(0.88 0.01 240);\n  --ring: oklch(0.65 0.08 200);\n  --chart-1: oklch(0.75 0.12 45);\n  --chart-2: oklch(0.7 0.08 180);\n  --chart-3: oklch(0.65 0.06 220);\n  --chart-4: oklch(0.8 0.1 90);\n  --chart-5: oklch(0.75 0.09 75);\n  --sidebar: oklch(0.96 0.004 240);\n  --sidebar-foreground: oklch(0.25 0.02 240);\n  --sidebar-primary: oklch(0.65 0.08 200);\n  --sidebar-primary-foreground: oklch(0.98 0.005 240);\n  --sidebar-accent: oklch(0.92 0.02 240);\n  --sidebar-accent-foreground: oklch(0.35 0.03 240);\n  --sidebar-border: oklch(0.88 0.01 240);\n  --sidebar-ring: oklch(0.65 0.08 200);\n}\n\n.dark {\n  --background: oklch(0.13 0.01 240);\n  --foreground: oklch(0.85 0.02 240);\n  --card: oklch(0.13 0.01 240);\n  --card-foreground: oklch(0.85 0.02 240);\n  --popover: oklch(0.22 0.015 240);\n  --popover-foreground: oklch(0.85 0.02 240);\n  --primary: oklch(0.7 0.06 200);\n  --primary-foreground: oklch(0.15 0.01 240);\n  --secondary: oklch(0.28 0.02 240);\n  --secondary-foreground: oklch(0.85 0.02 240);\n  --muted: oklch(0.28 0.02 240);\n  --muted-foreground: oklch(0.65 0.02 240);\n  --accent: oklch(0.32 0.025 240);\n  --accent-foreground: oklch(0.85 0.02 240);\n  --destructive: oklch(0.7 0.12 25);\n  --border: oklch(0.2 0.02 240);\n  --input: oklch(0.35 0.02 240);\n  --ring: oklch(0.7 0.06 200);\n  --chart-1: oklch(0.65 0.1 45);\n  --chart-2: oklch(0.6 0.07 180);\n  --chart-3: oklch(0.55 0.05 220);\n  --chart-4: oklch(0.7 0.08 90);\n  --chart-5: oklch(0.65 0.07 75);\n  --sidebar: oklch(0.18 0.012 240);\n  --sidebar-foreground: oklch(0.85 0.02 240);\n  --sidebar-primary: oklch(0.7 0.06 200);\n  --sidebar-primary-foreground: oklch(0.15 0.01 240);\n  --sidebar-accent: oklch(0.28 0.02 240);\n  --sidebar-accent-foreground: oklch(0.85 0.02 240);\n  --sidebar-border: oklch(0.35 0.02 240);\n  --sidebar-ring: oklch(0.7 0.06 200);\n  \n  /* Dark mode status colors */\n  --color-success: oklch(0.65 0.1 140);\n  --color-success-foreground: oklch(0.15 0.01 240);\n  --color-warning: oklch(0.7 0.1 65);\n  --color-warning-foreground: oklch(0.15 0.01 240);\n  --color-info: var(--primary);\n  --color-info-foreground: var(--primary-foreground);\n}\n\n@layer base {\n  * {\n    @apply border-border outline-ring/50;\n  }\n  body {\n    @apply bg-background text-foreground;\n    font-family: 'JetBrains Mono', monospace;\n  }\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/main.tsx\" ext=\".tsx\" role=\"entry-point\">\n        <cntx:meta size=\"729\" modified=\"2025-06-25T06:31:35.145Z\" lines=\"27\" />\n        <cntx:content><![CDATA[// web/src/main.tsx\nimport { StrictMode } from 'react'\nimport { createRoot } from 'react-dom/client'\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query'\nimport { Toaster } from './components/ui/toaster'\nimport { ThemeProvider } from './components/theme-provider'\nimport './index.css'\nimport App from './App'\n\nconst queryClient = new QueryClient()\n\ncreateRoot(document.getElementById('root')!).render(\n  <StrictMode>\n    <QueryClientProvider client={queryClient}>\n      <ThemeProvider\n        attribute=\"class\"\n        defaultTheme=\"system\"\n        enableSystem\n        disableTransitionOnChange\n      >\n        <App />\n        <Toaster />\n      </ThemeProvider>\n    </QueryClientProvider>\n  </StrictMode>,\n)\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/tsconfig.app.json\" ext=\".json\" role=\"main-component\">\n        <cntx:meta size=\"756\" modified=\"2025-06-26T17:24:03.858Z\" lines=\"33\" />\n        <cntx:content><![CDATA[{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/*\": [\n        \"./src/*\"\n      ]\n    },\n    \"tsBuildInfoFile\": \"./node_modules/.tmp/tsconfig.app.tsbuildinfo\",\n    \"target\": \"ES2020\",\n    \"useDefineForClassFields\": true,\n    \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"],\n    \"module\": \"ESNext\",\n    \"skipLibCheck\": true,\n\n    /* Bundler mode */\n    \"moduleResolution\": \"bundler\",\n    \"allowImportingTsExtensions\": true,\n    \"verbatimModuleSyntax\": true,\n    \"moduleDetection\": \"force\",\n    \"noEmit\": true,\n    \"jsx\": \"react-jsx\",\n\n    /* Linting */\n    \"strict\": false,\n    \"noUnusedLocals\": false,\n    \"noUnusedParameters\": false,\n    \"noFallthroughCasesInSwitch\": true,\n    \"noUncheckedSideEffectImports\": true\n  },\n  \"include\": [\"src\"]\n}\n]]></cntx:content>\n      </cntx:file>\n    </cntx:group>\n    <cntx:group type=\"components\" description=\"React/UI components and interface elements\">\n      <cntx:file path=\"web/src/components/AIRulesManager.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"9710\" modified=\"2025-06-26T00:22:22.986Z\" lines=\"270\" />\n        <cntx:content><![CDATA[import { useState, useEffect } from 'react'\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'\nimport { Card, CardHeader, CardTitle, CardContent } from './ui/card'\nimport { Button } from './ui/button'\nimport { Textarea } from './ui/textarea'\nimport { Alert, AlertDescription } from './ui/alert'\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from './ui/tabs'\nimport { Save, RefreshCw, Copy, Download, Sparkles, FileText, Info } from 'lucide-react'\nimport { toast } from '@/lib/toast'\n\n// Fetch functions for .cursorrules\nconst fetchCursorRules = async (): Promise<string> => {\n  const response = await fetch('http://localhost:3333/api/cursor-rules')\n  if (!response.ok) throw new Error('Failed to fetch cursor rules')\n  return response.text()\n}\n\nconst saveCursorRules = async (content: string): Promise<void> => {\n  const response = await fetch('http://localhost:3333/api/cursor-rules', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ content })\n  })\n  if (!response.ok) throw new Error('Failed to save cursor rules')\n}\n\n// Fetch functions for CLAUDE.md\nconst fetchClaudeMd = async (): Promise<string> => {\n  const response = await fetch('http://localhost:3333/api/claude-md')\n  if (!response.ok) throw new Error('Failed to fetch CLAUDE.md')\n  return response.text()\n}\n\nconst saveClaudeMd = async (content: string): Promise<void> => {\n  const response = await fetch('http://localhost:3333/api/claude-md', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ content })\n  })\n  if (!response.ok) throw new Error('Failed to save CLAUDE.md')\n}\n\nexport function AIRulesManager() {\n  const queryClient = useQueryClient()\n  const [editingCursorRules, setEditingCursorRules] = useState<string>('')\n  const [editingClaudeMd, setEditingClaudeMd] = useState<string>('')\n  const [activeTab, setActiveTab] = useState<'cursor' | 'claude'>('cursor')\n\n  // Cursor Rules queries\n  const { data: currentCursorRules, isLoading: cursorRulesLoading } = useQuery({\n    queryKey: ['cursor-rules'],\n    queryFn: fetchCursorRules\n  })\n\n  const cursorRulesMutation = useMutation({\n    mutationFn: saveCursorRules,\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['cursor-rules'] })\n      toast.success('.cursorrules saved successfully!')\n    },\n    onError: (error) => {\n      toast.error(`Failed to save .cursorrules: ${error.message}`)\n    }\n  })\n\n  // CLAUDE.md queries  \n  const { data: currentClaudeMd, isLoading: claudeMdLoading } = useQuery({\n    queryKey: ['claude-md'],\n    queryFn: fetchClaudeMd\n  })\n\n  const claudeMdMutation = useMutation({\n    mutationFn: saveClaudeMd,\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['claude-md'] })\n      toast.success('CLAUDE.md saved successfully!')\n    },\n    onError: (error) => {\n      toast.error(`Failed to save CLAUDE.md: ${error.message}`)\n    }\n  })\n\n  // Initialize editing states when data loads\n  useEffect(() => {\n    if (currentCursorRules && !editingCursorRules) {\n      setEditingCursorRules(currentCursorRules)\n    }\n  }, [currentCursorRules])\n\n  useEffect(() => {\n    if (currentClaudeMd && !editingClaudeMd) {\n      setEditingClaudeMd(currentClaudeMd)\n    }\n  }, [currentClaudeMd])\n\n  const handleSaveCursorRules = () => {\n    cursorRulesMutation.mutate(editingCursorRules)\n  }\n\n  const handleSaveClaudeMd = () => {\n    claudeMdMutation.mutate(editingClaudeMd)\n  }\n\n  const handleCopyToClipboard = (content: string, type: string) => {\n    navigator.clipboard.writeText(content)\n    toast.success(`${type} copied to clipboard!`)\n  }\n\n  const handleDownload = (content: string, filename: string) => {\n    const blob = new Blob([content], { type: 'text/plain' })\n    const url = URL.createObjectURL(blob)\n    const a = document.createElement('a')\n    a.href = url\n    a.download = filename\n    document.body.appendChild(a)\n    a.click()\n    document.body.removeChild(a)\n    URL.revokeObjectURL(url)\n    toast.success(`${filename} downloaded!`)\n  }\n\n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle className=\"flex items-center gap-2 text-sm font-medium\">\n          <Sparkles className=\"w-4 h-4\" />\n          AI Rules & Context\n        </CardTitle>\n      </CardHeader>\n      <CardContent>\n        <Alert className=\"mb-4\">\n          <Info className=\"w-4 h-4\" />\n          <AlertDescription>\n            Configure AI context files for better assistance. <strong>.cursorrules</strong> works with Cursor, \n            while <strong>CLAUDE.md</strong> provides project context for Claude.\n          </AlertDescription>\n        </Alert>\n\n        <Tabs value={activeTab} onValueChange={(value) => setActiveTab(value as 'cursor' | 'claude')} className=\"space-y-4\">\n          <TabsList className=\"grid w-full grid-cols-2\">\n            <TabsTrigger value=\"cursor\" className=\"flex items-center gap-2\">\n              <FileText className=\"w-4 h-4\" />\n              .cursorrules\n            </TabsTrigger>\n            <TabsTrigger value=\"claude\" className=\"flex items-center gap-2\">\n              <Sparkles className=\"w-4 h-4\" />\n              CLAUDE.md\n            </TabsTrigger>\n          </TabsList>\n\n          <TabsContent value=\"cursor\" className=\"space-y-4\">\n            <div className=\"flex justify-between items-center\">\n              <div>\n                <h3 className=\"text-sm font-medium\">Cursor AI Assistant Rules</h3>\n                <p className=\"text-xs text-muted-foreground font-normal\">\n                  Configure how Cursor's AI understands your project\n                </p>\n              </div>\n              <div className=\"flex gap-2\">\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  className=\"h-7 text-xs\"\n                  onClick={() => handleCopyToClipboard(editingCursorRules, '.cursorrules')}\n                >\n                  <Copy className=\"w-3 h-3 mr-1\" />\n                  Copy\n                </Button>\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  className=\"h-7 text-xs\"\n                  onClick={() => handleDownload(editingCursorRules, '.cursorrules')}\n                >\n                  <Download className=\"w-3 h-3 mr-1\" />\n                  Download\n                </Button>\n                <Button\n                  onClick={handleSaveCursorRules}\n                  disabled={cursorRulesMutation.isPending}\n                  size=\"sm\"\n                  className=\"h-7 text-xs\"\n                >\n                  <Save className=\"w-3 h-3 mr-1\" />\n                  Save\n                </Button>\n              </div>\n            </div>\n\n            {cursorRulesLoading ? (\n              <div className=\"flex items-center justify-center p-8\">\n                <RefreshCw className=\"w-6 h-6 animate-spin mr-2\" />\n                Loading...\n              </div>\n            ) : (\n              <Textarea\n                value={editingCursorRules}\n                onChange={(e) => setEditingCursorRules(e.target.value)}\n                placeholder=\"Enter your Cursor AI rules here...\"\n                className=\"min-h-[300px] font-mono text-sm\"\n              />\n            )}\n          </TabsContent>\n\n          <TabsContent value=\"claude\" className=\"space-y-4\">\n            <div className=\"flex justify-between items-center\">\n              <div>\n                <h3 className=\"text-sm font-medium\">Claude Project Context</h3>\n                <p className=\"text-xs text-muted-foreground font-normal\">\n                  Markdown file explaining your project structure and guidelines\n                </p>\n              </div>\n              <div className=\"flex gap-2\">\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  className=\"h-7 text-xs\"\n                  onClick={() => handleCopyToClipboard(editingClaudeMd, 'CLAUDE.md')}\n                >\n                  <Copy className=\"w-3 h-3 mr-1\" />\n                  Copy\n                </Button>\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  className=\"h-7 text-xs\"\n                  onClick={() => handleDownload(editingClaudeMd, 'CLAUDE.md')}\n                >\n                  <Download className=\"w-3 h-3 mr-1\" />\n                  Download\n                </Button>\n                <Button\n                  onClick={handleSaveClaudeMd}\n                  disabled={claudeMdMutation.isPending}\n                  size=\"sm\"\n                  className=\"h-7 text-xs\"\n                >\n                  <Save className=\"w-3 h-3 mr-1\" />\n                  Save\n                </Button>\n              </div>\n            </div>\n\n            {claudeMdLoading ? (\n              <div className=\"flex items-center justify-center p-8\">\n                <RefreshCw className=\"w-6 h-6 animate-spin mr-2\" />\n                Loading...\n              </div>\n            ) : (\n              <Textarea\n                value={editingClaudeMd}\n                onChange={(e) => setEditingClaudeMd(e.target.value)}\n                placeholder=\"Enter your Claude project context here...\"\n                className=\"min-h-[300px] font-mono text-sm\"\n              />\n            )}\n\n            <Alert>\n              <Info className=\"w-4 h-4\" />\n              <AlertDescription>\n                This file helps Claude understand your project. Include project structure, \n                coding conventions, key concepts, and any important context.\n              </AlertDescription>\n            </Alert>\n          </TabsContent>\n        </Tabs>\n      </CardContent>\n    </Card>\n  )\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/BundleConfig.tsx\" ext=\".tsx\" role=\"configuration\">\n        <cntx:meta size=\"25381\" modified=\"2025-06-25T06:32:51.511Z\" lines=\"696\" />\n        <cntx:content><![CDATA[import { useState, useEffect } from 'react'\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'\nimport { Card, CardHeader, CardTitle, CardContent } from './ui/card'\nimport { Button } from './ui/button'\nimport { Input } from './ui/input'\nimport { Badge } from './ui/badge'\nimport { Textarea } from './ui/textarea'\nimport { Trash2, Plus, Save, Eye, AlertTriangle, Settings, X } from 'lucide-react'\nimport { useButtonFeedback } from '../hooks/useButtonFeedback'\nimport { getButtonIcon, getButtonClassName } from '../utils/buttonHelpers'\nimport { toast } from '@/lib/toast'\n\n// Extend Window interface for timeout\ndeclare global {\n  interface Window {\n    patternChangeTimeout?: NodeJS.Timeout\n  }\n}\n\ninterface BundleConfig {\n  bundles: Record<string, string[]>\n}\n\ninterface Bundle {\n  name: string\n  files: string[]\n  size: number\n}\n\nconst fetchConfig = async (): Promise<BundleConfig> => {\n  const response = await fetch('http://localhost:3333/api/config')\n  if (!response.ok) throw new Error('Failed to fetch config')\n  return response.json()\n}\n\nconst fetchBundles = async (): Promise<Bundle[]> => {\n  const response = await fetch('http://localhost:3333/api/bundles')\n  if (!response.ok) throw new Error('Failed to fetch bundles')\n  return response.json()\n}\n\nconst saveConfig = async (config: BundleConfig): Promise<void> => {\n  const response = await fetch('http://localhost:3333/api/config', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(config)\n  })\n  if (!response.ok) throw new Error('Failed to save config')\n}\n\nconst testPattern = async (pattern: string): Promise<string[]> => {\n  const response = await fetch('http://localhost:3333/api/test-pattern', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ pattern })\n  })\n  if (!response.ok) throw new Error('Failed to test pattern')\n  return response.json()\n}\n\nexport function BundleConfig() {\n  const queryClient = useQueryClient()\n  const [editingConfig, setEditingConfig] = useState<BundleConfig | null>(null)\n  const [testingPattern, setTestingPattern] = useState('')\n  const [testResults, setTestResults] = useState<string[]>([])\n  const [pasteConfigText, setPasteConfigText] = useState('')\n\n  // New bundle creation state\n  const [showAddBundle, setShowAddBundle] = useState(false)\n  const [newBundleName, setNewBundleName] = useState('')\n  const [newBundlePatterns, setNewBundlePatterns] = useState('**/*')\n\n  const { setButtonState, getButtonState, isLoading } = useButtonFeedback()\n\n  const { data: config, isLoading: configLoading } = useQuery({\n    queryKey: ['config'],\n    queryFn: fetchConfig\n  })\n\n  const { data: bundles } = useQuery({\n    queryKey: ['bundles'],\n    queryFn: fetchBundles,\n    refetchInterval: 5000\n  })\n\n  const saveMutation = useMutation({\n    mutationFn: saveConfig,\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['config'] })\n      queryClient.invalidateQueries({ queryKey: ['bundles'] })\n      setEditingConfig(null)\n      setButtonState('save', 'success')\n      toast.success('Configuration saved successfully!')\n    },\n    onError: (error) => {\n      setButtonState('save', 'error')\n      toast.error(`Failed to save config: ${error.message}`)\n    }\n  })\n\n  useEffect(() => {\n    if (config && !editingConfig) {\n      setEditingConfig(config)\n    }\n  }, [config])\n\n  const handleSave = () => {\n    if (editingConfig) {\n      setButtonState('save', 'loading')\n      saveMutation.mutate(editingConfig)\n    }\n  }\n\n  const handleTestPattern = async () => {\n    if (!testingPattern.trim()) return\n\n    setButtonState('test', 'loading')\n    try {\n      const results = await testPattern(testingPattern)\n      setTestResults(results)\n      setButtonState('test', 'success')\n      toast.success(`Pattern matched ${results.length} files`)\n    } catch (error) {\n      console.error('Pattern test failed:', error)\n      setTestResults([])\n      setButtonState('test', 'error')\n      toast.error('Failed to test pattern')\n    }\n  }\n\n  const handlePasteConfig = async () => {\n    if (!pasteConfigText.trim()) return\n\n    setButtonState('paste', 'loading')\n    try {\n      const parsed = JSON.parse(pasteConfigText)\n      if (!parsed.bundles || typeof parsed.bundles !== 'object') {\n        throw new Error('Configuration must have a \"bundles\" object')\n      }\n\n      // Ensure master bundle exists\n      if (!parsed.bundles.master) {\n        parsed.bundles.master = ['**/*']\n      }\n\n      setEditingConfig({\n        bundles: Object.fromEntries(\n          Object.entries(parsed.bundles).map(([name, patterns]) => [\n            name,\n            Array.isArray(patterns) ? patterns : [patterns]\n          ])\n        )\n      })\n\n      const bundleCount = Object.keys(parsed.bundles).length\n      setPasteConfigText('')\n      setButtonState('paste', 'success')\n      toast.success(`Applied ${bundleCount} bundles successfully`)\n    } catch (error) {\n      setButtonState('paste', 'error')\n      toast.error(`Invalid configuration: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  // Handle adding new bundle - immediately save to system\n  const handleAddBundle = async () => {\n    if (!editingConfig || !newBundleName.trim()) return\n\n    const trimmedName = newBundleName.trim()\n\n    if (editingConfig.bundles[trimmedName]) {\n      toast.error(`Bundle \"${trimmedName}\" already exists`)\n      return\n    }\n\n    // Parse patterns (split by newlines, filter empty)\n    const patterns = newBundlePatterns\n      .split('\\n')\n      .map(p => p.trim())\n      .filter(p => p.length > 0)\n\n    if (patterns.length === 0) {\n      toast.error('At least one pattern is required')\n      return\n    }\n\n    const newConfig = {\n      ...editingConfig,\n      bundles: {\n        ...editingConfig.bundles,\n        [trimmedName]: patterns\n      }\n    }\n\n    try {\n      // Immediately save to system\n      setButtonState('create-bundle', 'loading')\n      await saveConfig(newConfig)\n\n      // Update local state\n      setEditingConfig(newConfig)\n\n      // Reset form\n      setNewBundleName('')\n      setNewBundlePatterns('**/*')\n      setShowAddBundle(false)\n\n      // Force refresh ALL bundle-related queries\n      await queryClient.invalidateQueries({ queryKey: ['config'] })\n      await queryClient.invalidateQueries({ queryKey: ['bundles'] })\n      await queryClient.invalidateQueries({ queryKey: ['bundle-visibility-stats'] })\n\n      // Also force refetch to ensure immediate update\n      queryClient.refetchQueries({ queryKey: ['bundles'] })\n\n      setButtonState('create-bundle', 'success')\n      toast.success(`Bundle \"${trimmedName}\" created and saved!`)\n    } catch (error) {\n      setButtonState('create-bundle', 'error')\n      toast.error(`Failed to create bundle: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  const handleDeleteBundle = async (bundleName: string) => {\n    if (!editingConfig || bundleName === 'master') return\n    if (!confirm(`Delete bundle \"${bundleName}\"?`)) return\n\n    try {\n      setButtonState(`delete-${bundleName}`, 'loading')\n\n      // Create new config without the deleted bundle\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const { [bundleName]: deleted, ...rest } = editingConfig.bundles\n      const newConfig = { ...editingConfig, bundles: rest }\n\n      // Immediately save to system\n      await saveConfig(newConfig)\n\n      // Update local state\n      setEditingConfig(newConfig)\n\n      // Wait a moment for server to process\n      await new Promise(resolve => setTimeout(resolve, 500))\n\n      // Force clear all cache and refetch\n      queryClient.removeQueries({ queryKey: ['bundles'] })\n      queryClient.removeQueries({ queryKey: ['config'] })\n      queryClient.removeQueries({ queryKey: ['bundle-visibility-stats'] })\n\n      // Force immediate refetch\n      await queryClient.refetchQueries({ queryKey: ['bundles'] })\n      await queryClient.refetchQueries({ queryKey: ['config'] })\n\n      setButtonState(`delete-${bundleName}`, 'success')\n      toast.success(`Bundle \"${bundleName}\" deleted successfully!`)\n    } catch (error) {\n      setButtonState(`delete-${bundleName}`, 'error')\n      toast.error(`Failed to delete bundle: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  const handlePatternChange = async (bundleName: string, index: number, newPattern: string) => {\n    if (!editingConfig) return\n\n    const newPatterns = [...editingConfig.bundles[bundleName]]\n    newPatterns[index] = newPattern\n    const newConfig = {\n      ...editingConfig,\n      bundles: { ...editingConfig.bundles, [bundleName]: newPatterns }\n    }\n\n    setEditingConfig(newConfig)\n\n    // Debounced save - only save after user stops typing for 1 second\n    clearTimeout(window.patternChangeTimeout)\n    window.patternChangeTimeout = setTimeout(async () => {\n      try {\n        await saveConfig(newConfig)\n        queryClient.invalidateQueries({ queryKey: ['config'] })\n        queryClient.invalidateQueries({ queryKey: ['bundles'] })\n      } catch (error) {\n        toast.error(`Failed to save pattern change: ${error instanceof Error ? error.message : 'Unknown error'}`)\n      }\n    }, 1000)\n  }\n\n  const handleAddPattern = async (bundleName: string) => {\n    if (!editingConfig) return\n\n    const newConfig = {\n      ...editingConfig,\n      bundles: {\n        ...editingConfig.bundles,\n        [bundleName]: [...editingConfig.bundles[bundleName], '']\n      }\n    }\n\n    try {\n      await saveConfig(newConfig)\n      setEditingConfig(newConfig)\n      queryClient.invalidateQueries({ queryKey: ['config'] })\n      queryClient.invalidateQueries({ queryKey: ['bundles'] })\n      toast.success('Pattern added')\n    } catch (error) {\n      toast.error(`Failed to add pattern: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  const handleRemovePattern = async (bundleName: string, index: number) => {\n    if (!editingConfig || editingConfig.bundles[bundleName].length === 1) return\n\n    const newPatterns = editingConfig.bundles[bundleName].filter((_, i) => i !== index)\n    const newConfig = {\n      ...editingConfig,\n      bundles: { ...editingConfig.bundles, [bundleName]: newPatterns }\n    }\n\n    try {\n      await saveConfig(newConfig)\n      setEditingConfig(newConfig)\n      queryClient.invalidateQueries({ queryKey: ['config'] })\n      queryClient.invalidateQueries({ queryKey: ['bundles'] })\n      toast.success('Pattern removed')\n    } catch (error) {\n      toast.error(`Failed to remove pattern: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  const getBundleStats = (bundleName: string) => {\n    const bundle = bundles?.find(b => b.name === bundleName)\n    return bundle ? { files: bundle.files.length, size: bundle.size } : { files: 0, size: 0 }\n  }\n\n  const formatSize = (bytes: number) => {\n    if (bytes === 0) return '0 B'\n    const k = 1024\n    const sizes = ['B', 'KB', 'MB', 'GB']\n    const i = Math.floor(Math.log(bytes) / Math.log(k))\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i]\n  }\n\n  if (configLoading) return <div>Loading configuration...</div>\n  if (!editingConfig) return <div>No configuration found</div>\n\n  const hasChanges = JSON.stringify(config) !== JSON.stringify(editingConfig)\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Header */}\n      <div className=\"flex justify-between items-center\">\n        <div>\n          <h2 className=\"text-lg font-semibold\">Bundle Configuration</h2>\n          <p className=\"text-sm text-muted-foreground\">\n            Define patterns for each bundle. Use glob patterns like *.js, src/**/*.tsx, etc.\n          </p>\n        </div>\n        <div className=\"flex gap-2\">\n          <Button\n            variant=\"outline\"\n            onClick={() => setEditingConfig(config || null)}\n            disabled={!hasChanges}\n          >\n            Reset\n          </Button>\n          <Button\n            onClick={handleSave}\n            disabled={!hasChanges || isLoading('save')}\n            className={getButtonClassName(getButtonState('save'))}\n          >\n            {getButtonIcon(getButtonState('save'), <Save className=\"w-4 h-4\" />)}\n            <span className=\"ml-1\">Save Changes</span>\n          </Button>\n        </div>\n      </div>\n\n      {/* Paste Configuration */}\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center gap-2\">\n            <Settings className=\"w-4 h-4\" />\n            Paste Bundle Configuration\n          </CardTitle>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <Textarea\n            placeholder=\"Paste bundle configuration JSON here...\"\n            value={pasteConfigText}\n            onChange={(e) => setPasteConfigText(e.target.value)}\n            className=\"min-h-32 font-mono text-sm\"\n          />\n          <div className=\"flex gap-2\">\n            <Button\n              onClick={handlePasteConfig}\n              disabled={!pasteConfigText.trim() || isLoading('paste')}\n              className={getButtonClassName(getButtonState('paste'))}\n            >\n              {getButtonIcon(getButtonState('paste'), <Settings className=\"w-4 h-4\" />)}\n              <span className=\"ml-1\">Apply Configuration</span>\n            </Button>\n            <Button\n              variant=\"outline\"\n              onClick={() => setPasteConfigText('')}\n              disabled={!pasteConfigText.trim()}\n            >\n              Clear\n            </Button>\n          </div>\n        </CardContent>\n      </Card>\n\n      {/* Pattern Tester */}\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center gap-2\">\n            <Eye className=\"w-4 h-4\" />\n            Pattern Tester\n          </CardTitle>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <div className=\"flex gap-2\">\n            <Input\n              placeholder=\"Test a glob pattern (e.g., src/**/*.ts)\"\n              value={testingPattern}\n              onChange={(e) => setTestingPattern(e.target.value)}\n              onKeyDown={(e) => e.key === 'Enter' && handleTestPattern()}\n            />\n            <Button\n              onClick={handleTestPattern}\n              disabled={!testingPattern.trim() || isLoading('test')}\n              className={getButtonClassName(getButtonState('test'))}\n            >\n              {getButtonIcon(getButtonState('test'), <Eye className=\"w-4 h-4\" />)}\n              <span className=\"ml-1\">Test</span>\n            </Button>\n          </div>\n\n          {testResults.length > 0 && (\n            <div className=\"space-y-2\">\n              <div className=\"text-sm font-medium\">\n                Matches {testResults.length} files:\n              </div>\n              <div className=\"max-h-40 overflow-y-auto bg-muted p-3 rounded-md\">\n                {testResults.slice(0, 20).map((file, i) => (\n                  <div key={i} className=\"text-sm font-mono\">{file}</div>\n                ))}\n                {testResults.length > 20 && (\n                  <div className=\"text-sm text-muted-foreground\">\n                    ... and {testResults.length - 20} more files\n                  </div>\n                )}\n              </div>\n            </div>\n          )}\n        </CardContent>\n      </Card>\n\n      {/* Bundle Enhancement Options - NEW SECTION */}\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center gap-2\">\n            <Settings className=\"w-4 h-4\" />\n            Bundle Enhancement Options\n          </CardTitle>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <div className=\"grid md:grid-cols-2 gap-6\">\n            {/* Structure & Context */}\n            <div className=\"space-y-3\">\n              <h4 className=\"font-medium text-sm\">Structure & Context</h4>\n              <div className=\"space-y-2\">\n                <label className=\"flex items-center gap-3\">\n                  <input type=\"checkbox\" className=\"rounded\" />\n                  <div className=\"flex-1\">\n                    <div className=\"text-sm\">Directory Tree</div>\n                    <div className=\"text-xs text-muted-foreground\">Include project structure overview</div>\n                  </div>\n                  <Badge variant=\"outline\" className=\"text-xs\">+10%</Badge>\n                </label>\n\n                <label className=\"flex items-center gap-3\">\n                  <input type=\"checkbox\" className=\"rounded\" />\n                  <div className=\"flex-1\">\n                    <div className=\"text-sm\">File Types</div>\n                    <div className=\"text-xs text-muted-foreground\">Auto-detect file purposes</div>\n                  </div>\n                  <Badge variant=\"outline\" className=\"text-xs\">+5%</Badge>\n                </label>\n\n                <label className=\"flex items-center gap-3\">\n                  <input type=\"checkbox\" className=\"rounded\" />\n                  <div className=\"flex-1\">\n                    <div className=\"text-sm\">Dependencies</div>\n                    <div className=\"text-xs text-muted-foreground\">Import/export mapping</div>\n                  </div>\n                  <Badge variant=\"outline\" className=\"text-xs\">+25%</Badge>\n                </label>\n              </div>\n            </div>\n\n            {/* AI Instructions */}\n            <div className=\"space-y-3\">\n              <h4 className=\"font-medium text-sm\">AI Instructions</h4>\n              <div className=\"space-y-2\">\n                <label className=\"flex items-center gap-3\">\n                  <input type=\"checkbox\" defaultChecked className=\"rounded\" />\n                  <div className=\"flex-1\">\n                    <div className=\"text-sm\">Bundle Purpose</div>\n                    <div className=\"text-xs text-muted-foreground\">What this bundle is for</div>\n                  </div>\n                  <Badge variant=\"outline\" className=\"text-xs\">+2%</Badge>\n                </label>\n\n                <label className=\"flex items-center gap-3\">\n                  <input type=\"checkbox\" defaultChecked className=\"rounded\" />\n                  <div className=\"flex-1\">\n                    <div className=\"text-sm\">Cursor Rules</div>\n                    <div className=\"text-xs text-muted-foreground\">Include .cursorrules content</div>\n                  </div>\n                  <Badge variant=\"outline\" className=\"text-xs\">+15%</Badge>\n                </label>\n\n                <label className=\"flex items-center gap-3\">\n                  <input type=\"checkbox\" className=\"rounded\" />\n                  <div className=\"flex-1\">\n                    <div className=\"text-sm\">Custom Instructions</div>\n                    <div className=\"text-xs text-muted-foreground\">Bundle-specific AI guidance</div>\n                  </div>\n                  <Badge variant=\"outline\" className=\"text-xs\">+5%</Badge>\n                </label>\n              </div>\n            </div>\n          </div>\n\n          <div className=\"bg-[color:var(--color-info)]/5 p-3 rounded-md\">\n            <div className=\"text-sm text-[color:var(--color-info)]\">\n              <strong>Coming Soon:</strong> These enhancement options will add rich context to your bundles,\n              making them more useful for AI agents. Enable features based on your needs vs. bundle size preferences.\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n\n      {/* Bundle Configurations */}\n      <div className=\"space-y-4\">\n        {Object.entries(editingConfig.bundles).map(([bundleName, patterns]) => {\n          const stats = getBundleStats(bundleName)\n          const isLarge = stats.size > 10 * 1024 * 1024\n\n          return (\n            <Card key={bundleName} className={isLarge ? 'border-[color:var(--color-warning)]' : ''}>\n              <CardHeader>\n                <div className=\"flex justify-between items-center\">\n                  <div className=\"flex items-center gap-3\">\n                    <CardTitle>{bundleName}</CardTitle>\n                    <Badge variant=\"outline\">\n                      {stats.files} files • {formatSize(stats.size)}\n                    </Badge>\n                    {isLarge && (\n                      <Badge variant=\"destructive\" className=\"flex items-center gap-1\">\n                        <AlertTriangle className=\"w-3 h-3\" />\n                        Large\n                      </Badge>\n                    )}\n                  </div>\n                  <div className=\"flex gap-2\">\n                    <Button\n                      variant=\"outline\"\n                      size=\"sm\"\n                      onClick={() => handleAddPattern(bundleName)}\n                    >\n                      <Plus className=\"w-4 h-4 mr-1\" />\n                      Add Pattern\n                    </Button>\n                    {bundleName !== 'master' && (\n                      <Button\n                        variant=\"outline\"\n                        size=\"sm\"\n                        onClick={() => handleDeleteBundle(bundleName)}\n                        disabled={isLoading(`delete-${bundleName}`)}\n                        className={getButtonClassName(getButtonState(`delete-${bundleName}`))}\n                      >\n                        {getButtonIcon(getButtonState(`delete-${bundleName}`), <Trash2 className=\"w-4 h-4\" />)}\n                      </Button>\n                    )}\n                  </div>\n                </div>\n              </CardHeader>\n              <CardContent className=\"space-y-3\">\n                {patterns.map((pattern, index) => (\n                  <div key={index} className=\"flex gap-2\">\n                    <Input\n                      value={pattern}\n                      onChange={(e) => handlePatternChange(bundleName, index, e.target.value)}\n                      placeholder=\"Glob pattern (e.g., src/**/*.ts)\"\n                      className=\"font-mono\"\n                    />\n                    {patterns.length > 1 && (\n                      <Button\n                        variant=\"outline\"\n                        size=\"sm\"\n                        onClick={() => handleRemovePattern(bundleName, index)}\n                      >\n                        <Trash2 className=\"w-4 h-4\" />\n                      </Button>\n                    )}\n                  </div>\n                ))}\n              </CardContent>\n            </Card>\n          )\n        })}\n      </div>\n\n      {/* Add New Bundle */}\n      <Card>\n        <CardContent className=\"pt-6\">\n          {!showAddBundle ? (\n            <Button\n              variant=\"outline\"\n              onClick={() => setShowAddBundle(true)}\n              className=\"w-full\"\n            >\n              <Plus className=\"w-4 h-4 mr-2\" />\n              Add New Bundle\n            </Button>\n          ) : (\n            <div className=\"space-y-4\">\n              <div className=\"flex justify-between items-center\">\n                <h3 className=\"text-lg font-medium\">Create New Bundle</h3>\n                <Button\n                  variant=\"ghost\"\n                  size=\"sm\"\n                  onClick={() => {\n                    setShowAddBundle(false)\n                    setNewBundleName('')\n                    setNewBundlePatterns('**/*')\n                  }}\n                >\n                  <X className=\"w-4 h-4\" />\n                </Button>\n              </div>\n\n              <div className=\"space-y-3\">\n                <div>\n                  <label className=\"text-sm font-medium\">Bundle Name</label>\n                  <Input\n                    placeholder=\"e.g., frontend, backend, tests\"\n                    value={newBundleName}\n                    onChange={(e) => setNewBundleName(e.target.value)}\n                  />\n                </div>\n\n                <div>\n                  <label className=\"text-sm font-medium\">Patterns (one per line)</label>\n                  <Textarea\n                    placeholder=\"src/components/**/*&#10;src/pages/**/*&#10;*.jsx\"\n                    value={newBundlePatterns}\n                    onChange={(e) => setNewBundlePatterns(e.target.value)}\n                    className=\"font-mono text-sm\"\n                    rows={4}\n                  />\n                  <div className=\"text-xs text-muted-foreground mt-1\">\n                    Examples: <code>src/**/*.ts</code>, <code>**/*.test.*</code>, <code>docs/**/*</code>\n                  </div>\n                </div>\n              </div>\n\n              <div className=\"flex gap-2\">\n                <Button\n                  onClick={handleAddBundle}\n                  disabled={!newBundleName.trim() || isLoading('create-bundle')}\n                  className={getButtonClassName(getButtonState('create-bundle'))}\n                >\n                  {getButtonIcon(getButtonState('create-bundle'), <Plus className=\"w-4 h-4\" />)}\n                  <span className=\"ml-1\">Create Bundle</span>\n                </Button>\n                <Button\n                  variant=\"outline\"\n                  onClick={() => {\n                    setShowAddBundle(false)\n                    setNewBundleName('')\n                    setNewBundlePatterns('**/*')\n                  }}\n                  disabled={isLoading('create-bundle')}\n                >\n                  Cancel\n                </Button>\n              </div>\n            </div>\n          )}\n        </CardContent>\n      </Card>\n    </div>\n  )\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/BundleList.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"42133\" modified=\"2025-06-26T17:12:31.324Z\" lines=\"1038\" />\n        <cntx:content><![CDATA[// web/src/components/BundleList.tsx\nimport { useQuery, useQueryClient } from '@tanstack/react-query'\nimport { Card, CardHeader, CardTitle, CardContent } from './ui/card'\nimport { Button } from '@/components/ui/button'\nimport { Badge } from '@/components/ui/badge'\n// import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'\nimport { Copy, RefreshCw, Loader2, CheckCircle, AlertCircle, Download, FileText, Settings, Code, BookOpen, Edit3, X, Plus, Minus, Search, AlertTriangle } from 'lucide-react'\nimport { useState } from 'react'\nimport { toast } from '@/lib/toast'\n\ninterface Bundle {\n  name: string\n  changed: boolean\n  fileCount: number\n  content: string\n  files: string[]\n  lastGenerated: string\n  size: number\n}\n\n\nconst fetchBundles = async (): Promise<Bundle[]> => {\n  const response = await fetch('http://localhost:3333/api/bundles')\n  if (!response.ok) throw new Error('Failed to fetch bundles')\n  return response.json()\n}\n\n\nconst fetchAllFiles = async (): Promise<string[]> => {\n  const response = await fetch('http://localhost:3333/api/files')\n  if (!response.ok) throw new Error('Failed to fetch files')\n  const fileData = await response.json()\n  return fileData.map((f: any) => f.path)\n}\n\nconst fetchUndercategorizedFiles = async (): Promise<{path: string, bundles: string[]}[]> => {\n  const response = await fetch('http://localhost:3333/api/files-with-visibility')\n  if (!response.ok) throw new Error('Failed to fetch files with visibility')\n  const filesData = await response.json()\n  \n  // Find files that are only in the 'master' bundle (need better bundle assignment)\n  // AND aren't globally hidden (which means they should be ignored)\n  return filesData\n    .filter((file: any) => {\n      const isNotGloballyHidden = !file.globallyHidden\n      const bundles = file.inBundles || []\n      const onlyInMaster = bundles.length === 1 && bundles[0] === 'master'\n      const hasNoBundles = bundles.length === 0\n      \n      return isNotGloballyHidden && (onlyInMaster || hasNoBundles)\n    })\n    .map((file: any) => ({\n      path: file.path,\n      bundles: file.inBundles || []\n    }))\n}\n\nconst suggestBundleForFile = (filePath: string): string[] => {\n  const fileName = filePath.toLowerCase()\n  const pathParts = fileName.split('/')\n  \n  const suggestions: string[] = []\n  \n  // Web/frontend files\n  if (pathParts.includes('web') || pathParts.includes('src')) {\n    suggestions.push('frontend')\n    \n    // More specific frontend bundles\n    if (pathParts.includes('components')) {\n      suggestions.push('ui-components')\n    }\n  }\n  \n  // Server/backend files\n  if (fileName.includes('server') || fileName.includes('api') || pathParts.includes('bin')) {\n    suggestions.push('server')\n  }\n  \n  // Configuration files\n  if (fileName.includes('config') || fileName.includes('setup') || fileName.endsWith('.json') || \n      fileName.endsWith('.sh') || fileName.includes('package')) {\n    suggestions.push('config')\n  }\n  \n  // Documentation\n  if (fileName.endsWith('.md') || fileName.includes('doc') || fileName.includes('readme')) {\n    suggestions.push('docs')\n  }\n  \n  // If no specific suggestions, suggest the most general applicable bundles\n  if (suggestions.length === 0) {\n    if (pathParts.includes('web')) {\n      suggestions.push('frontend')\n    } else {\n      suggestions.push('server', 'config')\n    }\n  }\n  \n  return suggestions\n}\n\nexport function BundleList() {\n  const queryClient = useQueryClient()\n  const [selectedBundle, setSelectedBundle] = useState<string | null>(null)\n  const [editingBundles, setEditingBundles] = useState<Set<string>>(new Set())\n  const [availableFiles, setAvailableFiles] = useState<string[]>([])\n  const [undercategorizedFiles, setUndercategorizedFiles] = useState<{path: string, bundles: string[]}[]>([])\n  const [showFileAnalysis, setShowFileAnalysis] = useState(false)\n  const [availableFilesSearch, setAvailableFilesSearch] = useState('')\n  const [loadingButtons, setLoadingButtons] = useState<Set<string>>(new Set())\n  const [successButtons, setSuccessButtons] = useState<Set<string>>(new Set())\n  const [errorButtons, setErrorButtons] = useState<Set<string>>(new Set())\n\n  // Use React Query for proper state management\n  const { data: bundles = [], isLoading, refetch } = useQuery({\n    queryKey: ['bundles'],\n    queryFn: fetchBundles,\n    refetchInterval: 5000,\n    refetchOnWindowFocus: true\n  })\n\n  const selectBundle = async (bundleName: string) => {\n    if (selectedBundle === bundleName) {\n      setSelectedBundle(null)\n    } else {\n      setSelectedBundle(bundleName)\n    }\n  }\n\n  // Get which bundles a file belongs to\n  const getFileBundles = (filePath: string) => {\n    return bundles.filter(bundle => bundle.files.includes(filePath)).map(b => b.name)\n  }\n\n  // Helper function to get icon for file type\n  const getFileIcon = (fileName: string) => {\n    const ext = fileName.split('.').pop()?.toLowerCase()\n    switch (ext) {\n      case 'tsx':\n      case 'jsx':\n        return <Code className=\"w-3 h-3 text-blue-500\" />\n      case 'ts':\n      case 'js':\n        return <FileText className=\"w-3 h-3 text-yellow-500\" />\n      case 'json':\n        return <Settings className=\"w-3 h-3 text-green-500\" />\n      case 'md':\n        return <BookOpen className=\"w-3 h-3 text-purple-500\" />\n      case 'css':\n      case 'scss':\n        return <FileText className=\"w-3 h-3 text-pink-500\" />\n      case 'html':\n        return <FileText className=\"w-3 h-3 text-orange-500\" />\n      case 'sh':\n        return <FileText className=\"w-3 h-3 text-gray-500\" />\n      default:\n        return <FileText className=\"w-3 h-3 text-gray-400\" />\n    }\n  }\n\n\n  // File picker functions\n  const toggleEditMode = async (bundleName: string) => {\n    const newEditing = new Set(editingBundles)\n    if (newEditing.has(bundleName)) {\n      newEditing.delete(bundleName)\n    } else {\n      newEditing.add(bundleName)\n      // Always fetch fresh available files when entering edit mode\n      try {\n        const files = await fetchAllFiles()\n        setAvailableFiles(files)\n      } catch (error) {\n        console.error('Failed to fetch files:', error)\n        toast.error('Failed to load file list')\n      }\n    }\n    setEditingBundles(newEditing)\n  }\n\n  const isFileInBundle = (fileName: string, bundle: Bundle) => {\n    return bundle.files.includes(fileName)\n  }\n\n  const getFileExclusions = (fileName: string, currentBundle: string): string[] => {\n    if (!bundles || !Array.isArray(bundles)) return []\n    return bundles\n      .filter((b: Bundle) => b.name !== currentBundle && b.files.includes(fileName))\n      .map((b: Bundle) => b.name)\n  }\n\n  const removeFileFromBundle = async (fileName: string, bundleName: string) => {\n    try {\n      setButtonState(`remove-${bundleName}-${fileName}`, 'loading')\n\n      console.log(`Removing ${fileName} from ${bundleName}`)\n\n      // Prevent modifications to master bundle\n      if (bundleName === 'master') {\n        setButtonState(`remove-${bundleName}-${fileName}`, 'error')\n        toast.error('Cannot modify master bundle files')\n        return\n      }\n\n      // Get current configuration\n      const configResponse = await fetch('http://localhost:3333/api/config')\n      if (!configResponse.ok) {\n        throw new Error('Failed to fetch current configuration')\n      }\n      \n      const currentConfig = await configResponse.json()\n      \n      // Remove the file from the bundle's patterns (not hide it!)\n      if (currentConfig.bundles[bundleName]) {\n        currentConfig.bundles[bundleName] = currentConfig.bundles[bundleName].filter(\n          (pattern: string) => pattern !== fileName\n        )\n        console.log(`Removed ${fileName} from ${bundleName} patterns`)\n      }\n\n      // Update the configuration\n      const updateResponse = await fetch('http://localhost:3333/api/config', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(currentConfig)\n      })\n\n      if (!updateResponse.ok) {\n        const errorText = await updateResponse.text()\n        console.error('API Error:', errorText)\n        throw new Error(`Failed to update configuration: ${errorText}`)\n      }\n\n      // Force refresh the bundles query to get the updated data\n      queryClient.invalidateQueries({ queryKey: ['bundles'] })\n\n      setButtonState(`remove-${bundleName}-${fileName}`, 'success')\n      toast.success(`Removed ${fileName} from ${bundleName} bundle`)\n\n    } catch (error) {\n      console.error('Failed to remove file:', error)\n      setButtonState(`remove-${bundleName}-${fileName}`, 'error')\n      toast.error(`Failed to remove file: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  const addFileToBundle = async (fileName: string, bundleName: string) => {\n    try {\n      setButtonState(`add-${bundleName}-${fileName}`, 'loading')\n\n      // Prevent modifications to master bundle\n      if (bundleName === 'master') {\n        setButtonState(`add-${bundleName}-${fileName}`, 'error')\n        toast.error('Cannot modify master bundle files')\n        return\n      }\n\n      // First, get the current configuration\n      const configResponse = await fetch('http://localhost:3333/api/config')\n      if (!configResponse.ok) {\n        throw new Error('Failed to fetch current configuration')\n      }\n      \n      const currentConfig = await configResponse.json()\n      \n      // Add the file to the bundle's patterns\n      if (!currentConfig.bundles[bundleName]) {\n        currentConfig.bundles[bundleName] = []\n      }\n      \n      // Add the exact file path if it's not already there\n      if (!currentConfig.bundles[bundleName].includes(fileName)) {\n        currentConfig.bundles[bundleName].push(fileName)\n      }\n\n      // Update the configuration\n      const updateResponse = await fetch('http://localhost:3333/api/config', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(currentConfig)\n      })\n\n      if (!updateResponse.ok) {\n        const errorText = await updateResponse.text()\n        throw new Error(`Failed to update configuration: ${errorText}`)\n      }\n\n      // Remove the file from the bundle's hidden list\n      await fetch('http://localhost:3333/api/hidden-files', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          action: 'toggle',\n          filePath: fileName,\n          bundleName: bundleName,\n          forceHide: false\n        })\n      })\n\n      // Force refresh the bundles query to get the updated data\n      queryClient.invalidateQueries({ queryKey: ['bundles'] })\n\n      setButtonState(`add-${bundleName}-${fileName}`, 'success')\n      toast.success(`Added ${fileName} to ${bundleName} bundle`)\n\n      // Refresh undercategorized files if they're currently being shown\n      if (showFileAnalysis) {\n        await loadFileAnalysis()\n      }\n\n    } catch (error) {\n      console.error('Failed to add file:', error)\n      setButtonState(`add-${bundleName}-${fileName}`, 'error')\n      toast.error(`Failed to add file: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  const setButtonState = (key: string, state: 'loading' | 'success' | 'error' | 'idle') => {\n    setLoadingButtons(prev => {\n      const newSet = new Set(prev)\n      if (state === 'loading') newSet.add(key)\n      else newSet.delete(key)\n      return newSet\n    })\n\n    setSuccessButtons(prev => {\n      const newSet = new Set(prev)\n      if (state === 'success') {\n        newSet.add(key)\n        // Auto-clear success state after 2 seconds\n        setTimeout(() => setSuccessButtons(current => {\n          const updated = new Set(current)\n          updated.delete(key)\n          return updated\n        }), 2000)\n      } else {\n        newSet.delete(key)\n      }\n      return newSet\n    })\n\n    setErrorButtons(prev => {\n      const newSet = new Set(prev)\n      if (state === 'error') {\n        newSet.add(key)\n        // Auto-clear error state after 3 seconds\n        setTimeout(() => setErrorButtons(current => {\n          const updated = new Set(current)\n          updated.delete(key)\n          return updated\n        }), 3000)\n      } else {\n        newSet.delete(key)\n      }\n      return newSet\n    })\n  }\n\n  const copyBundle = async (bundleName: string) => {\n    const key = `copy-${bundleName}`\n    setButtonState(key, 'loading')\n\n    try {\n      const response = await fetch(`http://localhost:3333/api/bundles/${bundleName}`)\n      if (!response.ok) throw new Error('Failed to fetch bundle content')\n\n      const content = await response.text()\n      await navigator.clipboard.writeText(content)\n\n      setButtonState(key, 'success')\n      toast.success(`Bundle \"${bundleName}\" copied to clipboard!`)\n    } catch (error) {\n      setButtonState(key, 'error')\n      toast.error(`Failed to copy bundle: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  const downloadBundle = async (bundleName: string) => {\n    const key = `download-${bundleName}`\n    setButtonState(key, 'loading')\n\n    try {\n      const response = await fetch(`http://localhost:3333/api/bundles/${bundleName}`)\n      if (!response.ok) throw new Error('Failed to fetch bundle content')\n\n      const content = await response.text()\n      const blob = new Blob([content], { type: 'application/xml' })\n      const url = URL.createObjectURL(blob)\n      const a = document.createElement('a')\n      a.href = url\n      a.download = `${bundleName}-bundle.xml`\n      a.click()\n      URL.revokeObjectURL(url)\n\n      setButtonState(key, 'success')\n      toast.success(`Bundle \"${bundleName}\" downloaded!`)\n    } catch (error) {\n      setButtonState(key, 'error')\n      toast.error(`Failed to download bundle: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  const regenerateBundle = async (bundleName: string) => {\n    const key = `regen-${bundleName}`\n    setButtonState(key, 'loading')\n\n    try {\n      const response = await fetch(`http://localhost:3333/api/regenerate/${bundleName}`, {\n        method: 'POST'\n      })\n      if (!response.ok) throw new Error('Failed to regenerate bundle')\n\n      await refetch()\n      setButtonState(key, 'success')\n      toast.success(`Bundle \"${bundleName}\" regenerated successfully!`)\n    } catch (error) {\n      setButtonState(key, 'error')\n      toast.error(`Failed to regenerate bundle: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  if (isLoading) return <div>Loading bundles...</div>\n  if (!bundles) return <div>No bundles found</div>\n\n  const loadFileAnalysis = async () => {\n    try {\n      const undercategorized = await fetchUndercategorizedFiles()\n      setUndercategorizedFiles(undercategorized)\n      \n      console.log('Found undercategorized files:', { \n        total: undercategorized.length,\n        files: undercategorized.map(f => ({ path: f.path, bundles: f.bundles }))\n      })\n    } catch (error) {\n      console.error('Failed to fetch file analysis:', error)\n      toast.error('Failed to load file analysis')\n    }\n  }\n\n  const suggestCategoryImprovement = async (filePath: string, suggestedCategory: string) => {\n    const key = `categorize-${filePath}`\n    setButtonState(key, 'loading')\n    \n    try {\n      // For now, we'll just show a success message and suggest the user report this to improve the backend\n      // In a real implementation, this would send category suggestions to the backend for ML training\n      toast.success(`Category suggestion recorded: ${filePath} → ${suggestedCategory}`)\n      \n      // TODO: Implement actual backend endpoint for category suggestions\n      // const response = await fetch('http://localhost:3333/api/suggest-category', {\n      //   method: 'POST',\n      //   headers: { 'Content-Type': 'application/json' },\n      //   body: JSON.stringify({ filePath, suggestedCategory })\n      // })\n      \n      setButtonState(key, 'success')\n    } catch (error) {\n      console.error('Failed to suggest category:', error)\n      setButtonState(key, 'error')\n      toast.error('Failed to record category suggestion')\n    }\n  }\n\n  const manualRefresh = async () => {\n    console.log('Manual refresh triggered')\n    queryClient.removeQueries({ queryKey: ['bundles'] })\n    const result = await refetch()\n    console.log('Fresh bundles data:', result.data)\n    \n    // Also refresh file analysis\n    if (showFileAnalysis) {\n      await loadFileAnalysis()\n    }\n  }\n\n  // Bundle Grid Card Component\n  const BundleGridCard = ({ bundle }: { bundle: Bundle }) => {\n    const copyKey = `copy-${bundle.name}`\n    const downloadKey = `download-${bundle.name}`\n    const regenKey = `regen-${bundle.name}`\n    const isCopyLoading = loadingButtons.has(copyKey)\n    const isDownloadLoading = loadingButtons.has(downloadKey)\n    const isRegenLoading = loadingButtons.has(regenKey)\n    const isCopySuccess = successButtons.has(copyKey)\n    const isDownloadSuccess = successButtons.has(downloadKey)\n    const isRegenSuccess = successButtons.has(regenKey)\n    const isCopyError = errorButtons.has(copyKey)\n    const isDownloadError = errorButtons.has(downloadKey)\n    const isRegenError = errorButtons.has(regenKey)\n    const isSelected = selectedBundle === bundle.name\n    \n    // Check if bundle has files needing bundle assignment (files only in master bundle)\n    const fileBundles = bundle.files.map(file => getFileBundles(file))\n    const hasUnassignedFiles = fileBundles.some(bundles => bundles.length === 1 && bundles[0] === 'master')\n\n    return (\n      <Card \n        className={`cursor-pointer transition-all hover:shadow-md ${\n          bundle.changed ? 'border-warning' : ''\n        } ${isSelected ? 'ring-2 ring-primary border-primary' : ''}`}\n        onClick={() => selectBundle(bundle.name)}\n      >\n        <CardHeader className=\"pb-2\">\n          <div className=\"space-y-1.5\">\n            <h3 className=\"text-sm font-medium truncate\">{bundle.name}</h3>\n            <Badge variant={bundle.changed ? 'destructive' : 'secondary'} className=\"text-xs font-normal h-4 w-fit\">\n              {bundle.changed ? 'CHANGED' : 'SYNCED'}\n            </Badge>\n          </div>\n        </CardHeader>\n        <CardContent className=\"pt-0\">\n          <div className=\"space-y-2\">\n            <div className=\"text-xs text-muted-foreground\">\n              <div className=\"flex flex-wrap gap-x-2 gap-y-1 items-center\">\n                <span>{bundle.fileCount} files</span>\n                <span>•</span>\n                <span>{(bundle.size / 1024).toFixed(1)}kb</span>\n                {hasUnassignedFiles && (\n                  <>\n                    <span>•</span>\n                    <span className=\"text-warning text-xs\">\n                      <AlertTriangle className=\"w-2.5 h-2.5 inline mr-1\" />\n                      Files need assignment\n                    </span>\n                  </>\n                )}\n              </div>\n            </div>\n            \n            <div className=\"flex\" onClick={(e) => e.stopPropagation()}>\n              <div className=\"inline-flex rounded-md border border-input bg-background shadow-sm\">\n                <Button\n                  variant=\"ghost\"\n                  size=\"sm\"\n                  onClick={() => regenerateBundle(bundle.name)}\n                  disabled={isRegenLoading}\n                  className=\"h-6 px-1.5 rounded-none border-r border-input first:rounded-l-md last:rounded-r-md hover:bg-accent\"\n                >\n                  {isRegenLoading ? (\n                    <Loader2 className=\"w-2.5 h-2.5 animate-spin\" />\n                  ) : isRegenSuccess ? (\n                    <CheckCircle className=\"w-2.5 h-2.5\" />\n                  ) : isRegenError ? (\n                    <AlertCircle className=\"w-2.5 h-2.5\" />\n                  ) : (\n                    <RefreshCw className=\"w-2.5 h-2.5\" />\n                  )}\n                </Button>\n                <Button\n                  variant=\"ghost\"\n                  size=\"sm\"\n                  onClick={() => copyBundle(bundle.name)}\n                  disabled={isCopyLoading}\n                  className=\"h-6 px-1.5 rounded-none border-r border-input first:rounded-l-md last:rounded-r-md hover:bg-accent\"\n                >\n                  {isCopyLoading ? (\n                    <Loader2 className=\"w-2.5 h-2.5 animate-spin\" />\n                  ) : isCopySuccess ? (\n                    <CheckCircle className=\"w-2.5 h-2.5\" />\n                  ) : isCopyError ? (\n                    <AlertCircle className=\"w-2.5 h-2.5\" />\n                  ) : (\n                    <Copy className=\"w-2.5 h-2.5\" />\n                  )}\n                </Button>\n                <Button\n                  variant=\"ghost\"\n                  size=\"sm\"\n                  onClick={() => downloadBundle(bundle.name)}\n                  disabled={isDownloadLoading}\n                  className=\"h-6 px-1.5 rounded-none first:rounded-l-md last:rounded-r-md hover:bg-accent\"\n                >\n                  {isDownloadLoading ? (\n                    <Loader2 className=\"w-2.5 h-2.5 animate-spin\" />\n                  ) : isDownloadSuccess ? (\n                    <CheckCircle className=\"w-2.5 h-2.5\" />\n                  ) : isDownloadError ? (\n                    <AlertCircle className=\"w-2.5 h-2.5\" />\n                  ) : (\n                    <Download className=\"w-2.5 h-2.5\" />\n                  )}\n                </Button>\n              </div>\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n    )\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex justify-between items-center\">\n        <div className=\"flex items-center gap-4\">\n          <h2 className=\"text-lg font-semibold\">Bundles</h2>\n          {undercategorizedFiles.length > 0 && (\n            <Badge variant=\"outline\" className=\"bg-warning/10 text-warning border-warning/20\">\n              <AlertTriangle className=\"w-3 h-3 mr-1\" />\n              {undercategorizedFiles.length} files need better bundle assignment\n            </Badge>\n          )}\n        </div>\n        <div className=\"flex gap-2\">\n          <Button\n            onClick={async () => {\n              if (!showFileAnalysis) {\n                await loadFileAnalysis()\n              }\n              setShowFileAnalysis(!showFileAnalysis)\n            }}\n            variant={showFileAnalysis ? \"default\" : \"outline\"}\n            size=\"sm\"\n          >\n            <Search className=\"w-4 h-4 mr-1\" />\n            {showFileAnalysis ? 'Hide' : 'Analyze'} File Bundle Assignment\n          </Button>\n          <Button onClick={manualRefresh} variant=\"outline\" size=\"sm\">\n            <RefreshCw className=\"w-4 h-4 mr-1\" />\n            Force Refresh\n          </Button>\n        </div>\n      </div>\n      \n      {/* File Bundle Assignment Analysis Section */}\n      {showFileAnalysis && (\n        <Card className=\"border-warning/20 bg-warning/5\">\n          <CardHeader>\n            <CardTitle className=\"flex items-center gap-2 text-warning\">\n              <AlertTriangle className=\"w-4 h-4\" />\n              File Bundle Assignment Analysis\n            </CardTitle>\n            <p className=\"text-sm text-muted-foreground\">\n              Files that need better bundle assignment. All files belong to the 'master' bundle by default, but should also belong to more specific bundles.\n            </p>\n          </CardHeader>\n          <CardContent>\n            {undercategorizedFiles.length === 0 ? (\n              <div className=\"text-center py-8 text-muted-foreground\">\n                <CheckCircle className=\"w-8 h-8 mx-auto mb-2 text-[color:var(--color-success)]\" />\n                <p>Excellent! All files are properly assigned to specific bundles.</p>\n                <p className=\"text-sm\">No files are sitting in only the master bundle.</p>\n              </div>\n            ) : (\n              <div className=\"space-y-4\">\n                <div className=\"space-y-3\">\n                  <h4 className=\"font-medium text-warning flex items-center gap-2\">\n                    <AlertTriangle className=\"w-4 h-4\" />\n                    Files Needing Bundle Assignment ({undercategorizedFiles.length})\n                  </h4>\n                  <p className=\"text-sm text-muted-foreground\">\n                    These files are only in the 'master' bundle and should be assigned to more specific bundles for better organization.\n                  </p>\n                  <div className=\"space-y-2 max-h-60 overflow-y-auto\">\n                    {undercategorizedFiles.map((fileInfo) => {\n                      const suggestions = suggestBundleForFile(fileInfo.path)\n                      const currentBundleText = fileInfo.bundles.length === 0 ? 'none' : fileInfo.bundles.join(', ')\n                      \n                      return (\n                        <div key={fileInfo.path} className=\"flex items-center gap-2 p-3 rounded border border-warning/20 bg-background\">\n                          <div className=\"flex-1 min-w-0\">\n                            <div className=\"font-mono text-sm text-foreground truncate\">\n                              {fileInfo.path}\n                            </div>\n                            <div className=\"flex items-center gap-2 mt-1\">\n                              <span className=\"text-xs text-muted-foreground\">\n                                Currently in: {currentBundleText === 'master' ? 'master only' : currentBundleText}\n                              </span>\n                              {suggestions.length > 0 && (\n                                <div className=\"flex items-center gap-1\">\n                                  <span className=\"text-xs text-muted-foreground\">Suggested:</span>\n                                  {suggestions.slice(0, 2).map((bundle) => (\n                                    <Badge key={bundle} variant=\"outline\" className=\"text-xs px-1 py-0\">\n                                      {bundle}\n                                    </Badge>\n                                  ))}\n                                </div>\n                              )}\n                            </div>\n                          </div>\n                          <div className=\"flex gap-1 flex-shrink-0\">\n                            <Button\n                              variant=\"outline\"\n                              size=\"sm\"\n                              onClick={() => {\n                                // Hide this file globally (add to ignore patterns)\n                                fetch('http://localhost:3333/api/hidden-files', {\n                                  method: 'POST',\n                                  headers: { 'Content-Type': 'application/json' },\n                                  body: JSON.stringify({\n                                    action: 'toggle',\n                                    filePath: fileInfo.path,\n                                    forceHide: true\n                                  })\n                                }).then(() => {\n                                  toast.success(`Hidden ${fileInfo.path} from all bundles`)\n                                  loadFileAnalysis() // Refresh the analysis\n                                }).catch(error => {\n                                  console.error('Failed to hide file:', error)\n                                  toast.error('Failed to hide file')\n                                })\n                              }}\n                              className=\"h-6 px-2 text-xs border-muted hover:bg-muted\"\n                            >\n                              Ignore\n                            </Button>\n                            {(suggestions.length > 0 ? suggestions.slice(0, 2) : bundles.filter(b => b.name !== 'master').slice(0, 2)).map((bundleName) => (\n                              <Button\n                                key={bundleName}\n                                variant=\"outline\"\n                                size=\"sm\"\n                                onClick={() => addFileToBundle(fileInfo.path, bundleName)}\n                                className=\"h-6 px-2 text-xs\"\n                              >\n                                Add to {bundleName}\n                              </Button>\n                            ))}\n                          </div>\n                        </div>\n                      )\n                    })}\n                  </div>\n                </div>\n\n                <div className=\"flex justify-between items-center pt-2 border-t border-warning/20\">\n                  <span className=\"text-sm text-muted-foreground\">\n                    {undercategorizedFiles.length} files need better bundle assignment\n                  </span>\n                  <Button\n                    variant=\"outline\"\n                    size=\"sm\"\n                    onClick={loadFileAnalysis}\n                  >\n                    <RefreshCw className=\"w-3 h-3 mr-1\" />\n                    Refresh Analysis\n                  </Button>\n                </div>\n              </div>\n            )}\n          </CardContent>\n        </Card>\n      )}\n      \n      {/* Responsive Layout */}\n      <div className=\"flex flex-col lg:flex-row gap-6\">\n        {/* Bundle Grid */}\n        <div className={`${selectedBundle ? 'hidden lg:block lg:w-1/2' : 'w-full'} transition-all`}>\n          <div className={`grid grid-cols-1 gap-4 ${\n            selectedBundle \n              ? 'md:grid-cols-2' \n              : 'sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4'\n          }`}>\n            {bundles && Array.isArray(bundles) ? bundles.map((bundle) => (\n              <BundleGridCard key={bundle.name} bundle={bundle} />\n            )) : <div>No bundles available</div>}\n          </div>\n        </div>\n\n        {/* Detail Panel */}\n        {selectedBundle && (\n          <div className={`${selectedBundle ? 'block' : 'hidden'} ${\n            selectedBundle ? 'fixed inset-0 z-50 bg-background lg:relative lg:inset-auto lg:z-auto lg:w-1/2' : ''\n          } transition-all flex flex-col`}>\n            {/* Mobile Close Button */}\n            <div className=\"lg:hidden sticky top-0 bg-background border-b p-4 flex justify-between items-center flex-shrink-0\">\n              <h3 className=\"font-semibold\">Bundle Details</h3>\n              <Button \n                variant=\"ghost\" \n                size=\"sm\" \n                onClick={() => setSelectedBundle(null)}\n              >\n                <X className=\"w-4 h-4\" />\n              </Button>\n            </div>\n            \n            <div className=\"flex-1 overflow-y-auto p-4 lg:p-0\">\n              {(() => {\n                const bundle = bundles?.find((b: Bundle) => b.name === selectedBundle)\n                if (!bundle) return <div>Bundle not found</div>\n\n                return (\n                  <BundleDetailView \n                    bundle={bundle}\n                    bundles={bundles}\n                    selectedBundleName={selectedBundle}\n                    editingBundles={editingBundles}\n                    availableFiles={availableFiles}\n                    loadingButtons={loadingButtons}\n                    successButtons={successButtons}\n                    errorButtons={errorButtons}\n                    toggleEditMode={toggleEditMode}\n                    removeFileFromBundle={removeFileFromBundle}\n                    addFileToBundle={addFileToBundle}\n                    getFileBundles={getFileBundles}\n                    getFileIcon={getFileIcon}\n                    availableFilesSearch={availableFilesSearch}\n                    setAvailableFilesSearch={setAvailableFilesSearch}\n                  />\n                )\n              })()}\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  )\n}\n\n// Bundle Detail View Component\nconst BundleDetailView = ({ \n  bundle, \n  bundles,\n  selectedBundleName,\n  editingBundles, \n  availableFiles, \n  loadingButtons, \n  successButtons, \n  errorButtons,\n  toggleEditMode,\n  removeFileFromBundle,\n  addFileToBundle,\n  getFileBundles,\n  getFileIcon,\n  availableFilesSearch,\n  setAvailableFilesSearch\n}: {\n  bundle: Bundle\n  bundles: Bundle[]\n  selectedBundleName: string\n  editingBundles: Set<string>\n  availableFiles: string[]\n  loadingButtons: Set<string>\n  successButtons: Set<string>\n  errorButtons: Set<string>\n  toggleEditMode: (bundleName: string) => void\n  removeFileFromBundle: (fileName: string, bundleName: string) => void\n  addFileToBundle: (fileName: string, bundleName: string) => void\n  getFileBundles: (filePath: string) => string[]\n  getFileIcon: (fileName: string) => React.ReactNode\n  availableFilesSearch: string\n  setAvailableFilesSearch: (value: string) => void\n}) => {\n  // Get the most current bundle from bundles array to ensure we have latest file updates\n  const currentBundle = bundles?.find((b: Bundle) => b.name === selectedBundleName) || bundle\n  \n  return (\n    <Card>\n      <CardHeader className=\"pb-3\">\n        <div className=\"flex flex-col gap-2\">\n          <div className=\"flex items-center gap-2 min-w-0\">\n            <h3 className=\"text-sm font-medium truncate\">{bundle.name}</h3>\n            <Badge variant={bundle.changed ? 'destructive' : 'secondary'} className=\"text-xs font-normal\">\n              {bundle.changed ? 'CHANGED' : 'SYNCED'}\n            </Badge>\n          </div>\n          <div className=\"flex gap-1\">\n            <Button\n              variant=\"outline\"\n              size=\"sm\"\n              onClick={() => toggleEditMode(bundle.name)}\n              disabled={bundle.name === 'master'}\n              className={`h-7 text-xs ${editingBundles.has(bundle.name) ? 'bg-primary/10 border-primary/20' : ''}`}\n            >\n              {editingBundles.has(bundle.name) ? (\n                <X className=\"w-3 h-3\" />\n              ) : (\n                <Edit3 className=\"w-3 h-3\" />\n              )}\n            </Button>\n          </div>\n        </div>\n      </CardHeader>\n      <CardContent className=\"pt-0\">\n        <div className=\"text-xs text-muted-foreground mb-3\">\n          <div className=\"flex flex-wrap gap-x-2 gap-y-1 items-center\">\n            <span>{bundle.fileCount} files</span>\n            <span>•</span>\n            <span>{(bundle.size / 1024).toFixed(1)}kb</span>\n            {bundle.lastGenerated && (\n              <>\n                <span>•</span>\n                <span className=\"truncate max-w-[200px]\">\n                  Generated {new Date(bundle.lastGenerated).toLocaleTimeString()}\n                </span>\n              </>\n            )}\n          </div>\n        </div>\n\n        <div className=\"space-y-3\">\n          {/* Bundle Files */}\n          <div className=\"space-y-2\">\n            <div className=\"flex items-center gap-2 flex-wrap\">\n              <Badge variant=\"outline\" className=\"text-xs font-normal h-5\">\n                Files\n              </Badge>\n              <span className=\"text-xs text-muted-foreground\">\n                ({currentBundle.files.length} files)\n              </span>\n            </div>\n            <div className=\"space-y-1 max-h-64 overflow-y-auto\">\n              {editingBundles.has(bundle.name) ? (\n                // Edit mode: show files with remove buttons\n                currentBundle.files.map((file) => {\n                  const removeKey = `remove-${bundle.name}-${file}`\n                  const isLoading = loadingButtons.has(removeKey)\n                  const fileBundles = getFileBundles(file).filter(b => b !== bundle.name)\n                  const fileName = file.split('/').pop() || file\n                  return (\n                    <div key={file} className=\"flex items-center gap-2 py-0.5 px-1 hover:bg-muted/50 rounded-sm group\">\n                      <Button\n                        variant=\"ghost\"\n                        size=\"sm\"\n                        onClick={() => removeFileFromBundle(file, bundle.name)}\n                        disabled={isLoading || bundle.name === 'master'}\n                        className=\"h-4 w-4 p-0 opacity-0 group-hover:opacity-100 hover:bg-destructive/10 flex-shrink-0\"\n                      >\n                        {isLoading ? (\n                          <Loader2 className=\"w-2.5 h-2.5 animate-spin\" />\n                        ) : (\n                          <Minus className=\"w-2.5 h-2.5 text-destructive\" />\n                        )}\n                      </Button>\n                      <div className=\"flex items-center gap-1.5 flex-1 min-w-0\">\n                        <div className=\"flex-shrink-0\">{getFileIcon(file)}</div>\n                        <span className=\"text-xs text-foreground truncate font-normal\">{fileName}</span>\n                        {fileBundles.length > 0 && (\n                          <div className=\"flex gap-1 flex-wrap ml-auto\">\n                            {fileBundles.map(bundleName => (\n                              <Badge key={bundleName} variant=\"outline\" className=\"text-xs font-normal h-4 px-1.5\">\n                                {bundleName}\n                              </Badge>\n                            ))}\n                          </div>\n                        )}\n                      </div>\n                    </div>\n                  )\n                })\n              ) : (\n                // View mode: show files with bundle labels\n                currentBundle.files.map((file) => {\n                  const fileBundles = getFileBundles(file).filter(b => b !== bundle.name)\n                  const fileName = file.split('/').pop() || file\n                  return (\n                    <div key={file} className=\"flex items-center gap-1.5 py-0.5 px-1 hover:bg-muted/30 rounded-sm\">\n                      <div className=\"flex-shrink-0\">{getFileIcon(file)}</div>\n                      <span className=\"text-xs text-foreground truncate flex-1 font-normal\">{fileName}</span>\n                      {fileBundles.length > 0 && (\n                        <div className=\"flex gap-1 flex-wrap\">\n                          {fileBundles.map(bundleName => (\n                            <Badge key={bundleName} variant=\"outline\" className=\"text-xs font-normal h-4 px-1.5\">\n                              {bundleName}\n                            </Badge>\n                          ))}\n                        </div>\n                      )}\n                    </div>\n                  )\n                })\n              )}\n            </div>\n          </div>\n\n          {/* Available Files Section (Edit Mode Only) */}\n          {editingBundles.has(bundle.name) && (\n            <div className=\"space-y-2 mt-4 pt-3 border-t\">\n              <div className=\"flex items-center gap-2 flex-wrap\">\n                <Badge variant=\"outline\" className=\"bg-muted text-muted-foreground border-border text-xs font-normal h-5\">\n                  <Plus className=\"w-2.5 h-2.5 mr-1\" />\n                  Available Files\n                </Badge>\n                <span className=\"text-xs text-muted-foreground\">\n                  (Click + to add to bundle)\n                </span>\n              </div>\n              <div className=\"mb-2\">\n                <div className=\"relative\">\n                  <Search className=\"absolute left-2 top-1/2 transform -translate-y-1/2 text-muted-foreground w-3 h-3\" />\n                  <input\n                    type=\"text\"\n                    placeholder=\"Search files...\"\n                    value={availableFilesSearch}\n                    onChange={(e) => setAvailableFilesSearch(e.target.value)}\n                    className=\"w-full pl-7 pr-3 py-1 text-xs border border-input rounded-md bg-background text-foreground placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring\"\n                  />\n                </div>\n              </div>\n              <div className=\"space-y-1 max-h-40 overflow-y-auto\">\n                {availableFiles\n                  .filter(file => !currentBundle.files.includes(file))\n                  .filter(file => availableFilesSearch === '' || file.toLowerCase().includes(availableFilesSearch.toLowerCase()))\n                  .map((file) => {\n                    const addKey = `add-${currentBundle.name}-${file}`\n                    const isLoading = loadingButtons.has(addKey)\n                    const fileBundles = getFileBundles(file)\n                    const fileName = file.split('/').pop() || file\n                    return (\n                      <div key={file} className=\"flex items-center gap-2 py-0.5 px-1 hover:bg-muted/50 rounded-sm group\">\n                        <Button\n                          variant=\"ghost\"\n                          size=\"sm\"\n                          onClick={() => addFileToBundle(file, currentBundle.name)}\n                          disabled={isLoading}\n                          className=\"h-4 w-4 p-0 opacity-0 group-hover:opacity-100 hover:bg-primary/10 flex-shrink-0\"\n                        >\n                          {isLoading ? (\n                            <Loader2 className=\"w-2.5 h-2.5 animate-spin\" />\n                          ) : (\n                            <Plus className=\"w-2.5 h-2.5 text-primary\" />\n                          )}\n                        </Button>\n                        <div className=\"flex items-center gap-1.5 flex-1 min-w-0\">\n                          <div className=\"flex-shrink-0\">{getFileIcon(file)}</div>\n                          <span className=\"text-xs text-muted-foreground truncate font-normal\">{fileName}</span>\n                          {fileBundles.length > 0 && (\n                            <div className=\"flex gap-1 flex-wrap ml-auto\">\n                              {fileBundles.map(bundleName => (\n                                <Badge key={bundleName} variant=\"outline\" className=\"text-xs font-normal h-4 px-1.5\">\n                                  {bundleName}\n                                </Badge>\n                              ))}\n                            </div>\n                          )}\n                        </div>\n                      </div>\n                    )\n                  })\n                }\n              </div>\n            </div>\n          )}\n\n        </div>\n      </CardContent>\n    </Card>\n  )\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/CursorRulesManager.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"15371\" modified=\"2025-06-25T06:32:26.052Z\" lines=\"415\" />\n        <cntx:content><![CDATA[// Updated CursorRulesManager.tsx\nimport { useState, useEffect } from 'react'\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'\nimport { Card, CardHeader, CardTitle, CardContent } from './ui/card'\nimport { Button } from './ui/button'\nimport { Textarea } from './ui/textarea'\nimport { Alert, AlertDescription } from './ui/alert'\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from './ui/tabs'\nimport { Save, RefreshCw, Copy, Download, Upload, Sparkles, FileText, Info } from 'lucide-react'\nimport { useButtonFeedback } from '../hooks/useButtonFeedback'\nimport { getButtonIcon, getButtonClassName } from '../utils/buttonHelpers'\nimport { toast } from '@/lib/toast'\n\ninterface CursorRulesTemplates {\n  react: string\n  node: string\n  general: string\n}\n\nconst fetchCursorRules = async (): Promise<string> => {\n  const response = await fetch('http://localhost:3333/api/cursor-rules')\n  if (!response.ok) throw new Error('Failed to fetch cursor rules')\n  return response.text()\n}\n\nconst saveCursorRules = async (content: string): Promise<void> => {\n  const response = await fetch('http://localhost:3333/api/cursor-rules', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ content })\n  })\n  if (!response.ok) throw new Error('Failed to save cursor rules')\n}\n\nconst fetchTemplates = async (): Promise<CursorRulesTemplates> => {\n  const response = await fetch('http://localhost:3333/api/cursor-rules/templates')\n  if (!response.ok) throw new Error('Failed to fetch templates')\n  return response.json()\n}\n\nexport function CursorRulesManager() {\n  const queryClient = useQueryClient()\n  const [editingRules, setEditingRules] = useState<string>('')\n  const [selectedTemplate, setSelectedTemplate] = useState<string>('')\n\n  const { setButtonState, getButtonState, isLoading } = useButtonFeedback()\n\n  const { data: currentRules, isLoading: rulesLoading } = useQuery({\n    queryKey: ['cursor-rules'],\n    queryFn: fetchCursorRules\n  })\n\n  const { data: templates } = useQuery({\n    queryKey: ['cursor-templates'],\n    queryFn: fetchTemplates\n  })\n\n  const saveMutation = useMutation({\n    mutationFn: saveCursorRules,\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['cursor-rules'] })\n      setButtonState('save', 'success')\n      toast.success('Cursor rules saved successfully!')\n    },\n    onError: (error) => {\n      setButtonState('save', 'error')\n      toast.error(`Failed to save cursor rules: ${error.message}`)\n    }\n  })\n\n  useEffect(() => {\n    if (currentRules && !editingRules) {\n      setEditingRules(currentRules)\n    }\n  }, [currentRules])\n\n  const handleSave = () => {\n    if (editingRules) {\n      setButtonState('save', 'loading')\n      saveMutation.mutate(editingRules)\n    }\n  }\n\n  const handleReset = () => {\n    setEditingRules(currentRules || '')\n    toast.info('Reset to last saved version')\n  }\n\n  const handleLoadTemplate = (templateType: keyof CursorRulesTemplates) => {\n    if (templates && templates[templateType]) {\n      setEditingRules(templates[templateType])\n      setSelectedTemplate(templateType)\n      toast.success(`Loaded ${templateType} template`)\n    }\n  }\n\n  const copyToClipboard = async () => {\n    if (!editingRules) return\n\n    setButtonState('copy', 'loading')\n    try {\n      await navigator.clipboard.writeText(editingRules)\n      setButtonState('copy', 'success')\n      toast.success('Cursor rules copied to clipboard!')\n    } catch (error) {\n      setButtonState('copy', 'error')\n      toast.error('Failed to copy to clipboard')\n    }\n  }\n\n  const downloadRules = () => {\n    setButtonState('download', 'loading')\n    try {\n      const blob = new Blob([editingRules], { type: 'text/plain' })\n      const url = URL.createObjectURL(blob)\n      const a = document.createElement('a')\n      a.href = url\n      a.download = '.cursorrules'\n      a.click()\n      URL.revokeObjectURL(url)\n      setButtonState('download', 'success')\n      toast.success('Cursor rules downloaded!')\n    } catch (error) {\n      setButtonState('download', 'error')\n      toast.error('Failed to download file')\n    }\n  }\n\n  const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {\n    const file = event.target.files?.[0]\n    if (!file) return\n\n    setButtonState('upload', 'loading')\n    const reader = new FileReader()\n    reader.onload = (e) => {\n      const content = e.target?.result as string\n      setEditingRules(content)\n      setButtonState('upload', 'success')\n      toast.success('Cursor rules uploaded successfully!')\n    }\n    reader.onerror = () => {\n      setButtonState('upload', 'error')\n      toast.error('Failed to read file')\n    }\n    reader.readAsText(file)\n  }\n\n  if (rulesLoading) return <div>Loading cursor rules...</div>\n\n  const hasChanges = currentRules !== editingRules\n  const wordCount = editingRules.split(/\\s+/).filter(word => word.length > 0).length\n  const lineCount = editingRules.split('\\n').length\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Header */}\n      <div className=\"flex justify-between items-start\">\n        <div>\n          <h2 className=\"text-lg font-semibold flex items-center gap-2\">\n            <Sparkles className=\"w-5 h-5\" />\n            Cursor Rules Management\n          </h2>\n          <p className=\"text-sm text-muted-foreground\">\n            Configure AI assistant behavior and project context for Cursor IDE\n          </p>\n        </div>\n        <div className=\"flex gap-2\">\n          <Button\n            variant=\"outline\"\n            onClick={handleReset}\n            disabled={!hasChanges}\n          >\n            <RefreshCw className=\"w-4 h-4 mr-1\" />\n            Reset\n          </Button>\n          <Button\n            onClick={handleSave}\n            disabled={!hasChanges || isLoading('save')}\n            className={`bg-[color:var(--color-type-hooks)] hover:bg-[color:var(--color-type-hooks)]/80 ${getButtonClassName(getButtonState('save'))}`}\n          >\n            {getButtonIcon(getButtonState('save'), <Save className=\"w-4 h-4\" />)}\n            <span className=\"ml-1\">Save Rules</span>\n          </Button>\n        </div>\n      </div>\n\n      {/* Status Info */}\n      <Card>\n        <CardContent className=\"pt-6\">\n          <div className=\"flex items-center justify-between\">\n            <div className=\"flex items-center gap-4\">\n              <div className=\"flex items-center gap-2\">\n                <FileText className=\"w-4 h-4 text-muted-foreground\" />\n                <span className=\"text-sm text-muted-foreground\">\n                  {lineCount} lines • {wordCount} words\n                </span>\n              </div>\n              {currentRules && (\n                <div className=\"flex items-center gap-2\">\n                  <span className=\"text-sm text-[color:var(--color-success)]\">.cursorrules file exists</span>\n                </div>\n              )}\n            </div>\n            <div className=\"flex gap-2\">\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={copyToClipboard}\n                disabled={isLoading('copy')}\n                className={getButtonClassName(getButtonState('copy'))}\n              >\n                {getButtonIcon(getButtonState('copy'), <Copy className=\"w-4 h-4\" />)}\n                <span className=\"ml-1\">Copy</span>\n              </Button>\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={downloadRules}\n                disabled={isLoading('download')}\n                className={getButtonClassName(getButtonState('download'))}\n              >\n                {getButtonIcon(getButtonState('download'), <Download className=\"w-4 h-4\" />)}\n                <span className=\"ml-1\">Download</span>\n              </Button>\n              <label className=\"cursor-pointer\">\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  asChild\n                  className={getButtonClassName(getButtonState('upload'))}\n                >\n                  <span>\n                    {getButtonIcon(getButtonState('upload'), <Upload className=\"w-4 h-4\" />)}\n                    <span className=\"ml-1\">Upload</span>\n                  </span>\n                </Button>\n                <input\n                  type=\"file\"\n                  accept=\".cursorrules,.txt,.md\"\n                  onChange={handleFileUpload}\n                  className=\"hidden\"\n                />\n              </label>\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n\n      <Tabs defaultValue=\"editor\" className=\"space-y-6\">\n        <TabsList>\n          <TabsTrigger value=\"editor\">Rules Editor</TabsTrigger>\n          <TabsTrigger value=\"templates\">Templates</TabsTrigger>\n          <TabsTrigger value=\"help\">Help & Examples</TabsTrigger>\n        </TabsList>\n\n        <TabsContent value=\"editor\">\n          <Card>\n            <CardHeader>\n              <CardTitle>Edit Cursor Rules</CardTitle>\n            </CardHeader>\n            <CardContent className=\"space-y-4\">\n              {hasChanges && (\n                <Alert className=\"border-[color:var(--color-warning)]/20 bg-[color:var(--color-warning)]/5\">\n                  <Info className=\"w-4 h-4\" />\n                  <AlertDescription>\n                    You have unsaved changes. Click \"Save Rules\" to apply them to your .cursorrules file.\n                  </AlertDescription>\n                </Alert>\n              )}\n\n              <Textarea\n                value={editingRules}\n                onChange={(e) => setEditingRules(e.target.value)}\n                placeholder=\"Enter your cursor rules here...\"\n                className=\"min-h-96 font-mono text-sm\"\n              />\n\n              {selectedTemplate && (\n                <div className=\"flex items-center gap-2\">\n                  <span className=\"text-sm text-muted-foreground\">\n                    Template: {selectedTemplate}\n                  </span>\n                  <Button\n                    variant=\"ghost\"\n                    size=\"sm\"\n                    onClick={() => setSelectedTemplate('')}\n                  >\n                    Clear\n                  </Button>\n                </div>\n              )}\n            </CardContent>\n          </Card>\n        </TabsContent>\n\n        <TabsContent value=\"templates\">\n          <div className=\"space-y-4\">\n            <Card>\n              <CardHeader>\n                <CardTitle>Project Templates</CardTitle>\n              </CardHeader>\n              <CardContent>\n                <p className=\"text-sm text-muted-foreground mb-4\">\n                  Choose a template that matches your project type. You can customize it after loading.\n                </p>\n                <div className=\"grid gap-3\">\n                  <Button\n                    variant=\"outline\"\n                    onClick={() => handleLoadTemplate('react')}\n                    className=\"justify-start h-auto p-4\"\n                  >\n                    <div className=\"text-left\">\n                      <div className=\"font-medium\">React Application</div>\n                      <div className=\"text-sm text-muted-foreground\">\n                        Modern React with TypeScript, hooks, and Tailwind CSS\n                      </div>\n                    </div>\n                  </Button>\n\n                  <Button\n                    variant=\"outline\"\n                    onClick={() => handleLoadTemplate('node')}\n                    className=\"justify-start h-auto p-4\"\n                  >\n                    <div className=\"text-left\">\n                      <div className=\"font-medium\">Node.js Backend</div>\n                      <div className=\"text-sm text-muted-foreground\">\n                        Express/Fastify backend with ES modules and TypeScript\n                      </div>\n                    </div>\n                  </Button>\n\n                  <Button\n                    variant=\"outline\"\n                    onClick={() => handleLoadTemplate('general')}\n                    className=\"justify-start h-auto p-4\"\n                  >\n                    <div className=\"text-left\">\n                      <div className=\"font-medium\">General Project</div>\n                      <div className=\"text-sm text-muted-foreground\">\n                        Basic template for any type of project\n                      </div>\n                    </div>\n                  </Button>\n                </div>\n              </CardContent>\n            </Card>\n          </div>\n        </TabsContent>\n\n        <TabsContent value=\"help\">\n          <div className=\"space-y-4\">\n            <Card>\n              <CardHeader>\n                <CardTitle>What are Cursor Rules?</CardTitle>\n              </CardHeader>\n              <CardContent className=\"space-y-4\">\n                <p className=\"text-sm text-muted-foreground\">\n                  Cursor rules (.cursorrules) provide context and guidelines to AI assistants like Cursor IDE's AI.\n                  They help the AI understand your project structure, coding preferences, and best practices.\n                </p>\n\n                <div className=\"space-y-3\">\n                  <div>\n                    <h4 className=\"font-medium mb-2\">Best Practices</h4>\n                    <ul className=\"text-sm text-muted-foreground space-y-1 list-disc list-inside\">\n                      <li>Include project context and technology stack</li>\n                      <li>Specify coding standards and naming conventions</li>\n                      <li>Document file organization patterns</li>\n                      <li>Mention important dependencies and frameworks</li>\n                      <li>Include team preferences and architectural decisions</li>\n                    </ul>\n                  </div>\n\n                  <div>\n                    <h4 className=\"font-medium mb-2\">Example Sections</h4>\n                    <div className=\"bg-muted/50 p-3 rounded text-xs font-mono\">\n                      # Project Context<br />\n                      # Development Guidelines<br />\n                      # Code Style<br />\n                      # File Organization<br />\n                      # Bundle Context<br />\n                      # AI Assistant Instructions\n                    </div>\n                  </div>\n                </div>\n              </CardContent>\n            </Card>\n\n            <Card>\n              <CardHeader>\n                <CardTitle>Integration with cntx-ui</CardTitle>\n              </CardHeader>\n              <CardContent>\n                <p className=\"text-sm text-muted-foreground mb-3\">\n                  Your cursor rules automatically include information about your cntx-ui bundle configuration,\n                  helping AI assistants understand your project structure and file organization.\n                </p>\n\n                <Alert>\n                  <Sparkles className=\"w-4 h-4\" />\n                  <AlertDescription>\n                    When you change your bundle configuration, consider updating your cursor rules\n                    to reflect the new project structure and help AI assistants provide better suggestions.\n                  </AlertDescription>\n                </Alert>\n              </CardContent>\n            </Card>\n          </div>\n        </TabsContent>\n      </Tabs>\n    </div>\n  )\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/EnhancedBundleConfig.tsx\" ext=\".tsx\" role=\"configuration\">\n        <cntx:meta size=\"18186\" modified=\"2025-06-26T00:21:56.905Z\" lines=\"487\" />\n        <cntx:content><![CDATA[import { useState } from 'react'\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'\nimport { Card, CardHeader, CardTitle, CardContent } from './ui/card'\nimport { Button } from './ui/button'\nimport { Input } from './ui/input'\nimport { Badge } from './ui/badge'\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from './ui/tabs'\nimport { Plus, Trash2, Eye, CheckCircle2, Circle } from 'lucide-react'\nimport { toast } from '@/lib/toast'\n\ninterface BundleConfig {\n  bundles: Record<string, string[]>\n}\n\ninterface ProjectFile {\n  path: string\n  type: string\n  size: number\n}\n\nconst fetchConfig = async (): Promise<BundleConfig> => {\n  const response = await fetch('http://localhost:3333/api/config')\n  if (!response.ok) throw new Error('Failed to fetch config')\n  return response.json()\n}\n\nconst saveConfig = async (config: BundleConfig): Promise<void> => {\n  const response = await fetch('http://localhost:3333/api/config', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(config)\n  })\n  if (!response.ok) throw new Error('Failed to save config')\n}\n\nconst fetchProjectFiles = async (): Promise<ProjectFile[]> => {\n  const response = await fetch('http://localhost:3333/api/files')\n  if (!response.ok) throw new Error('Failed to fetch files')\n  return response.json()\n}\n\nconst testPattern = async (pattern: string): Promise<string[]> => {\n  const response = await fetch('http://localhost:3333/api/test-pattern', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ pattern })\n  })\n  if (!response.ok) throw new Error('Failed to test pattern')\n  return response.json()\n}\n\nexport function EnhancedBundleConfig() {\n  const queryClient = useQueryClient()\n  const [editingBundle, setEditingBundle] = useState<string | null>(null)\n  const [showCreateBundle, setShowCreateBundle] = useState(false)\n  const [createBundleStep, setCreateBundleStep] = useState<'name' | 'files' | 'patterns'>('name')\n  \n  // Bundle creation state\n  const [newBundleName, setNewBundleName] = useState('')\n  const [selectedFiles, setSelectedFiles] = useState<Set<string>>(new Set())\n  const [generatedPatterns, setGeneratedPatterns] = useState<string[]>([])\n  const [lastSelectedIndex, setLastSelectedIndex] = useState<number>(-1)\n  \n  // Pattern testing\n  const [testingPattern, setTestingPattern] = useState('')\n  const [testResults, setTestResults] = useState<string[]>([])\n\n  const { data: config, isLoading: configLoading } = useQuery({\n    queryKey: ['config'],\n    queryFn: fetchConfig\n  })\n\n  const { data: projectFiles, isLoading: filesLoading } = useQuery({\n    queryKey: ['project-files'],\n    queryFn: fetchProjectFiles\n  })\n\n  const saveMutation = useMutation({\n    mutationFn: saveConfig,\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['config'] })\n      queryClient.invalidateQueries({ queryKey: ['bundles'] })\n      setEditingBundle(null)\n      setShowCreateBundle(false)\n      setNewBundleName('')\n      setSelectedFiles(new Set())\n      setGeneratedPatterns([])\n      setCreateBundleStep('name')\n      toast.success('Bundle configuration saved!')\n    },\n    onError: (error) => {\n      toast.error(`Failed to save: ${error.message}`)\n    }\n  })\n\n  // Generate patterns from selected files\n  const generatePatternsFromFiles = (files: string[]) => {\n    const patterns: string[] = []\n    const directories = new Set<string>()\n    \n    files.forEach(file => {\n      const dir = file.split('/').slice(0, -1).join('/')\n      if (dir) directories.add(dir)\n    })\n    \n    // Create patterns for common directory structures\n    directories.forEach(dir => {\n      const filesInDir = files.filter(f => f.startsWith(dir + '/'))\n      if (filesInDir.length > 1) {\n        patterns.push(`${dir}/**/*`)\n      }\n    })\n    \n    // Add individual files that don't fit patterns\n    files.forEach(file => {\n      const matchedByPattern = patterns.some(pattern => {\n        const regex = new RegExp(pattern.replace(/\\*\\*/g, '.*').replace(/\\*/g, '[^/]*'))\n        return regex.test(file)\n      })\n      if (!matchedByPattern) {\n        patterns.push(file)\n      }\n    })\n    \n    return patterns.length > 0 ? patterns : files\n  }\n\n  const handleCreateBundle = () => {\n    if (!config || !newBundleName.trim()) return\n    \n    const patterns = generatedPatterns.length > 0 ? generatedPatterns : Array.from(selectedFiles)\n    \n    const updatedConfig = {\n      ...config,\n      bundles: {\n        ...config.bundles,\n        [newBundleName]: patterns\n      }\n    }\n    \n    saveMutation.mutate(updatedConfig)\n  }\n\n  const handleDeleteBundle = (bundleName: string) => {\n    if (!config) return\n    \n    const { [bundleName]: deleted, ...remainingBundles } = config.bundles\n    const updatedConfig = {\n      ...config,\n      bundles: remainingBundles\n    }\n    \n    saveMutation.mutate(updatedConfig)\n  }\n\n  const handlePatternChange = (bundleName: string, patterns: string[]) => {\n    if (!config) return\n    \n    const updatedConfig = {\n      ...config,\n      bundles: {\n        ...config.bundles,\n        [bundleName]: patterns\n      }\n    }\n    \n    saveMutation.mutate(updatedConfig)\n  }\n\n  const handleTestPattern = async () => {\n    if (!testingPattern.trim()) return\n    \n    try {\n      const results = await testPattern(testingPattern)\n      setTestResults(results)\n    } catch (error) {\n      toast.error('Failed to test pattern')\n    }\n  }\n\n  const handleFileSelection = (filePath: string, index: number, event?: React.MouseEvent) => {\n    const newSelected = new Set(selectedFiles)\n    \n    // Handle shift+click for range selection\n    if (event?.shiftKey && lastSelectedIndex >= 0 && projectFiles) {\n      const startIndex = Math.min(lastSelectedIndex, index)\n      const endIndex = Math.max(lastSelectedIndex, index)\n      \n      for (let i = startIndex; i <= endIndex; i++) {\n        if (projectFiles[i]) {\n          newSelected.add(projectFiles[i].path)\n        }\n      }\n    } else {\n      // Normal click - toggle selection\n      if (newSelected.has(filePath)) {\n        newSelected.delete(filePath)\n      } else {\n        newSelected.add(filePath)\n      }\n    }\n    \n    setSelectedFiles(newSelected)\n    setLastSelectedIndex(index)\n    \n    // Auto-generate patterns when files are selected\n    if (newSelected.size > 0) {\n      const patterns = generatePatternsFromFiles(Array.from(newSelected))\n      setGeneratedPatterns(patterns)\n    } else {\n      setGeneratedPatterns([])\n    }\n  }\n\n  if (configLoading || filesLoading) {\n    return <div className=\"p-4\">Loading...</div>\n  }\n\n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle className=\"flex items-center justify-between text-sm font-medium\">\n          Bundle Configuration\n          <Button\n            onClick={() => setShowCreateBundle(true)}\n            size=\"sm\"\n            className=\"h-7 text-xs\"\n          >\n            <Plus className=\"w-3 h-3 mr-1\" />\n            Create Bundle\n          </Button>\n        </CardTitle>\n      </CardHeader>\n      <CardContent className=\"space-y-6\">\n        {/* Create Bundle Modal */}\n        {showCreateBundle && (\n          <Card className=\"border-2 border-[color:var(--color-info)]/20 bg-[color:var(--color-info)]/5\">\n            <CardHeader>\n              <CardTitle className=\"text-sm font-medium\">Create New Bundle</CardTitle>\n            </CardHeader>\n            <CardContent>\n              <Tabs value={createBundleStep} onValueChange={(value) => setCreateBundleStep(value as any)}>\n                <TabsList className=\"grid w-full grid-cols-3\">\n                  <TabsTrigger value=\"name\">1. Name</TabsTrigger>\n                  <TabsTrigger value=\"files\" disabled={!newBundleName.trim()}>2. Select Files</TabsTrigger>\n                  <TabsTrigger value=\"patterns\" disabled={selectedFiles.size === 0}>3. Review</TabsTrigger>\n                </TabsList>\n\n                <TabsContent value=\"name\" className=\"space-y-4\">\n                  <div>\n                    <label className=\"text-xs font-medium\">Bundle Name</label>\n                    <Input\n                      placeholder=\"e.g., frontend, api, components\"\n                      value={newBundleName}\n                      onChange={(e) => setNewBundleName(e.target.value)}\n                    />\n                  </div>\n                  <Button \n                    onClick={() => setCreateBundleStep('files')}\n                    disabled={!newBundleName.trim()}\n                    size=\"sm\"\n                    className=\"h-7 text-xs\"\n                  >\n                    Next: Select Files\n                  </Button>\n                </TabsContent>\n\n                <TabsContent value=\"files\" className=\"space-y-4\">\n                  <div>\n                    <div className=\"flex items-center justify-between mb-3\">\n                      <label className=\"text-xs font-medium\">Select Files for \"{newBundleName}\"</label>\n                      <Badge variant=\"outline\">{selectedFiles.size} selected</Badge>\n                    </div>\n                    \n                    <div className=\"text-xs text-muted-foreground mb-2\">\n                      Click to select files. Hold Shift and click to select ranges.\n                    </div>\n                    \n                    <div className=\"max-h-64 overflow-y-auto border rounded-lg p-3 space-y-1\">\n                      {projectFiles?.map((file, index) => (\n                        <div\n                          key={file.path}\n                          className=\"flex items-center gap-2 p-2 hover:bg-muted/50 rounded cursor-pointer select-none\"\n                          onClick={(e) => handleFileSelection(file.path, index, e)}\n                        >\n                          {selectedFiles.has(file.path) ? (\n                            <CheckCircle2 className=\"w-4 h-4 text-[color:var(--color-info)]\" />\n                          ) : (\n                            <Circle className=\"w-4 h-4 text-muted-foreground\" />\n                          )}\n                          <span className=\"text-xs font-mono flex-1\">{file.path}</span>\n                          <Badge variant=\"outline\" className=\"text-xs\">{file.type}</Badge>\n                        </div>\n                      ))}\n                    </div>\n                  </div>\n                  \n                  <div className=\"flex gap-2\">\n                    <Button variant=\"outline\" size=\"sm\" className=\"h-7 text-xs\" onClick={() => setCreateBundleStep('name')}>\n                      Back\n                    </Button>\n                    <Button \n                      onClick={() => setCreateBundleStep('patterns')}\n                      disabled={selectedFiles.size === 0}\n                      size=\"sm\"\n                      className=\"h-7 text-xs\"\n                    >\n                      Next: Review Patterns\n                    </Button>\n                  </div>\n                </TabsContent>\n\n                <TabsContent value=\"patterns\" className=\"space-y-4\">\n                  <div>\n                    <label className=\"text-xs font-medium\">Generated Patterns</label>\n                    <div className=\"space-y-2 mt-2\">\n                      {generatedPatterns.map((pattern, index) => (\n                        <div key={index} className=\"flex gap-2\">\n                          <Input\n                            value={pattern}\n                            onChange={(e) => {\n                              const newPatterns = [...generatedPatterns]\n                              newPatterns[index] = e.target.value\n                              setGeneratedPatterns(newPatterns)\n                            }}\n                            className=\"font-mono text-sm\"\n                          />\n                          <Button\n                            variant=\"outline\"\n                            size=\"sm\"\n                            onClick={() => {\n                              const newPatterns = generatedPatterns.filter((_, i) => i !== index)\n                              setGeneratedPatterns(newPatterns)\n                            }}\n                          >\n                            <Trash2 className=\"w-4 h-4\" />\n                          </Button>\n                        </div>\n                      ))}\n                      <Button\n                        variant=\"outline\"\n                        size=\"sm\"\n                        onClick={() => setGeneratedPatterns([...generatedPatterns, '**/*'])}\n                      >\n                        <Plus className=\"w-4 h-4 mr-1\" />\n                        Add Pattern\n                      </Button>\n                    </div>\n                  </div>\n\n                  <div className=\"flex gap-2\">\n                    <Button variant=\"outline\" size=\"sm\" className=\"h-7 text-xs\" onClick={() => setCreateBundleStep('files')}>\n                      Back\n                    </Button>\n                    <Button variant=\"outline\" size=\"sm\" className=\"h-7 text-xs\" onClick={() => setShowCreateBundle(false)}>\n                      Cancel\n                    </Button>\n                    <Button onClick={handleCreateBundle} disabled={saveMutation.isPending} size=\"sm\" className=\"h-7 text-xs\">\n                      Create Bundle\n                    </Button>\n                  </div>\n                </TabsContent>\n              </Tabs>\n            </CardContent>\n          </Card>\n        )}\n\n        {/* Existing Bundles */}\n        <div className=\"space-y-4\">\n          {config && Object.entries(config.bundles).map(([bundleName, patterns]) => (\n            <div key={bundleName} className=\"border rounded-lg p-4\">\n              <div className=\"flex items-center justify-between mb-3\">\n                <h3 className=\"text-sm font-medium\">{bundleName}</h3>\n                <div className=\"flex gap-2\">\n                  <Button\n                    variant=\"outline\"\n                    size=\"sm\"\n                    className=\"h-7 text-xs\"\n                    onClick={() => setEditingBundle(editingBundle === bundleName ? null : bundleName)}\n                  >\n                    {editingBundle === bundleName ? 'Done' : 'Edit'}\n                  </Button>\n                  {bundleName !== 'master' && (\n                    <Button\n                      variant=\"outline\"\n                      size=\"sm\"\n                      className=\"h-7 text-xs\"\n                      onClick={() => handleDeleteBundle(bundleName)}\n                    >\n                      <Trash2 className=\"w-3 h-3\" />\n                    </Button>\n                  )}\n                </div>\n              </div>\n              \n              {editingBundle === bundleName ? (\n                <div className=\"space-y-2\">\n                  {patterns.map((pattern, index) => (\n                    <div key={index} className=\"flex gap-2\">\n                      <Input\n                        value={pattern}\n                        onChange={(e) => {\n                          const newPatterns = [...patterns]\n                          newPatterns[index] = e.target.value\n                          handlePatternChange(bundleName, newPatterns)\n                        }}\n                        placeholder=\"e.g., src/**/*.ts\"\n                        className=\"font-mono text-sm\"\n                      />\n                      {patterns.length > 1 && (\n                        <Button\n                          variant=\"outline\"\n                          size=\"sm\"\n                          onClick={() => {\n                            const newPatterns = patterns.filter((_, i) => i !== index)\n                            handlePatternChange(bundleName, newPatterns)\n                          }}\n                        >\n                          <Trash2 className=\"w-4 h-4\" />\n                        </Button>\n                      )}\n                    </div>\n                  ))}\n                  <Button\n                    variant=\"outline\"\n                    size=\"sm\"\n                    onClick={() => handlePatternChange(bundleName, [...patterns, '**/*'])}\n                  >\n                    <Plus className=\"w-4 h-4 mr-1\" />\n                    Add Pattern\n                  </Button>\n                </div>\n              ) : (\n                <div className=\"flex flex-wrap gap-1\">\n                  {patterns.map((pattern, index) => (\n                    <Badge key={index} variant=\"secondary\" className=\"font-mono text-xs\">\n                      {pattern}\n                    </Badge>\n                  ))}\n                </div>\n              )}\n            </div>\n          ))}\n        </div>\n\n        {/* Pattern Tester */}\n        <Card>\n          <CardHeader>\n            <CardTitle className=\"text-sm font-medium\">Test a Pattern</CardTitle>\n          </CardHeader>\n          <CardContent className=\"space-y-3\">\n            <div className=\"flex gap-2\">\n              <Input\n                placeholder=\"e.g., src/**/*.ts\"\n                value={testingPattern}\n                onChange={(e) => setTestingPattern(e.target.value)}\n                className=\"font-mono\"\n              />\n              <Button onClick={handleTestPattern} size=\"sm\" className=\"h-7 text-xs\">\n                <Eye className=\"w-3 h-3 mr-1\" />\n                Test\n              </Button>\n            </div>\n            \n            {testResults.length > 0 && (\n              <div className=\"mt-3\">\n                <p className=\"text-sm text-muted-foreground mb-2\">\n                  Found {testResults.length} files:\n                </p>\n                <div className=\"max-h-32 overflow-y-auto text-xs space-y-1 bg-muted/50 p-2 rounded font-mono\">\n                  {testResults.slice(0, 20).map((file, index) => (\n                    <div key={index}>{file}</div>\n                  ))}\n                  {testResults.length > 20 && (\n                    <div className=\"text-muted-foreground\">\n                      ... and {testResults.length - 20} more files\n                    </div>\n                  )}\n                </div>\n              </div>\n            )}\n          </CardContent>\n        </Card>\n      </CardContent>\n    </Card>\n  )\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/FileTree.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"8780\" modified=\"2025-06-26T00:21:27.205Z\" lines=\"309\" />\n        <cntx:content><![CDATA[import { useQuery } from '@tanstack/react-query'\nimport { useState } from 'react'\nimport { ChevronDown, ChevronRight, File, Folder, FolderOpen } from 'lucide-react'\nimport { Button } from './ui/button'\nimport { Badge } from './ui/badge'\nimport { Card } from './ui/card'\n\ninterface FileNode {\n  name: string\n  path: string\n  type: 'file' | 'directory'\n  size?: number\n  children?: FileNode[]\n  bundles?: string[]\n}\n\ninterface Bundle {\n  name: string\n  files: string[]\n}\n\nconst fetchBundles = async (): Promise<Bundle[]> => {\n  const response = await fetch('http://localhost:3333/api/bundles')\n  if (!response.ok) throw new Error('Failed to fetch bundles')\n  return response.json()\n}\n\nconst buildFileTree = (bundles: Bundle[]): FileNode => {\n  const root: FileNode = { name: '', path: '', type: 'directory', children: [] }\n  const allFiles = new Set<string>()\n  const fileBundleMap = new Map<string, string[]>()\n\n  // Collect all files and their bundle associations\n  bundles.forEach(bundle => {\n    bundle.files.forEach(file => {\n      allFiles.add(file)\n      if (!fileBundleMap.has(file)) {\n        fileBundleMap.set(file, [])\n      }\n      fileBundleMap.get(file)!.push(bundle.name)\n    })\n  })\n\n  // Build tree structure\n  allFiles.forEach(filePath => {\n    const parts = filePath.split('/')\n    let current = root\n\n    parts.forEach((part, index) => {\n      const isFile = index === parts.length - 1\n      const currentPath = parts.slice(0, index + 1).join('/')\n\n      if (!current.children) current.children = []\n\n      let existing = current.children.find(child => child.name === part)\n\n      if (!existing) {\n        existing = {\n          name: part,\n          path: currentPath,\n          type: isFile ? 'file' : 'directory',\n          children: isFile ? undefined : [],\n          bundles: isFile ? fileBundleMap.get(filePath) : undefined\n        }\n        current.children.push(existing)\n      }\n\n      if (!isFile) {\n        current = existing\n      }\n    })\n  })\n\n  // Sort: directories first, then files, alphabetically\n  const sortChildren = (node: FileNode) => {\n    if (node.children) {\n      node.children.sort((a, b) => {\n        if (a.type !== b.type) {\n          return a.type === 'directory' ? -1 : 1\n        }\n        return a.name.localeCompare(b.name)\n      })\n      node.children.forEach(sortChildren)\n    }\n  }\n\n  sortChildren(root)\n  return root\n}\n\nconst formatFileSize = (bytes: number): string => {\n  if (bytes === 0) return '0 B'\n  const k = 1024\n  const sizes = ['B', 'KB', 'MB', 'GB']\n  const i = Math.floor(Math.log(bytes) / Math.log(k))\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i]\n}\n\ninterface FileTreeNodeProps {\n  node: FileNode\n  level: number\n  expandedDirs: Set<string>\n  onToggleDir: (path: string) => void\n}\n\nfunction FileTreeNode({ node, level, expandedDirs, onToggleDir }: FileTreeNodeProps) {\n  const isExpanded = expandedDirs.has(node.path)\n  const indent = level * 16\n\n  if (node.type === 'directory') {\n    return (\n      <div>\n        <div\n          className=\"flex items-center gap-2 py-1 px-2 hover:bg-muted/50 rounded cursor-pointer\"\n          style={{ paddingLeft: `${indent + 8}px` }}\n          onClick={() => onToggleDir(node.path)}\n        >\n          {isExpanded ? (\n            <ChevronDown className=\"w-4 h-4 text-muted-foreground\" />\n          ) : (\n            <ChevronRight className=\"w-4 h-4 text-muted-foreground\" />\n          )}\n          {isExpanded ? (\n            <FolderOpen className=\"w-4 h-4 text-[color:var(--color-info)]\" />\n          ) : (\n            <Folder className=\"w-4 h-4 text-[color:var(--color-info)]\" />\n          )}\n          <span className=\"text-xs font-normal\">{node.name}</span>\n          {node.children && (\n            <span className=\"text-xs text-muted-foreground ml-auto\">\n              {node.children.length} items\n            </span>\n          )}\n        </div>\n\n        {isExpanded && node.children && (\n          <div>\n            {node.children.map((child) => (\n              <FileTreeNode\n                key={child.path}\n                node={child}\n                level={level + 1}\n                expandedDirs={expandedDirs}\n                onToggleDir={onToggleDir}\n              />\n            ))}\n          </div>\n        )}\n      </div>\n    )\n  }\n\n  // File node\n  const getFileIcon = (filename: string) => {\n    const ext = filename.split('.').pop()?.toLowerCase()\n    const iconClass = \"w-4 h-4\"\n\n    switch (ext) {\n      case 'js':\n      case 'ts':\n      case 'jsx':\n      case 'tsx':\n        return <File className={`${iconClass} text-[color:var(--color-warning)]`} />\n      case 'json':\n        return <File className={`${iconClass} text-[color:var(--color-success)]`} />\n      case 'md':\n        return <File className={`${iconClass} text-[color:var(--color-info)]/80`} />\n      case 'css':\n      case 'scss':\n        return <File className={`${iconClass} text-[color:var(--color-type-styles)]`} />\n      case 'html':\n        return <File className={`${iconClass} text-[color:var(--color-type-configuration)]`} />\n      default:\n        return <File className={`${iconClass} text-muted-foreground`} />\n    }\n  }\n\n  return (\n    <div\n      className=\"flex items-center gap-2 py-1 px-2 hover:bg-muted/50 rounded\"\n      style={{ paddingLeft: `${indent + 24}px` }}\n    >\n      {getFileIcon(node.name)}\n      <span className=\"text-xs font-mono\">{node.name}</span>\n\n      {node.bundles && node.bundles.length > 0 && (\n        <div className=\"flex gap-1 ml-2\">\n          {node.bundles.map(bundle => (\n            <Badge\n              key={bundle}\n              variant=\"outline\"\n              className=\"text-xs px-1 py-0 h-4\"\n            >\n              {bundle}\n            </Badge>\n          ))}\n        </div>\n      )}\n\n      {node.size && (\n        <span className=\"text-xs text-muted-foreground ml-auto\">\n          {formatFileSize(node.size)}\n        </span>\n      )}\n    </div>\n  )\n}\n\nexport function FileTree() {\n  const [expandedDirs, setExpandedDirs] = useState<Set<string>>(new Set(['']))\n  // wtf is this shit broseph? \n  // const [showUnbundled, setShowUnbundled] = useState(false)\n\n  const { data: bundles, isLoading } = useQuery({\n    queryKey: ['bundles'],\n    queryFn: fetchBundles,\n    refetchInterval: 5000,\n  })\n\n  const handleToggleDir = (path: string) => {\n    const newExpanded = new Set(expandedDirs)\n    if (newExpanded.has(path)) {\n      newExpanded.delete(path)\n    } else {\n      newExpanded.add(path)\n    }\n    setExpandedDirs(newExpanded)\n  }\n\n  const expandAll = () => {\n    if (!bundles) return\n    const tree = buildFileTree(bundles)\n    const allDirs = new Set<string>()\n\n    const collectDirs = (node: FileNode) => {\n      if (node.type === 'directory') {\n        allDirs.add(node.path)\n        node.children?.forEach(collectDirs)\n      }\n    }\n\n    collectDirs(tree)\n    setExpandedDirs(allDirs)\n  }\n\n  const collapseAll = () => {\n    setExpandedDirs(new Set(['']))\n  }\n\n  if (isLoading) return <div>Loading file tree...</div>\n  if (!bundles) return <div>No bundles found</div>\n\n  const tree = buildFileTree(bundles)\n  const totalFiles = bundles.reduce((acc, bundle) => acc + bundle.files.length, 0)\n\n  return (\n    <div className=\"space-y-4\">\n      {/* Controls */}\n      <div className=\"flex items-center justify-between\">\n        <div className=\"flex gap-1\">\n          <Button variant=\"outline\" size=\"sm\" className=\"h-7 text-xs\" onClick={expandAll}>\n            Expand All\n          </Button>\n          <Button variant=\"outline\" size=\"sm\" className=\"h-7 text-xs\" onClick={collapseAll}>\n            Collapse All\n          </Button>\n        </div>\n\n        <div className=\"text-xs text-muted-foreground font-normal\">\n          {totalFiles} files tracked\n        </div>\n      </div>\n\n      {/* File Tree */}\n      <Card className=\"p-4\">\n        <div className=\"space-y-1 max-h-96 overflow-y-auto\">\n          {tree.children && tree.children.length > 0 ? (\n            tree.children.map((child) => (\n              <FileTreeNode\n                key={child.path}\n                node={child}\n                level={0}\n                expandedDirs={expandedDirs}\n                onToggleDir={handleToggleDir}\n              />\n            ))\n          ) : (\n            <div className=\"text-center text-muted-foreground py-8\">\n              No files found\n            </div>\n          )}\n        </div>\n      </Card>\n\n      {/* Bundle Legend */}\n      <Card className=\"p-4\">\n        <h3 className=\"text-xs font-medium mb-2\">Bundle Legend</h3>\n        <div className=\"flex flex-wrap gap-2\">\n          {bundles.map(bundle => (\n            <Badge key={bundle.name} variant=\"outline\">\n              {bundle.name} ({bundle.files.length})\n            </Badge>\n          ))}\n        </div>\n      </Card>\n    </div>\n  )\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/HiddenFilesManager.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"25917\" modified=\"2025-06-26T00:23:43.363Z\" lines=\"673\" />\n        <cntx:content><![CDATA[import { useState } from 'react'\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'\nimport { Card, CardHeader, CardTitle, CardContent } from './ui/card'\nimport { Button } from './ui/button'\nimport { Input } from './ui/input'\nimport { Badge } from './ui/badge'\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from './ui/tabs'\nimport {\n  Eye,\n  EyeOff,\n  Search,\n  Plus,\n  Trash2,\n  RotateCcw,\n  FileText,\n  Settings,\n  AlertCircle,\n  CheckCircle,\n  Info,\n} from 'lucide-react'\nimport { toast } from '@/lib/toast'\n\ninterface FileWithVisibility {\n  path: string\n  size: number\n  modified: string\n  visible: boolean\n  globallyHidden: boolean\n  bundleHidden: boolean\n  inBundles: string[]\n  matchesIgnorePattern: boolean\n}\n\ninterface IgnorePattern {\n  pattern: string\n  active: boolean\n}\n\ninterface IgnorePatterns {\n  system: IgnorePattern[]\n  user: IgnorePattern[]\n  file: IgnorePattern[]\n}\n\ninterface BundleStats {\n  total: number\n  visible: number\n  hidden: number\n  patterns: string[]\n}\n\n// API functions\nconst fetchFilesWithVisibility = async (bundleName: string | null = null): Promise<FileWithVisibility[]> => {\n  const url = bundleName\n    ? `http://localhost:3333/api/files-with-visibility?bundle=${bundleName}`\n    : 'http://localhost:3333/api/files-with-visibility'\n  const response = await fetch(url)\n  if (!response.ok) throw new Error('Failed to fetch files')\n  return response.json()\n}\n\nconst fetchIgnorePatterns = async (): Promise<IgnorePatterns> => {\n  const response = await fetch('http://localhost:3333/api/ignore-patterns')\n  if (!response.ok) throw new Error('Failed to fetch ignore patterns')\n  return response.json()\n}\n\nconst fetchBundleVisibilityStats = async (): Promise<Record<string, BundleStats>> => {\n  const response = await fetch('http://localhost:3333/api/bundle-visibility-stats')\n  if (!response.ok) throw new Error('Failed to fetch bundle stats')\n  return response.json()\n}\n\nconst toggleFileVisibility = async ({ filePath, bundleName = null, forceHide = null }: {\n  filePath: string\n  bundleName?: string | null\n  forceHide?: boolean | null\n}) => {\n  const response = await fetch('http://localhost:3333/api/hidden-files', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      action: 'toggle',\n      filePath,\n      bundleName,\n      forceHide\n    })\n  })\n  if (!response.ok) throw new Error('Failed to toggle file visibility')\n  return response.json()\n}\n\nconst bulkToggleVisibility = async ({ filePaths, bundleName = null, forceHide }: {\n  filePaths: string[]\n  bundleName?: string | null\n  forceHide: boolean\n}) => {\n  const response = await fetch('http://localhost:3333/api/hidden-files', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      action: 'bulk-toggle',\n      filePaths,\n      bundleName,\n      forceHide\n    })\n  })\n  if (!response.ok) throw new Error('Failed to bulk toggle visibility')\n  return response.json()\n}\n\nconst manageIgnorePattern = async ({ action, pattern }: {\n  action: 'add' | 'remove' | 'toggle-system'\n  pattern: string\n}) => {\n  const response = await fetch('http://localhost:3333/api/ignore-patterns', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ action, pattern })\n  })\n  if (!response.ok) throw new Error('Failed to manage ignore pattern')\n  return response.json()\n}\n\nconst resetHiddenFiles = async ({ scope, bundleName = null }: {\n  scope: 'global' | 'bundle' | 'all'\n  bundleName?: string | null\n}) => {\n  const response = await fetch('http://localhost:3333/api/reset-hidden-files', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ scope, bundleName })\n  })\n  if (!response.ok) throw new Error('Failed to reset hidden files')\n  return response.json()\n}\n\nexport function HiddenFilesManager() {\n  const queryClient = useQueryClient()\n  const [selectedBundle, setSelectedBundle] = useState<string | null>(null)\n  const [searchTerm, setSearchTerm] = useState('')\n  const [showHidden, setShowHidden] = useState(false)\n  const [filterBy, setFilterBy] = useState('all') // all, hidden, visible\n  const [newPattern, setNewPattern] = useState('')\n  const [selectedFiles, setSelectedFiles] = useState<string[]>([])\n\n  // Queries\n  const { data: files = [], isLoading: filesLoading } = useQuery({\n    queryKey: ['files-with-visibility', selectedBundle],\n    queryFn: () => fetchFilesWithVisibility(selectedBundle),\n    refetchInterval: 5000\n  })\n\n  const { data: ignorePatterns = { system: [], user: [], file: [] }, isLoading: patternsLoading } = useQuery({\n    queryKey: ['ignore-patterns'],\n    queryFn: fetchIgnorePatterns,\n    refetchInterval: 10000\n  })\n\n  const { data: bundleStats = {}, isLoading: statsLoading } = useQuery({\n    queryKey: ['bundle-visibility-stats'],\n    queryFn: fetchBundleVisibilityStats,\n    refetchInterval: 5000\n  })\n\n  // Mutations\n  const toggleFileMutation = useMutation({\n    mutationFn: toggleFileVisibility,\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['files-with-visibility'] })\n      queryClient.invalidateQueries({ queryKey: ['bundle-visibility-stats'] })\n      queryClient.invalidateQueries({ queryKey: ['bundles'] })\n      toast.success('File visibility updated')\n    },\n    onError: (error: Error) => toast.error(`Failed to update file visibility: ${error.message}`)\n  })\n\n  const bulkToggleMutation = useMutation({\n    mutationFn: bulkToggleVisibility,\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['files-with-visibility'] })\n      queryClient.invalidateQueries({ queryKey: ['bundle-visibility-stats'] })\n      queryClient.invalidateQueries({ queryKey: ['bundles'] })\n      setSelectedFiles([])\n      toast.success('Bulk visibility update completed')\n    },\n    onError: (error: Error) => toast.error(`Failed to bulk update visibility: ${error.message}`)\n  })\n\n  const patternMutation = useMutation({\n    mutationFn: manageIgnorePattern,\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['ignore-patterns'] })\n      queryClient.invalidateQueries({ queryKey: ['files-with-visibility'] })\n      queryClient.invalidateQueries({ queryKey: ['bundles'] })\n      toast.success('Ignore pattern updated')\n    },\n    onError: (error: Error) => toast.error(`Failed to update ignore pattern: ${error.message}`)\n  })\n\n  const resetMutation = useMutation({\n    mutationFn: resetHiddenFiles,\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['files-with-visibility'] })\n      queryClient.invalidateQueries({ queryKey: ['bundle-visibility-stats'] })\n      queryClient.invalidateQueries({ queryKey: ['bundles'] })\n      toast.success('Hidden files reset successfully')\n    },\n    onError: (error: Error) => toast.error(`Failed to reset hidden files: ${error.message}`)\n  })\n\n  // Filter files\n  const filteredFiles = files.filter(file => {\n    const matchesSearch = file.path.toLowerCase().includes(searchTerm.toLowerCase())\n    const matchesVisibility = filterBy === 'all' ||\n      (filterBy === 'hidden' && !file.visible) ||\n      (filterBy === 'visible' && file.visible)\n    const shouldShow = showHidden || file.visible\n\n    return matchesSearch && matchesVisibility && shouldShow\n  })\n\n  // Handlers\n  const handleToggleFile = (filePath: string) => {\n    toggleFileMutation.mutate({ filePath, bundleName: selectedBundle })\n  }\n\n  const handleBulkToggle = (forceHide: boolean) => {\n    bulkToggleMutation.mutate({\n      filePaths: selectedFiles,\n      bundleName: selectedBundle,\n      forceHide\n    })\n  }\n\n  const handleAddPattern = () => {\n    if (newPattern.trim()) {\n      patternMutation.mutate({ action: 'add', pattern: newPattern.trim() })\n      setNewPattern('')\n    }\n  }\n\n  const handleTogglePattern = (pattern: string, isSystem = false) => {\n    const action = isSystem ? 'toggle-system' : 'remove'\n    patternMutation.mutate({ action, pattern })\n  }\n\n  const allPatterns = [\n    ...(ignorePatterns.system || []).map(p => ({ ...p, source: 'system' as const })),\n    ...(ignorePatterns.user || []).map(p => ({ ...p, source: 'user' as const })),\n    ...(ignorePatterns.file || []).map(p => ({ ...p, source: 'file' as const }))\n  ]\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Header */}\n      <div className=\"flex justify-between items-center\">\n        <div>\n          <h2 className=\"text-sm font-medium\">File Visibility & Ignore Management</h2>\n          <p className=\"text-xs text-muted-foreground font-normal\">\n            Control which files appear in bundles and manage ignore patterns\n          </p>\n        </div>\n        <div className=\"flex items-center gap-2\">\n          <Badge variant=\"outline\" className=\"flex items-center gap-1\">\n            <Eye className=\"w-3 h-3\" />\n            {filteredFiles.filter(f => f.visible).length} visible\n          </Badge>\n          <Badge variant=\"outline\" className=\"flex items-center gap-1\">\n            <EyeOff className=\"w-3 h-3\" />\n            {filteredFiles.filter(f => !f.visible).length} hidden\n          </Badge>\n        </div>\n      </div>\n\n      <Tabs defaultValue=\"files\" className=\"space-y-6\">\n        <TabsList>\n          <TabsTrigger value=\"files\">File Visibility</TabsTrigger>\n          <TabsTrigger value=\"patterns\">Ignore Patterns</TabsTrigger>\n          <TabsTrigger value=\"bundles\">Bundle Overview</TabsTrigger>\n        </TabsList>\n\n        {/* File Visibility Tab */}\n        <TabsContent value=\"files\" className=\"space-y-4\">\n          {/* Bundle Selector */}\n          <Card>\n            <CardContent className=\"pt-6\">\n              <div className=\"flex items-center gap-4 mb-4\">\n                <div className=\"flex items-center gap-2\">\n                  <label className=\"text-xs font-medium\">Bundle:</label>\n                  <select\n                    value={selectedBundle || ''}\n                    onChange={(e) => setSelectedBundle(e.target.value || null)}\n                    className=\"px-2 py-1 border rounded-md text-xs\"\n                  >\n                    <option value=\"\">All Bundles (Global)</option>\n                    {Object.keys(bundleStats).map(bundleName => (\n                      <option key={bundleName} value={bundleName}>{bundleName}</option>\n                    ))}\n                  </select>\n                </div>\n\n                {selectedBundle && (\n                  <Badge variant=\"secondary\">\n                    Bundle-specific visibility for {selectedBundle}\n                  </Badge>\n                )}\n              </div>\n\n              <div className=\"flex items-center gap-4\">\n                <div className=\"flex-1\">\n                  <div className=\"relative\">\n                    <Search className=\"absolute left-2 top-2.5 h-4 w-4 text-muted-foreground\" />\n                    <Input\n                      placeholder=\"Search files...\"\n                      value={searchTerm}\n                      onChange={(e) => setSearchTerm(e.target.value)}\n                      className=\"pl-8\"\n                    />\n                  </div>\n                </div>\n\n                <div className=\"flex items-center gap-2\">\n                  <Button\n                    variant=\"outline\"\n                    size=\"sm\"\n                    className={`h-7 text-xs ${showHidden ? 'bg-[color:var(--color-info)]/5 border-[color:var(--color-info)]/20' : ''}`}\n                    onClick={() => setShowHidden(!showHidden)}\n                  >\n                    {showHidden ? <Eye className=\"w-3 h-3\" /> : <EyeOff className=\"w-3 h-3\" />}\n                    {showHidden ? 'Hide Hidden' : 'Show Hidden'}\n                  </Button>\n\n                  <select\n                    value={filterBy}\n                    onChange={(e) => setFilterBy(e.target.value)}\n                    className=\"px-2 py-1 border rounded-md text-xs\"\n                  >\n                    <option value=\"all\">All Files</option>\n                    <option value=\"visible\">Visible Only</option>\n                    <option value=\"hidden\">Hidden Only</option>\n                  </select>\n                </div>\n              </div>\n\n              {/* Bulk Actions */}\n              {selectedFiles.length > 0 && (\n                <div className=\"flex items-center gap-2 p-3 bg-[color:var(--color-info)]/5 rounded-md border border-[color:var(--color-info)]/20 mt-4\">\n                  <Info className=\"w-4 h-4 text-[color:var(--color-info)]\" />\n                  <span className=\"text-xs text-[color:var(--color-info)] font-normal\">\n                    {selectedFiles.length} files selected\n                  </span>\n                  <div className=\"flex gap-2 ml-auto\">\n                    <Button size=\"sm\" className=\"h-7 text-xs\" onClick={() => handleBulkToggle(false)}>\n                      <Eye className=\"w-3 h-3 mr-1\" />\n                      Show All\n                    </Button>\n                    <Button size=\"sm\" className=\"h-7 text-xs\" variant=\"outline\" onClick={() => handleBulkToggle(true)}>\n                      <EyeOff className=\"w-3 h-3 mr-1\" />\n                      Hide All\n                    </Button>\n                    <Button\n                      size=\"sm\"\n                      className=\"h-7 text-xs\"\n                      variant=\"ghost\"\n                      onClick={() => setSelectedFiles([])}\n                    >\n                      Cancel\n                    </Button>\n                  </div>\n                </div>\n              )}\n            </CardContent>\n          </Card>\n\n          {/* File List */}\n          <Card>\n            <CardContent className=\"pt-6\">\n              {filesLoading ? (\n                <div className=\"text-center py-8\">Loading files...</div>\n              ) : (\n                <div className=\"space-y-2 max-h-96 overflow-y-auto\">\n                  {filteredFiles.map((file) => (\n                    <div\n                      key={file.path}\n                      className={`flex items-center gap-3 p-2 rounded-md border transition-colors ${!file.visible ? 'opacity-60 bg-muted/50' : 'hover:bg-muted/50'\n                        }`}\n                    >\n                      <input\n                        type=\"checkbox\"\n                        checked={selectedFiles.includes(file.path)}\n                        onChange={(e) => {\n                          if (e.target.checked) {\n                            setSelectedFiles([...selectedFiles, file.path])\n                          } else {\n                            setSelectedFiles(selectedFiles.filter(f => f !== file.path))\n                          }\n                        }}\n                        className=\"rounded\"\n                      />\n\n                      <FileText className=\"w-4 h-4 text-muted-foreground flex-shrink-0\" />\n\n                      <div className=\"flex-1 min-w-0\">\n                        <div className=\"font-mono text-xs truncate\">{file.path}</div>\n                        <div className=\"flex items-center gap-2 mt-1\">\n                          {file.inBundles.map(bundle => (\n                            <Badge key={bundle} variant=\"outline\" className=\"text-xs\">\n                              {bundle}\n                            </Badge>\n                          ))}\n                          {file.globallyHidden && (\n                            <Badge variant=\"destructive\" className=\"text-xs\">\n                              Globally Hidden\n                            </Badge>\n                          )}\n                          {file.bundleHidden && selectedBundle && (\n                            <Badge variant=\"secondary\" className=\"text-xs\">\n                              Hidden in {selectedBundle}\n                            </Badge>\n                          )}\n                          {file.matchesIgnorePattern && (\n                            <Badge variant=\"outline\" className=\"text-xs text-muted-foreground\">\n                              Ignored\n                            </Badge>\n                          )}\n                        </div>\n                      </div>\n\n                      <div className=\"text-xs text-muted-foreground\">\n                        {(file.size / 1024).toFixed(1)}kb\n                      </div>\n\n                      <Button\n                        size=\"sm\"\n                        variant=\"ghost\"\n                        onClick={() => handleToggleFile(file.path)}\n                        disabled={toggleFileMutation.isPending}\n                        className=\"flex-shrink-0\"\n                      >\n                        {file.visible ? (\n                          <>\n                            <EyeOff className=\"w-3 h-3 mr-1\" />\n                            Hide\n                          </>\n                        ) : (\n                          <>\n                            <Eye className=\"w-3 h-3 mr-1\" />\n                            Show\n                          </>\n                        )}\n                      </Button>\n                    </div>\n                  ))}\n                </div>\n              )}\n\n              {filteredFiles.length === 0 && !filesLoading && (\n                <div className=\"text-center py-8 text-muted-foreground\">\n                  No files match your current filters\n                </div>\n              )}\n            </CardContent>\n          </Card>\n\n          {/* Reset Options */}\n          <Card>\n            <CardHeader>\n              <CardTitle className=\"flex items-center gap-2 text-sm font-medium\">\n                <RotateCcw className=\"w-4 h-4\" />\n                Reset Options\n              </CardTitle>\n            </CardHeader>\n            <CardContent className=\"space-y-3\">\n              <div className=\"flex gap-2\">\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  className=\"h-7 text-xs\"\n                  onClick={() => resetMutation.mutate({ scope: 'global' })}\n                  disabled={resetMutation.isPending}\n                >\n                  Reset Global Hidden Files\n                </Button>\n\n                {selectedBundle && (\n                  <Button\n                    variant=\"outline\"\n                    size=\"sm\"\n                    onClick={() => resetMutation.mutate({ scope: 'bundle', bundleName: selectedBundle })}\n                    disabled={resetMutation.isPending}\n                  >\n                    Reset {selectedBundle} Bundle\n                  </Button>\n                )}\n\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  onClick={() => resetMutation.mutate({ scope: 'all' })}\n                  disabled={resetMutation.isPending}\n                  className=\"text-destructive border-destructive/20 hover:bg-destructive/5\"\n                >\n                  Reset All Hidden Files\n                </Button>\n              </div>\n            </CardContent>\n          </Card>\n        </TabsContent>\n\n        {/* Ignore Patterns Tab */}\n        <TabsContent value=\"patterns\" className=\"space-y-4\">\n          {/* Add New Pattern */}\n          <Card>\n            <CardHeader>\n              <CardTitle className=\"text-sm font-medium\">Add Ignore Pattern</CardTitle>\n            </CardHeader>\n            <CardContent className=\"space-y-4\">\n              <div className=\"flex gap-2\">\n                <Input\n                  placeholder=\"Enter glob pattern (e.g., *.log, src/debug/**)\"\n                  value={newPattern}\n                  onChange={(e) => setNewPattern(e.target.value)}\n                  className=\"flex-1\"\n                  onKeyDown={(e) => e.key === 'Enter' && handleAddPattern()}\n                />\n                <Button\n                  onClick={handleAddPattern}\n                  disabled={!newPattern.trim() || patternMutation.isPending}\n                  size=\"sm\"\n                  className=\"h-7 text-xs\"\n                >\n                  <Plus className=\"w-3 h-3 mr-1\" />\n                  Add Pattern\n                </Button>\n              </div>\n\n              <div className=\"text-sm text-muted-foreground\">\n                Examples: <code>*.log</code>, <code>node_modules/**</code>, <code>src/debug.ts</code>, <code>**/*.test.*</code>\n              </div>\n            </CardContent>\n          </Card>\n\n          {/* Existing Patterns */}\n          <Card>\n            <CardHeader>\n              <CardTitle className=\"text-sm font-medium\">Current Ignore Patterns</CardTitle>\n            </CardHeader>\n            <CardContent>\n              {patternsLoading ? (\n                <div className=\"text-center py-4\">Loading patterns...</div>\n              ) : (\n                <div className=\"space-y-3\">\n                  {allPatterns.map((item, index) => (\n                    <div\n                      key={index}\n                      className={`flex items-center gap-3 p-3 rounded-md border ${!item.active ? 'opacity-60 bg-muted/50' : ''\n                        }`}\n                    >\n                      <div className=\"flex-1\">\n                        <div className=\"font-mono text-xs\">{item.pattern}</div>\n                        <div className=\"flex items-center gap-2 mt-1\">\n                          <Badge\n                            variant={item.source === 'system' ? 'secondary' :\n                              item.source === 'user' ? 'default' : 'outline'}\n                            className=\"text-xs\"\n                          >\n                            {item.source === 'system' ? 'System Default' :\n                              item.source === 'user' ? 'User Added' : 'File Pattern'}\n                          </Badge>\n                          {item.active ? (\n                            <Badge variant=\"outline\" className=\"text-xs text-[color:var(--color-success)]\">\n                              <CheckCircle className=\"w-3 h-3 mr-1\" />\n                              Active\n                            </Badge>\n                          ) : (\n                            <Badge variant=\"outline\" className=\"text-xs text-muted-foreground\">\n                              <AlertCircle className=\"w-3 h-3 mr-1\" />\n                              Disabled\n                            </Badge>\n                          )}\n                        </div>\n                      </div>\n\n                      <div className=\"flex gap-2\">\n                        {item.source === 'system' ? (\n                          <Button\n                            size=\"sm\"\n                            variant=\"ghost\"\n                            onClick={() => handleTogglePattern(item.pattern, true)}\n                            disabled={patternMutation.isPending}\n                          >\n                            {item.active ? 'Disable' : 'Enable'}\n                          </Button>\n                        ) : (\n                          <Button\n                            size=\"sm\"\n                            variant=\"ghost\"\n                            onClick={() => handleTogglePattern(item.pattern, false)}\n                            disabled={patternMutation.isPending}\n                          >\n                            <Trash2 className=\"w-4 h-4\" />\n                          </Button>\n                        )}\n                      </div>\n                    </div>\n                  ))}\n                </div>\n              )}\n            </CardContent>\n          </Card>\n        </TabsContent>\n\n        {/* Bundle Overview Tab */}\n        <TabsContent value=\"bundles\" className=\"space-y-4\">\n          {statsLoading ? (\n            <div className=\"text-center py-8\">Loading bundle statistics...</div>\n          ) : (\n            <div className=\"grid gap-4\">\n              {Object.entries(bundleStats).map(([bundleName, stats]) => (\n                <Card key={bundleName}>\n                  <CardHeader>\n                    <div className=\"flex justify-between items-center\">\n                      <CardTitle className=\"text-sm font-medium\">{bundleName}</CardTitle>\n                      <div className=\"flex items-center gap-2\">\n                        <Badge variant=\"outline\">\n                          {stats.visible} / {stats.total} visible\n                        </Badge>\n                        {stats.hidden > 0 && (\n                          <Badge variant=\"secondary\">\n                            {stats.hidden} hidden\n                          </Badge>\n                        )}\n                      </div>\n                    </div>\n                  </CardHeader>\n                  <CardContent>\n                    <div className=\"space-y-3\">\n                      <div className=\"flex items-center gap-4\">\n                        <div className=\"flex-1 bg-border rounded-full h-2\">\n                          <div\n                            className=\"bg-[color:var(--color-info)] h-2 rounded-full\"\n                            style={{\n                              width: `${stats.total > 0 ? (stats.visible / stats.total) * 100 : 0}%`\n                            }}\n                          />\n                        </div>\n                        <Button\n                          size=\"sm\"\n                          variant=\"outline\"\n                          className=\"h-7 text-xs\"\n                          onClick={() => setSelectedBundle(bundleName)}\n                        >\n                          <Settings className=\"w-3 h-3 mr-1\" />\n                          Manage Files\n                        </Button>\n                      </div>\n\n                      <div className=\"text-sm text-muted-foreground\">\n                        <div>Patterns: {stats.patterns.join(', ')}</div>\n                      </div>\n                    </div>\n                  </CardContent>\n                </Card>\n              ))}\n            </div>\n          )}\n        </TabsContent>\n      </Tabs>\n    </div>\n  )\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/SemanticChunks.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"25816\" modified=\"2025-06-26T23:01:24.638Z\" lines=\"672\" />\n        <cntx:content><![CDATA[import { useState, useMemo } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { Card, CardHeader, CardTitle, CardContent } from './ui/card'\nimport { Button } from './ui/button'\nimport { Badge } from './ui/badge'\nimport { Alert, AlertDescription } from './ui/alert'\nimport { Input } from './ui/input'\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from './ui/select'\nimport {\n  Copy,\n  RefreshCw,\n  Zap,\n  FileText,\n  Code,\n  Package,\n  AlertTriangle,\n  Eye,\n  EyeOff,\n  BarChart3,\n  Search,\n  Filter,\n  X\n} from 'lucide-react'\nimport { toast } from '@/lib/toast'\n\ninterface SemanticChunk {\n  name: string\n  type: string\n  subtype?: string\n  purpose: string\n  filePath: string\n  size: number\n  startLine?: number\n  isExported?: boolean\n  isAsync?: boolean\n  complexity: {\n    level: string\n    score: number\n  }\n  includes?: {\n    imports: string[]\n    types: string[]\n  }\n  tags: string[]\n  code?: string\n  bundles: string[]\n}\n\ninterface SemanticAnalysis {\n  summary: {\n    totalFiles: number\n    totalFunctions: number\n    totalChunks: number\n    averageChunkSize: number\n  }\n  chunks: SemanticChunk[]\n}\n\n// API functions\nconst fetchSemanticAnalysis = async (): Promise<SemanticAnalysis> => {\n  const response = await fetch('http://localhost:3333/api/semantic-chunks')\n  if (!response.ok) throw new Error('Failed to fetch semantic analysis')\n  return response.json()\n}\n\n\nexport function SemanticChunks() {\n  const [showDetails, setShowDetails] = useState<string | null>(null)\n\n  // Filter states\n  const [searchTerm, setSearchTerm] = useState('')\n  const [typeFilter, setTypeFilter] = useState<string>('all')\n  const [complexityFilter, setComplexityFilter] = useState<string>('all')\n  const [purposeFilter, setPurposeFilter] = useState<string>('all')\n  const [asyncFilter, setAsyncFilter] = useState<string>('all')\n  const [exportedFilter, setExportedFilter] = useState<string>('all')\n  const [bundleFilter, setBundleFilter] = useState<string>('all')\n\n  const { data: analysis, isLoading, error, refetch } = useQuery({\n    queryKey: ['semantic-analysis'],\n    queryFn: fetchSemanticAnalysis,\n    staleTime: 30000, // Cache for 30 seconds\n    refetchInterval: 60000 // Refresh every minute\n  })\n\n\n  // Filtered chunks based on search and filters\n  const filteredChunks = useMemo(() => {\n    if (!analysis?.chunks) return []\n\n    const filtered = analysis.chunks.filter(chunk => {\n      // Search filter\n      if (searchTerm) {\n        const searchLower = searchTerm.toLowerCase()\n        const matchesSearch =\n          chunk.name.toLowerCase().includes(searchLower) ||\n          chunk.purpose.toLowerCase().includes(searchLower) ||\n          chunk.filePath.toLowerCase().includes(searchLower) ||\n          chunk.code?.toLowerCase().includes(searchLower)\n\n        if (!matchesSearch) return false\n      }\n\n      // Type filter\n      if (typeFilter !== 'all' && chunk.subtype !== typeFilter) return false\n\n      // Complexity filter\n      if (complexityFilter !== 'all' && chunk.complexity?.level !== complexityFilter) return false\n\n      // Purpose filter\n      if (purposeFilter !== 'all' && !chunk.purpose.toLowerCase().includes(purposeFilter.toLowerCase())) return false\n\n      // Async filter\n      if (asyncFilter === 'async' && !chunk.isAsync) return false\n      if (asyncFilter === 'sync' && chunk.isAsync) return false\n\n      // Exported filter\n      if (exportedFilter === 'exported' && !chunk.isExported) return false\n      if (exportedFilter === 'internal' && chunk.isExported) return false\n\n      // Bundle filter\n      if (bundleFilter !== 'all' && !chunk.bundles?.includes(bundleFilter)) return false\n\n      return true\n    })\n\n    return filtered\n  }, [analysis?.chunks, searchTerm, typeFilter, complexityFilter, purposeFilter, asyncFilter, exportedFilter, bundleFilter])\n\n  // Get unique values for filter options\n  const filterOptions = useMemo(() => {\n    if (!analysis?.chunks) return { types: [], purposes: [], complexities: [], bundles: [] }\n\n    const types = [...new Set(analysis.chunks.map(c => c.subtype).filter(Boolean))].sort()\n    const purposes = [...new Set(analysis.chunks.map(c => c.purpose))].sort()\n    const complexities = [...new Set(analysis.chunks.map(c => c.complexity?.level).filter(Boolean))].sort()\n    const bundles = [...new Set(analysis.chunks.flatMap(c => c.bundles || []))].sort()\n\n    return { types, purposes, complexities, bundles }\n  }, [analysis?.chunks])\n\n  const clearFilters = () => {\n    setSearchTerm('')\n    setTypeFilter('all')\n    setComplexityFilter('all')\n    setPurposeFilter('all')\n    setAsyncFilter('all')\n    setExportedFilter('all')\n    setBundleFilter('all')\n  }\n\n  const hasActiveFilters = searchTerm || typeFilter !== 'all' || complexityFilter !== 'all' ||\n    purposeFilter !== 'all' || asyncFilter !== 'all' || exportedFilter !== 'all' || bundleFilter !== 'all'\n\n\n  const getChunkIcon = (chunk: SemanticChunk) => {\n    if (chunk.subtype === 'react_component' || chunk.tags?.includes('react_component')) return <Code className=\"w-4 h-4\" />\n    if (chunk.purpose?.includes('React hook')) return <Zap className=\"w-4 h-4\" />\n    if (chunk.subtype === 'arrow_function') return <FileText className=\"w-4 h-4\" />\n    if (chunk.subtype === 'method') return <Package className=\"w-4 h-4\" />\n    return <FileText className=\"w-4 h-4\" />\n  }\n\n  const getComplexityColor = (level: string) => {\n    switch (level) {\n      case 'low': return 'text-green-600'\n      case 'medium': return 'text-yellow-600'\n      case 'high': return 'text-red-600'\n      default: return 'text-gray-600'\n    }\n  }\n\n  if (isLoading) {\n    return (\n      <Card>\n        <CardContent className=\"pt-6\">\n          <div className=\"flex items-center justify-center py-8\">\n            <RefreshCw className=\"w-6 h-6 animate-spin mr-2\" />\n            <span className=\"text-sm\">Analyzing code semantics...</span>\n          </div>\n        </CardContent>\n      </Card>\n    )\n  }\n\n  if (error) {\n    return (\n      <Card>\n        <CardContent className=\"pt-6\">\n          <Alert>\n            <AlertTriangle className=\"w-4 h-4\" />\n            <AlertDescription>\n              Failed to load semantic analysis. Make sure the server supports semantic chunking.\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                className=\"ml-2\"\n                onClick={() => refetch()}\n              >\n                Retry\n              </Button>\n            </AlertDescription>\n          </Alert>\n        </CardContent>\n      </Card>\n    )\n  }\n\n  if (!analysis) return null\n\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Filters */}\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center justify-between text-sm font-medium\">\n            <div className=\"flex items-center gap-2\">\n              <Filter className=\"w-4 h-4\" />\n              Filters\n            </div>\n            {hasActiveFilters && (\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                className=\"h-7 text-xs\"\n                onClick={clearFilters}\n              >\n                <X className=\"w-3 h-3 mr-1\" />\n                Clear All\n              </Button>\n            )}\n          </CardTitle>\n        </CardHeader>\n        <CardContent>\n          <div className=\"grid grid-cols-1 md:grid-cols-3 lg:grid-cols-7 gap-4\">\n            {/* Search */}\n            <div className=\"md:col-span-2\">\n              <div className=\"relative\">\n                <Search className=\"absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-muted-foreground\" />\n                <Input\n                  placeholder=\"Search functions...\"\n                  value={searchTerm}\n                  onChange={(e) => setSearchTerm(e.target.value)}\n                  className=\"pl-10 h-8 text-xs\"\n                />\n              </div>\n            </div>\n\n            {/* Function Type */}\n            <div>\n              <Select value={typeFilter} onValueChange={setTypeFilter}>\n                <SelectTrigger className=\"h-8 text-xs\">\n                  <SelectValue placeholder=\"Type\" />\n                </SelectTrigger>\n                <SelectContent>\n                  <SelectItem value=\"all\">All Types</SelectItem>\n                  {filterOptions.types.map(type => (\n                    <SelectItem key={type} value={type}>{type}</SelectItem>\n                  ))}\n                </SelectContent>\n              </Select>\n            </div>\n\n            {/* Complexity */}\n            <div>\n              <Select value={complexityFilter} onValueChange={setComplexityFilter}>\n                <SelectTrigger className=\"h-8 text-xs\">\n                  <SelectValue placeholder=\"Complexity\" />\n                </SelectTrigger>\n                <SelectContent>\n                  <SelectItem value=\"all\">All Complexity</SelectItem>\n                  {filterOptions.complexities.map(complexity => (\n                    <SelectItem key={complexity} value={complexity}>{complexity}</SelectItem>\n                  ))}\n                </SelectContent>\n              </Select>\n            </div>\n\n            {/* Purpose */}\n            <div>\n              <Select value={purposeFilter} onValueChange={setPurposeFilter}>\n                <SelectTrigger className=\"h-8 text-xs\">\n                  <SelectValue placeholder=\"Purpose\" />\n                </SelectTrigger>\n                <SelectContent>\n                  <SelectItem value=\"all\">All Purposes</SelectItem>\n                  {filterOptions.purposes.map(purpose => (\n                    <SelectItem key={purpose} value={purpose}>{purpose}</SelectItem>\n                  ))}\n                </SelectContent>\n              </Select>\n            </div>\n\n            {/* Async/Sync */}\n            <div>\n              <Select value={asyncFilter} onValueChange={setAsyncFilter}>\n                <SelectTrigger className=\"h-8 text-xs\">\n                  <SelectValue placeholder=\"Async\" />\n                </SelectTrigger>\n                <SelectContent>\n                  <SelectItem value=\"all\">All Functions</SelectItem>\n                  <SelectItem value=\"async\">Async Only</SelectItem>\n                  <SelectItem value=\"sync\">Sync Only</SelectItem>\n                </SelectContent>\n              </Select>\n            </div>\n\n            {/* Bundle */}\n            <div>\n              <Select value={bundleFilter} onValueChange={setBundleFilter}>\n                <SelectTrigger className=\"h-8 text-xs\">\n                  <SelectValue placeholder=\"Bundle\" />\n                </SelectTrigger>\n                <SelectContent>\n                  <SelectItem value=\"all\">All Bundles</SelectItem>\n                  {filterOptions.bundles.map(bundle => (\n                    <SelectItem key={bundle} value={bundle}>{bundle}</SelectItem>\n                  ))}\n                </SelectContent>\n              </Select>\n            </div>\n          </div>\n\n          {/* Active Filters Display */}\n          {hasActiveFilters && (\n            <div className=\"flex flex-wrap gap-2 mt-4 pt-4 border-t\">\n              {searchTerm && (\n                <Badge variant=\"secondary\" className=\"text-xs flex items-center gap-1\">\n                  Search: \"{searchTerm}\"\n                  <button\n                    onClick={(e) => {\n                      e.preventDefault()\n                      e.stopPropagation()\n                      setSearchTerm('')\n                    }}\n                    className=\"ml-1 hover:bg-muted rounded-sm p-0.5\"\n                  >\n                    <X className=\"w-3 h-3\" />\n                  </button>\n                </Badge>\n              )}\n              {typeFilter !== 'all' && (\n                <Badge variant=\"secondary\" className=\"text-xs flex items-center gap-1\">\n                  Type: {typeFilter}\n                  <button\n                    onClick={(e) => {\n                      e.preventDefault()\n                      e.stopPropagation()\n                      setTypeFilter('all')\n                    }}\n                    className=\"ml-1 hover:bg-muted rounded-sm p-0.5\"\n                  >\n                    <X className=\"w-3 h-3\" />\n                  </button>\n                </Badge>\n              )}\n              {complexityFilter !== 'all' && (\n                <Badge variant=\"secondary\" className=\"text-xs flex items-center gap-1\">\n                  Complexity: {complexityFilter}\n                  <button\n                    onClick={(e) => {\n                      e.preventDefault()\n                      e.stopPropagation()\n                      setComplexityFilter('all')\n                    }}\n                    className=\"ml-1 hover:bg-muted rounded-sm p-0.5\"\n                  >\n                    <X className=\"w-3 h-3\" />\n                  </button>\n                </Badge>\n              )}\n              {purposeFilter !== 'all' && (\n                <Badge variant=\"secondary\" className=\"text-xs flex items-center gap-1\">\n                  Purpose: {purposeFilter}\n                  <button\n                    onClick={(e) => {\n                      e.preventDefault()\n                      e.stopPropagation()\n                      setPurposeFilter('all')\n                    }}\n                    className=\"ml-1 hover:bg-muted rounded-sm p-0.5\"\n                  >\n                    <X className=\"w-3 h-3\" />\n                  </button>\n                </Badge>\n              )}\n              {asyncFilter !== 'all' && (\n                <Badge variant=\"secondary\" className=\"text-xs flex items-center gap-1\">\n                  {asyncFilter === 'async' ? 'Async Only' : 'Sync Only'}\n                  <button\n                    onClick={(e) => {\n                      e.preventDefault()\n                      e.stopPropagation()\n                      setAsyncFilter('all')\n                    }}\n                    className=\"ml-1 hover:bg-muted rounded-sm p-0.5\"\n                  >\n                    <X className=\"w-3 h-3\" />\n                  </button>\n                </Badge>\n              )}\n              {bundleFilter !== 'all' && (\n                <Badge variant=\"secondary\" className=\"text-xs flex items-center gap-1\">\n                  Bundle: {bundleFilter}\n                  <button\n                    onClick={(e) => {\n                      e.preventDefault()\n                      e.stopPropagation()\n                      setBundleFilter('all')\n                    }}\n                    className=\"ml-1 hover:bg-muted rounded-sm p-0.5\"\n                  >\n                    <X className=\"w-3 h-3\" />\n                  </button>\n                </Badge>\n              )}\n            </div>\n          )}\n        </CardContent>\n      </Card>\n\n      {/* Analysis Summary */}\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center justify-between text-sm font-medium\">\n            <div className=\"flex items-center gap-2\">\n              <BarChart3 className=\"w-4 h-4\" />\n              Project Analysis\n            </div>\n            <Button\n              variant=\"outline\"\n              size=\"sm\"\n              className=\"h-7 text-xs\"\n              onClick={() => refetch()}\n              disabled={isLoading}\n            >\n              <RefreshCw className=\"w-3 h-3 mr-1\" />\n              Refresh\n            </Button>\n          </CardTitle>\n        </CardHeader>\n        <CardContent>\n          <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4 text-center\">\n            <div>\n              <div className=\"text-lg font-medium\">{analysis.summary?.totalFiles || 0}</div>\n              <div className=\"text-xs text-muted-foreground font-normal\">Files Analyzed</div>\n            </div>\n            <div>\n              <div className=\"text-lg font-medium\">{analysis.summary?.totalFunctions || 0}</div>\n              <div className=\"text-xs text-muted-foreground font-normal\">Functions Extracted</div>\n            </div>\n            <div>\n              <div className=\"text-lg font-medium\">\n                {filteredChunks.length}\n                {hasActiveFilters && (\n                  <span className=\"text-sm text-muted-foreground\"> / {analysis.summary?.totalChunks || 0}</span>\n                )}\n              </div>\n              <div className=\"text-xs text-muted-foreground font-normal\">\n                {hasActiveFilters ? 'Filtered' : 'Total'} Chunks\n              </div>\n            </div>\n            <div>\n              <div className=\"text-lg font-medium\">{Math.round(analysis.summary?.averageChunkSize || 0)}</div>\n              <div className=\"text-xs text-muted-foreground font-normal\">Avg Chunk Size</div>\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n\n      {/* Semantic Chunks Grid */}\n      <div className=\"grid gap-4\">\n        {filteredChunks.length === 0 ? (\n          <Card>\n            <CardContent className=\"pt-6\">\n              <div className=\"text-center py-8\">\n                <Package className=\"w-12 h-12 mx-auto text-muted-foreground mb-4\" />\n                <h3 className=\"text-lg font-medium mb-2\">No chunks match your filters</h3>\n                <p className=\"text-sm text-muted-foreground mb-4\">\n                  Try adjusting your search criteria or clearing the filters.\n                </p>\n                {hasActiveFilters && (\n                  <Button variant=\"outline\" onClick={clearFilters}>\n                    Clear All Filters\n                  </Button>\n                )}\n              </div>\n            </CardContent>\n          </Card>\n        ) : (\n          filteredChunks.map((chunk, index) => (\n            <Card key={`${chunk.filePath}-${chunk.name}-${index}`} className=\"relative\">\n              <CardHeader>\n                <div className=\"flex items-start justify-between\">\n                  <div className=\"flex items-start gap-3\">\n                    <div className=\"mt-1\">\n                      {getChunkIcon(chunk)}\n                    </div>\n                    <div className=\"flex-1\">\n                      <CardTitle className=\"text-sm font-medium tracking-wide\">\n                        {chunk.name}\n                      </CardTitle>\n                      <div className=\"flex items-center gap-2 mt-1\">\n                        <Badge variant=\"outline\" className=\"text-xs h-4\">\n                          {chunk.subtype || chunk.type}\n                        </Badge>\n                        <Badge variant=\"outline\" className=\"text-xs h-4\">\n                          {chunk.size} chars\n                        </Badge>\n                        <Badge\n                          variant=\"outline\"\n                          className={`text-xs h-4 ${getComplexityColor(chunk.complexity?.level || 'unknown')}`}\n                        >\n                          {chunk.complexity?.level || 'unknown'} complexity\n                        </Badge>\n                        {chunk.isAsync && (\n                          <Badge variant=\"outline\" className=\"text-xs h-4 bg-blue-50\">\n                            async\n                          </Badge>\n                        )}\n                        {chunk.isExported && (\n                          <Badge variant=\"outline\" className=\"text-xs h-4 bg-green-50\">\n                            exported\n                          </Badge>\n                        )}\n                      </div>\n                    </div>\n                  </div>\n                  <div className=\"flex gap-1\">\n                    <Button\n                      variant=\"outline\"\n                      size=\"sm\"\n                      className=\"h-7 text-xs\"\n                      onClick={() => setShowDetails(showDetails === chunk.name ? null : chunk.name)}\n                    >\n                      {showDetails === chunk.name ? (\n                        <EyeOff className=\"w-3 h-3\" />\n                      ) : (\n                        <Eye className=\"w-3 h-3\" />\n                      )}\n                    </Button>\n                  </div>\n                </div>\n              </CardHeader>\n              <CardContent>\n                <div className=\"space-y-3\">\n                  {/* Purpose and Tags */}\n                  <div>\n                    <p className=\"text-xs text-muted-foreground font-normal mb-2\">\n                      🎯 {chunk.purpose}\n                    </p>\n                    <div className=\"flex flex-wrap gap-1\">\n                      {(chunk.tags || []).slice(0, 6).map(tag => (\n                        <Badge key={tag} variant=\"secondary\" className=\"text-xs h-4\">\n                          {tag}\n                        </Badge>\n                      ))}\n                      {(chunk.tags || []).length > 6 && (\n                        <Badge variant=\"secondary\" className=\"text-xs h-4\">\n                          +{(chunk.tags || []).length - 6} more\n                        </Badge>\n                      )}\n                    </div>\n                  </div>\n\n                  {/* File Path and Location */}\n                  <div>\n                    <div className=\"text-xs font-medium mb-1\">Location:</div>\n                    <div className=\"text-xs text-muted-foreground font-normal font-mono\">\n                      {chunk.filePath}{chunk.startLine ? `:${chunk.startLine}` : ''}\n                    </div>\n                  </div>\n\n                  {/* Bundle Membership */}\n                  {(chunk.bundles?.length || 0) > 0 && (\n                    <div className=\"flex items-start gap-2 p-2 bg-blue-50 rounded text-xs\">\n                      <Package className=\"w-3 h-3 mt-0.5 text-blue-600\" />\n                      <div>\n                        <div className=\"font-medium text-blue-800\">Bundles:</div>\n                        <div className=\"flex flex-wrap gap-1 mt-1\">\n                          {chunk.bundles?.map(bundle => (\n                            <Badge key={bundle} variant=\"outline\" className=\"text-xs h-4 bg-blue-100 text-blue-700 border-blue-200\">\n                              {bundle}\n                            </Badge>\n                          ))}\n                        </div>\n                      </div>\n                    </div>\n                  )}\n\n                  {/* Function Includes (imports/types) */}\n                  {(chunk.includes?.imports.length || 0) > 0 && (\n                    <div className=\"flex items-start gap-2 p-2 bg-muted/50 rounded text-xs\">\n                      <Package className=\"w-3 h-3 mt-0.5 text-blue-500\" />\n                      <div>\n                        <div className=\"font-medium\">Imports:</div>\n                        <div className=\"font-normal\">{chunk.includes?.imports.slice(0, 3).join(', ')}</div>\n                        {(chunk.includes?.imports.length || 0) > 3 && (\n                          <div className=\"text-muted-foreground\">+{(chunk.includes?.imports.length || 0) - 3} more</div>\n                        )}\n                      </div>\n                    </div>\n                  )}\n\n                  {/* Expanded Details */}\n                  {showDetails === chunk.name && (\n                    <div className=\"border-t pt-3 space-y-3\">\n                      {/* Function Code Preview */}\n                      {chunk.code && (\n                        <div>\n                          <div className=\"flex items-center justify-between mb-2\">\n                            <div className=\"text-xs font-medium\">Function Code:</div>\n                            <Button\n                              variant=\"outline\"\n                              size=\"sm\"\n                              className=\"h-6 text-xs\"\n                              onClick={() => {\n                                navigator.clipboard.writeText(chunk.code || '')\n                                toast.success('Code copied to clipboard!')\n                              }}\n                            >\n                              <Copy className=\"w-3 h-3 mr-1\" />\n                              Copy\n                            </Button>\n                          </div>\n                          <div className=\"bg-muted/30 rounded p-3 text-xs font-mono overflow-x-auto\">\n                            <pre className=\"whitespace-pre-wrap\">{chunk.code}</pre>\n                          </div>\n                        </div>\n                      )}\n\n                      {/* Dependencies */}\n                      {(chunk.includes?.imports.length || 0) > 0 && (\n                        <div>\n                          <div className=\"text-xs font-medium mb-2\">All Imports:</div>\n                          <div className=\"space-y-1\">\n                            {chunk.includes?.imports.map((imp, idx) => (\n                              <div key={idx} className=\"text-xs font-mono text-muted-foreground bg-muted/30 px-2 py-1 rounded\">\n                                {imp}\n                              </div>\n                            ))}\n                          </div>\n                        </div>\n                      )}\n\n                      {/* Types */}\n                      {(chunk.includes?.types.length || 0) > 0 && (\n                        <div>\n                          <div className=\"text-xs font-medium mb-2\">Related Types:</div>\n                          <div className=\"space-y-1\">\n                            {chunk.includes?.types.map((type, idx) => (\n                              <div key={idx} className=\"text-xs font-mono text-muted-foreground bg-muted/30 px-2 py-1 rounded\">\n                                {type}\n                              </div>\n                            ))}\n                          </div>\n                        </div>\n                      )}\n\n                    </div>\n                  )}\n                </div>\n              </CardContent>\n            </Card>\n          )))}\n      </div>\n\n    </div>\n  )\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/SetupComponents.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"11953\" modified=\"2025-06-26T00:24:40.307Z\" lines=\"328\" />\n        <cntx:content><![CDATA[// Updated SetupComponents.tsx with clearer CLI vs UI guidance\n\nimport { useQuery } from '@tanstack/react-query'\nimport { Card, CardHeader, CardTitle, CardContent } from './ui/card'\nimport { Button } from './ui/button'\nimport { Alert, AlertDescription } from './ui/alert'\nimport { CheckCircle, AlertTriangle, Settings, Play, Terminal, FileText, Monitor, Command } from 'lucide-react'\n\ninterface SetupStatus {\n  hasConfig: boolean\n  hasIgnoreFile: boolean\n  bundleCount: number\n  hasCursorRules: boolean\n  isFirstTime: boolean\n}\n\nconst fetchSetupStatus = async (): Promise<SetupStatus> => {\n  try {\n    const [configResponse, bundlesResponse, cursorResponse] = await Promise.all([\n      fetch('http://localhost:3333/api/config'),\n      fetch('http://localhost:3333/api/bundles'),\n      fetch('http://localhost:3333/api/cursor-rules')\n    ])\n\n    const hasConfig = configResponse.ok\n    const bundles = bundlesResponse.ok ? await bundlesResponse.json() : []\n    const hasCursorRules = cursorResponse.ok\n\n    return {\n      hasConfig,\n      hasIgnoreFile: true, // We can assume this exists if config exists\n      bundleCount: bundles.length || 0,\n      hasCursorRules,\n      isFirstTime: !hasConfig || bundles.length === 0\n    }\n  } catch (error) {\n    return {\n      hasConfig: false,\n      hasIgnoreFile: false,\n      bundleCount: 0,\n      hasCursorRules: false,\n      isFirstTime: true\n    }\n  }\n}\n\ninterface SetupBannerProps {\n  onStartSetup: () => void\n}\n\nexport function SetupBanner({ onStartSetup }: SetupBannerProps) {\n  const { data: status, isLoading } = useQuery({\n    queryKey: ['setup-status'],\n    queryFn: fetchSetupStatus,\n    refetchInterval: 5000,\n  })\n\n  if (isLoading || !status?.isFirstTime) {\n    return null\n  }\n\n  return (\n    <Alert className=\"mb-6 border-[color:var(--color-info)]/20 bg-[color:var(--color-info)]/5\">\n      <Settings className=\"w-4 h-4\" />\n      <AlertDescription className=\"flex items-center justify-between\">\n        <div>\n          <strong>Welcome to cntx-ui!</strong> This looks like your first time.\n          The web interface is already running - let's help you get set up properly.\n        </div>\n        <Button onClick={onStartSetup} size=\"sm\">\n          Start Setup Guide\n        </Button>\n      </AlertDescription>\n    </Alert>\n  )\n}\n\ninterface SetupChecklistProps {\n  onOpenFullSetup: () => void\n}\n\nexport function SetupChecklist({ onOpenFullSetup }: SetupChecklistProps) {\n  const { data: status, isLoading } = useQuery({\n    queryKey: ['setup-status'],\n    queryFn: fetchSetupStatus,\n    refetchInterval: 10000,\n  })\n\n  if (isLoading) {\n    return <div>Checking setup status...</div>\n  }\n\n  const checks = [\n    {\n      label: 'Configuration file exists',\n      passed: status?.hasConfig || false,\n      description: '.cntx/config.json with bundle definitions'\n    },\n    {\n      label: 'Ignore patterns configured',\n      passed: status?.hasIgnoreFile || false,\n      description: '.cntxignore file to exclude unnecessary files'\n    },\n    {\n      label: 'Bundles generated',\n      passed: (status?.bundleCount || 0) > 0,\n      description: `${status?.bundleCount || 0} bundles currently configured`\n    },\n    {\n      label: 'Cursor rules created',\n      passed: status?.hasCursorRules || false,\n      description: '.cursorrules file for AI assistant context'\n    }\n  ]\n\n  const allPassed = checks.every(check => check.passed)\n\n  return (\n    <Card className={!allPassed ? 'border-[color:var(--color-warning)]/20' : ''}>\n      <CardHeader>\n        <CardTitle className=\"flex items-center gap-2 text-sm font-medium\">\n          <Settings className=\"w-4 h-4\" />\n          Setup Status\n          {allPassed ? (\n            <CheckCircle className=\"w-4 h-4 text-[color:var(--color-success)]\" />\n          ) : (\n            <AlertTriangle className=\"w-4 h-4 text-[color:var(--color-warning)]\" />\n          )}\n        </CardTitle>\n      </CardHeader>\n      <CardContent>\n        <div className=\"space-y-3\">\n          {checks.map((check, index) => (\n            <div key={index} className=\"flex items-start gap-3\">\n              <div className=\"flex-shrink-0 mt-0.5\">\n                {check.passed ? (\n                  <CheckCircle className=\"w-4 h-4 text-[color:var(--color-success)]\" />\n                ) : (\n                  <AlertTriangle className=\"w-4 h-4 text-[color:var(--color-warning)]\" />\n                )}\n              </div>\n              <div className=\"flex-1\">\n                <div className={`text-xs font-medium ${check.passed ? 'text-[color:var(--color-success)]' : 'text-[color:var(--color-warning)]'}`}>\n                  {check.label}\n                </div>\n                <div className=\"text-xs text-muted-foreground font-normal\">{check.description}</div>\n              </div>\n            </div>\n          ))}\n        </div>\n\n        {!allPassed && (\n          <div className=\"mt-4 pt-4 border-t\">\n            <Button onClick={onOpenFullSetup} variant=\"outline\" size=\"sm\" className=\"w-full h-7 text-xs\">\n              <Play className=\"w-3 h-3 mr-2\" />\n              Complete Setup Guide\n            </Button>\n          </div>\n        )}\n      </CardContent>\n    </Card>\n  )\n}\n\n// CLI vs UI guidance component\nexport function UsageGuidance() {\n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle className=\"flex items-center gap-2 text-sm font-medium\">\n          <Monitor className=\"w-4 h-4\" />\n          How to Use cntx-ui\n        </CardTitle>\n      </CardHeader>\n      <CardContent className=\"space-y-4\">\n        <Alert className=\"border-[color:var(--color-info)]/20 bg-[color:var(--color-info)]/5\">\n          <Terminal className=\"w-4 h-4\" />\n          <AlertDescription>\n            <strong>You're already running!</strong> The web interface provides full functionality.\n            CLI commands are available for automation and advanced workflows.\n          </AlertDescription>\n        </Alert>\n\n        <div className=\"space-y-4\">\n          <div>\n            <h4 className=\"text-xs font-medium mb-2 flex items-center gap-2\">\n              <Monitor className=\"w-3 h-3\" />\n              Web Interface (Recommended)\n            </h4>\n            <div className=\"text-xs text-muted-foreground font-normal space-y-2\">\n              <p>Perfect for interactive use and project management:</p>\n              <div className=\"ml-4 space-y-1\">\n                <div>• <strong>Bundle Management:</strong> View, create, and manage bundles</div>\n                <div>• <strong>Configuration:</strong> Edit bundle patterns visually</div>\n                <div>• <strong>Hidden Files:</strong> Control file visibility per bundle</div>\n                <div>• <strong>Cursor Rules:</strong> Manage AI assistant context</div>\n                <div>• <strong>Real-time Updates:</strong> See changes immediately</div>\n              </div>\n            </div>\n          </div>\n\n          <div>\n            <h4 className=\"text-xs font-medium mb-2 flex items-center gap-2\">\n              <Command className=\"w-3 h-3\" />\n              Command Line Interface\n            </h4>\n            <div className=\"text-xs text-muted-foreground font-normal space-y-2\">\n              <p>Great for automation, scripts, and CI/CD:</p>\n              <div className=\"ml-4 space-y-1\">\n                <div>• <strong>Quick bundle generation:</strong> <code className=\"bg-muted px-1 rounded\">cntx-ui bundle master</code></div>\n                <div>• <strong>Status checking:</strong> <code className=\"bg-muted px-1 rounded\">cntx-ui status</code></div>\n                <div>• <strong>Scripting workflows:</strong> Integrate with build processes</div>\n              </div>\n            </div>\n          </div>\n        </div>\n      </CardContent>\n    </Card>\n  )\n}\n\n// Quick CLI reference for advanced users\nexport function QuickCliReference() {\n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle className=\"flex items-center gap-2 text-sm font-medium\">\n          <Terminal className=\"w-4 h-4\" />\n          CLI Reference\n        </CardTitle>\n      </CardHeader>\n      <CardContent>\n        <div className=\"space-y-3 text-sm font-mono\">\n          <div className=\"flex items-center gap-2\">\n            <code className=\"bg-muted px-2 py-1 rounded text-xs\">cntx-ui watch</code>\n            <span className=\"text-muted-foreground text-xs\">Start server (already running)</span>\n          </div>\n          <div className=\"flex items-center gap-2\">\n            <code className=\"bg-muted px-2 py-1 rounded text-xs\">cntx-ui status</code>\n            <span className=\"text-muted-foreground text-xs\">Check configuration status</span>\n          </div>\n          <div className=\"flex items-center gap-2\">\n            <code className=\"bg-muted px-2 py-1 rounded text-xs\">cntx-ui bundle [name]</code>\n            <span className=\"text-muted-foreground text-xs\">Generate specific bundle</span>\n          </div>\n        </div>\n      </CardContent>\n    </Card>\n  )\n}\n\n// Workflow instructions component\nexport function WorkflowInstructions() {\n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle className=\"flex items-center gap-2 text-sm font-medium\">\n          <FileText className=\"w-4 h-4\" />\n          Common Workflows\n        </CardTitle>\n      </CardHeader>\n      <CardContent className=\"space-y-4\">\n        <div>\n          <h4 className=\"text-xs font-medium mb-2\">🎯 For AI Development</h4>\n          <div className=\"text-xs text-muted-foreground font-normal space-y-1\">\n            <div>1. Create focused bundles (api, ui, core)</div>\n            <div>2. Hide debug/temp files from bundles</div>\n            <div>3. Copy bundle XML for AI context</div>\n            <div>4. Use Cursor Rules for project context</div>\n          </div>\n        </div>\n\n        <div>\n          <h4 className=\"text-xs font-medium mb-2\">📁 For Project Organization</h4>\n          <div className=\"text-xs text-muted-foreground font-normal space-y-1\">\n            <div>1. Configure ignore patterns for unwanted files</div>\n            <div>2. Create bundles by feature or responsibility</div>\n            <div>3. Use hidden files to trim bundle scope</div>\n            <div>4. Monitor bundle sizes and file counts</div>\n          </div>\n        </div>\n\n        <div>\n          <h4 className=\"text-xs font-medium mb-2\">🤖 For CI/CD Integration</h4>\n          <div className=\"text-xs text-muted-foreground font-normal space-y-1\">\n            <div>1. Use CLI commands in build scripts</div>\n            <div>2. Generate bundles for automated testing</div>\n            <div>3. Export project context for deployment</div>\n          </div>\n        </div>\n      </CardContent>\n    </Card>\n  )\n}\n\n// Installation reminder for new users\nexport function InstallationReminder() {\n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle className=\"text-sm font-medium\">First Time Setup</CardTitle>\n      </CardHeader>\n      <CardContent className=\"space-y-3\">\n        <Alert className=\"border-[color:var(--color-success)]/20 bg-[color:var(--color-success)]/5\">\n          <CheckCircle className=\"w-4 h-4\" />\n          <AlertDescription>\n            <strong>You're all set!</strong> cntx-ui is installed and running.\n            Use this web interface for full functionality.\n          </AlertDescription>\n        </Alert>\n\n        <div className=\"text-xs text-muted-foreground font-normal\">\n          <p className=\"mb-2\"><strong>For new projects:</strong></p>\n          <div className=\"ml-4 space-y-1\">\n            <div>1. Install: <code className=\"bg-muted px-1 rounded\">npm install -g cntx-ui</code></div>\n            <div>2. Initialize: <code className=\"bg-muted px-1 rounded\">cntx-ui init</code></div>\n            <div>3. Start: <code className=\"bg-muted px-1 rounded\">cntx-ui watch</code></div>\n          </div>\n        </div>\n      </CardContent>\n    </Card>\n  )\n}\n\n// Legacy components for backward compatibility\nexport const QuickSetupTips = QuickCliReference\nexport const UsageInstructions = WorkflowInstructions\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/SetupScreen.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"32815\" modified=\"2025-06-26T00:31:31.564Z\" lines=\"666\" />\n        <cntx:content><![CDATA[import { useState } from 'react'\nimport { CheckCircle, Circle, Copy, Monitor, FolderOpen, Settings, ArrowRight, ExternalLink, AlertTriangle, Play, Sparkles, Eye, Zap, Download } from 'lucide-react'\nimport { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card'\nimport { Button } from '@/components/ui/button'\nimport { Badge } from '@/components/ui/badge'\nimport { Alert, AlertDescription } from '@/components/ui/alert'\n\ninterface SetupStep {\n  id: string\n  title: string\n  description: string\n  completed: boolean\n  required: boolean\n}\n\nexport default function SetupScreen() {\n  const [currentStep, setCurrentStep] = useState(0)\n  const [setupSteps, setSetupSteps] = useState<SetupStep[]>([\n    {\n      id: 'welcome',\n      title: 'Welcome to cntx-ui',\n      description: 'Organize your code into focused bundles for AI assistance',\n      completed: false,\n      required: true\n    },\n    {\n      id: 'bundles',\n      title: 'Create Your First Bundles',\n      description: 'Set up focused file collections and learn the basics',\n      completed: false,\n      required: true\n    },\n    {\n      id: 'ai-analysis',\n      title: 'AI Bundle Analysis (Optional)',\n      description: 'Let AI analyze your code and suggest optimal bundles',\n      completed: false,\n      required: false\n    },\n    {\n      id: 'mcp-integration',\n      title: 'MCP Integration (Enhanced)',\n      description: 'Set up seamless AI integration with Claude Desktop',\n      completed: false,\n      required: false\n    },\n    {\n      id: 'workflows',\n      title: 'Choose Your Workflow',\n      description: 'Manual copy/paste or seamless MCP integration',\n      completed: false,\n      required: false\n    }\n  ])\n\n  const [aiPromptCopied, setAiPromptCopied] = useState(false)\n  const [masterBundleCopied, setMasterBundleCopied] = useState(false)\n\n  const copyAiPrompt = async () => {\n    const prompt = `Analyze this codebase bundle and suggest an optimal bundle configuration for cntx-ui.\n\nBased on the file structure and content, recommend 3-6 meaningful bundles with glob patterns that group related files logically.\n\nConsider these common bundle types:\n- Frontend/UI components and pages\n- Backend API routes and controllers  \n- Configuration files\n- Documentation\n- Tests\n- Utilities/helpers\n- Styles/assets\n\nReturn ONLY a JSON configuration in this exact format:\n{\n  \"bundles\": {\n    \"master\": [\"**/*\"],\n    \"frontend\": [\"src/components/**/*\", \"src/pages/**/*\", \"src/hooks/**/*\"],\n    \"api\": [\"src/api/**/*\", \"routes/**/*\", \"controllers/**/*\"],\n    \"config\": [\"*.config.*\", \"package.json\", \"tsconfig.json\"],\n    \"docs\": [\"README.md\", \"docs/**/*\", \"*.md\"],\n    \"tests\": [\"**/*.test.*\", \"**/*.spec.*\", \"__tests__/**/*\"]\n  }\n}\n\nPlease analyze the following master bundle and suggest appropriate bundles:\n\n[PASTE YOUR MASTER BUNDLE XML CONTENT HERE]`\n\n    try {\n      await navigator.clipboard.writeText(prompt)\n      setAiPromptCopied(true)\n      setTimeout(() => setAiPromptCopied(false), 3000)\n    } catch (err) {\n      console.error('Failed to copy AI prompt:', err)\n    }\n  }\n\n  const copyMasterBundle = async () => {\n    try {\n      const response = await fetch('http://localhost:3333/api/bundles/master')\n      if (!response.ok) throw new Error('Failed to fetch master bundle')\n\n      const xmlContent = await response.text()\n      await navigator.clipboard.writeText(xmlContent)\n      setMasterBundleCopied(true)\n      setTimeout(() => setMasterBundleCopied(false), 3000)\n    } catch (err) {\n      console.error('Failed to copy master bundle:', err)\n    }\n  }\n\n  const downloadMasterBundle = async () => {\n    try {\n      const response = await fetch('http://localhost:3333/api/bundles/master')\n      if (!response.ok) throw new Error('Failed to fetch master bundle')\n\n      const xmlContent = await response.text()\n      const blob = new Blob([xmlContent], { type: 'application/xml' })\n      const url = URL.createObjectURL(blob)\n      const a = document.createElement('a')\n      a.href = url\n      a.download = 'master-bundle.xml'\n      a.click()\n      URL.revokeObjectURL(url)\n    } catch (err) {\n      console.error('Failed to download master bundle:', err)\n    }\n  }\n\n  const markStepComplete = (stepId: string) => {\n    setSetupSteps(prev => prev.map(step =>\n      step.id === stepId ? { ...step, completed: true } : step\n    ))\n  }\n\n  const StepIndicator = ({ step, isActive }: { step: SetupStep, isActive: boolean }) => (\n    <div className={`flex items-center gap-3 p-3 rounded-lg transition-colors ${isActive ? 'bg-accent border border-border' : 'hover:bg-muted/50'\n      }`}>\n      <div className=\"flex-shrink-0\">\n        {step.completed ? (\n          <CheckCircle className=\"w-6 h-6 text-[color:var(--color-success)]\" />\n        ) : (\n          <Circle className={`w-6 h-6 ${isActive ? 'text-primary' : 'text-muted-foreground'}`} />\n        )}\n      </div>\n      <div className=\"flex-1\">\n        <div className=\"flex items-center gap-2\">\n          <h3 className={`text-xs font-medium ${isActive ? 'text-foreground' : 'text-foreground'}`}>\n            {step.title}\n          </h3>\n          {step.required && (\n            <Badge variant=\"outline\" className=\"text-xs\">Required</Badge>\n          )}\n        </div>\n        <p className=\"text-xs text-muted-foreground font-normal\">{step.description}</p>\n      </div>\n    </div>\n  )\n\n  return (\n    <div className=\"min-h-screen bg-gradient-to-br from-background to-muted/20\">\n      <div className=\"container mx-auto px-4 py-8\">\n        {/* Header */}\n        <div className=\"text-center mb-8\">\n          <h1 className=\"text-2xl font-normal text-foreground mb-2\">Welcome to cntx-ui</h1>\n          <p className=\"text-sm text-muted-foreground font-normal max-w-2xl mx-auto\">\n            You're already up and running! Let's explore what you can do with the web interface.\n          </p>\n        </div>\n\n        <div className=\"grid lg:grid-cols-3 gap-8 max-w-7xl mx-auto\">\n          {/* Steps Sidebar */}\n          <div className=\"lg:col-span-1\">\n            <Card>\n              <CardHeader>\n                <CardTitle className=\"flex items-center gap-2 text-sm font-medium\">\n                  <Settings className=\"w-4 h-4\" />\n                  Quick Tour\n                </CardTitle>\n              </CardHeader>\n              <CardContent className=\"space-y-2\">\n                {setupSteps.map((step, index) => (\n                  <div\n                    key={step.id}\n                    onClick={() => setCurrentStep(index)}\n                    className=\"cursor-pointer\"\n                  >\n                    <StepIndicator step={step} isActive={currentStep === index} />\n                  </div>\n                ))}\n              </CardContent>\n            </Card>\n          </div>\n\n          {/* Main Content */}\n          <div className=\"lg:col-span-2 space-y-6\">\n            {/* Step 1: Welcome */}\n            {currentStep === 0 && (\n              <Card>\n                <CardHeader>\n                  <CardTitle className=\"flex items-center gap-2 text-sm font-medium\">\n                    <Sparkles className=\"w-4 h-4\" />\n                    Welcome to cntx-ui\n                  </CardTitle>\n                </CardHeader>\n                <CardContent className=\"space-y-6\">\n                  <Alert className=\"border-green-200 bg-green-50\">\n                    <CheckCircle className=\"w-4 h-4\" />\n                    <AlertDescription>\n                      <strong>You're all set!</strong> cntx-ui is running and ready to organize your code for AI assistance.\n                      Start with basic bundle management, then optionally enhance with seamless AI integration.\n                    </AlertDescription>\n                  </Alert>\n\n                  <div className=\"bg-accent/50 p-4 rounded-lg border\">\n                    <h4 className=\"text-xs font-medium text-foreground mb-2\">What is cntx-ui?</h4>\n                    <p className=\"text-xs text-muted-foreground font-normal mb-3\">\n                      cntx-ui organizes your codebase into focused bundles for AI development.\n                      Create meaningful file collections, copy them to AI tools, or use advanced MCP integration for seamless workflows.\n                    </p>\n                    <div className=\"grid grid-cols-2 gap-2 text-xs text-muted-foreground font-normal\">\n                      <div>• Bundle files by purpose or feature</div>\n                      <div>• Hide irrelevant files from AI context</div>\n                      <div>• Copy bundles to any AI tool</div>\n                      <div>• Optional seamless AI integration</div>\n                    </div>\n                  </div>\n\n                  <div className=\"grid md:grid-cols-2 gap-4\">\n                    <Card className=\"border-border\">\n                      <CardContent className=\"pt-6\">\n                        <Monitor className=\"w-8 h-8 text-primary mb-3\" />\n                        <h3 className=\"text-xs font-medium mb-2\">Core Experience</h3>\n                        <p className=\"text-xs text-muted-foreground font-normal\">\n                          Organize bundles in the web interface, copy XML to Claude, ChatGPT, or any AI tool.\n                        </p>\n                        <Badge variant=\"outline\" className=\"mt-2\">Works everywhere</Badge>\n                      </CardContent>\n                    </Card>\n\n                    <Card className=\"border-border\">\n                      <CardContent className=\"pt-6\">\n                        <Zap className=\"w-8 h-8 text-primary mb-3\" />\n                        <h3 className=\"text-xs font-medium mb-2\">Enhanced Experience</h3>\n                        <p className=\"text-xs text-muted-foreground font-normal\">\n                          Optional MCP server integration for seamless access in Claude Desktop and other MCP clients.\n                        </p>\n                        <Badge variant=\"outline\" className=\"mt-2\">Progressive enhancement</Badge>\n                      </CardContent>\n                    </Card>\n                  </div>\n\n                  <div className=\"flex justify-between\">\n                    <Button variant=\"outline\" size=\"sm\" className=\"h-7 text-xs\" disabled>Previous</Button>\n                    <Button onClick={() => { markStepComplete('welcome'); setCurrentStep(1); }} size=\"sm\" className=\"h-7 text-xs\">\n                      Create Your First Bundles <ArrowRight className=\"w-3 h-3 ml-1\" />\n                    </Button>\n                  </div>\n                </CardContent>\n              </Card>\n            )}\n\n            {/* Step 2: Create Bundles */}\n            {currentStep === 1 && (\n              <Card>\n                <CardHeader>\n                  <CardTitle className=\"flex items-center gap-2 text-sm font-medium\">\n                    <FolderOpen className=\"w-4 h-4\" />\n                    Create Your First Bundles\n                  </CardTitle>\n                </CardHeader>\n                <CardContent className=\"space-y-6\">\n                  <div>\n                    <p className=\"text-xs text-muted-foreground font-normal mb-4\">\n                      cntx-ui starts with a \"master\" bundle containing all your files. Let's explore the basics\n                      and learn how to create focused bundles for better AI assistance.\n                    </p>\n\n                    <Alert className=\"border-border bg-accent/50\">\n                      <FolderOpen className=\"w-4 h-4\" />\n                      <AlertDescription>\n                        <strong>✅ You're ready to go!</strong> cntx-ui has already created a master bundle with all your project files.\n                        Now let's organize them into meaningful collections.\n                      </AlertDescription>\n                    </Alert>\n                  </div>\n\n                  <div className=\"bg-accent/50 p-4 rounded-lg border\">\n                    <h4 className=\"text-xs font-medium text-foreground mb-3\">Here's the workflow:</h4>\n                    <ol className=\"text-xs text-muted-foreground font-normal space-y-2 list-decimal list-inside\">\n                      <li><strong>Copy the AI analysis prompt</strong> (button below)</li>\n                      <li><strong>Go to Bundles tab</strong> → Copy the \"master\" bundle XML</li>\n                      <li><strong>Open Claude/ChatGPT</strong> → Paste the prompt</li>\n                      <li><strong>Paste your master bundle XML</strong> after the prompt</li>\n                      <li><strong>AI returns perfect bundle JSON</strong> tailored to your code!</li>\n                      <li><strong>Go to Config tab</strong> → Paste the JSON → Apply!</li>\n                    </ol>\n                  </div>\n\n                  <div>\n                    <h4 className=\"text-xs font-medium mb-2\">Step 1: Copy AI Prompt & Master Bundle</h4>\n                    <div className=\"space-y-3\">\n                      <div className=\"bg-card border rounded-lg p-4\">\n                        <div className=\"flex items-center justify-between mb-2\">\n                          <span className=\"text-primary text-xs\">🤖 Smart Bundle Analysis Prompt</span>\n                          <Button\n                            variant=\"ghost\"\n                            size=\"sm\"\n                            className=\"h-7 text-xs text-muted-foreground hover:text-foreground\"\n                            onClick={copyAiPrompt}\n                          >\n                            {aiPromptCopied ? (\n                              <>\n                                <CheckCircle className=\"w-4 h-4 mr-1\" />\n                                Copied!\n                              </>\n                            ) : (\n                              <>\n                                <Copy className=\"w-4 h-4 mr-1\" />\n                                Copy Prompt\n                              </>\n                            )}\n                          </Button>\n                        </div>\n                        <div className=\"text-muted-foreground text-xs font-normal\">\n                          Intelligent prompt that guides AI to analyze your code structure\n                        </div>\n                      </div>\n\n                      <div className=\"bg-card border rounded-lg p-4\">\n                        <div className=\"flex items-center justify-between mb-2\">\n                          <span className=\"text-primary text-xs\">📦 Master Bundle XML</span>\n                          <div className=\"flex gap-2\">\n                            <Button\n                              variant=\"ghost\"\n                              size=\"sm\"\n                              className=\"h-7 text-xs text-muted-foreground hover:text-foreground\"\n                              onClick={copyMasterBundle}\n                            >\n                              {masterBundleCopied ? (\n                                <>\n                                  <CheckCircle className=\"w-4 h-4 mr-1\" />\n                                  Copied!\n                                </>\n                              ) : (\n                                <>\n                                  <Copy className=\"w-4 h-4 mr-1\" />\n                                  Copy XML\n                                </>\n                              )}\n                            </Button>\n                            <Button\n                              variant=\"ghost\"\n                              size=\"sm\"\n                              className=\"h-7 text-xs text-muted-foreground hover:text-foreground\"\n                              onClick={downloadMasterBundle}\n                            >\n                              <Download className=\"w-4 h-4 mr-1\" />\n                              Download\n                            </Button>\n                          </div>\n                        </div>\n                        <div className=\"text-muted-foreground text-xs font-normal\">\n                          Your complete codebase bundle for AI analysis\n                        </div>\n                      </div>\n                    </div>\n                  </div>\n\n                  <div className=\"bg-accent/50 p-4 rounded-lg border\">\n                    <h4 className=\"text-xs font-medium text-foreground mb-2\">🚀 Complete AI Workflow:</h4>\n                    <ol className=\"text-xs text-muted-foreground font-normal space-y-1 list-decimal list-inside\">\n                      <li><strong>Copy the prompt above</strong> → Paste into Claude/ChatGPT</li>\n                      <li><strong>Copy/download master bundle</strong> → Add to your AI conversation</li>\n                      <li><strong>AI analyzes your code</strong> → Returns perfect bundle configuration</li>\n                      <li><strong>Go to Config tab</strong> → Paste AI's JSON → Apply configuration</li>\n                      <li><strong>🎉 Optimized bundles ready!</strong> → Tailored to your project structure</li>\n                    </ol>\n                  </div>\n\n                  <div className=\"grid md:grid-cols-2 gap-4\">\n                    <div className=\"space-y-3\">\n                      <h4 className=\"text-xs font-medium\">What AI Analyzes:</h4>\n                      <div className=\"text-xs space-y-1 text-muted-foreground font-normal\">\n                        <div>🗂️ <strong>File organization patterns</strong></div>\n                        <div>🔗 <strong>Import/dependency relationships</strong></div>\n                        <div>⚙️ <strong>Technology stack detection</strong></div>\n                        <div>📁 <strong>Logical grouping opportunities</strong></div>\n                      </div>\n                    </div>\n\n                    <div className=\"space-y-3\">\n                      <h4 className=\"text-xs font-medium\">AI Suggests Bundles Like:</h4>\n                      <div className=\"text-xs space-y-1 text-muted-foreground font-normal\">\n                        <div>🎨 <strong>frontend</strong> - Components, pages, styles</div>\n                        <div>🔌 <strong>api</strong> - Routes, controllers, models</div>\n                        <div>🧪 <strong>tests</strong> - All test files</div>\n                        <div>⚙️ <strong>config</strong> - Configuration files</div>\n                      </div>\n                    </div>\n                  </div>\n\n                  <Alert>\n                    <AlertTriangle className=\"w-4 h-4\" />\n                    <AlertDescription>\n                      <strong>Why this works so well:</strong> AI understands code patterns and can see relationships\n                      between files that aren't obvious. It creates bundles that actually make sense for your specific project.\n                    </AlertDescription>\n                  </Alert>\n\n                  <div className=\"flex justify-between\">\n                    <Button variant=\"outline\" size=\"sm\" className=\"h-7 text-xs\" onClick={() => setCurrentStep(0)}>Previous</Button>\n                    <Button onClick={() => { markStepComplete('ai-analysis'); setCurrentStep(2); }} size=\"sm\" className=\"h-7 text-xs\">\n                      Continue to Bundle Management <ArrowRight className=\"w-3 h-3 ml-1\" />\n                    </Button>\n                  </div>\n                </CardContent>\n              </Card>\n            )}\n\n            {/* Step 3: Create/Manage Bundles */}\n            {currentStep === 2 && (\n              <Card>\n                <CardHeader>\n                  <CardTitle className=\"flex items-center gap-2 text-sm font-medium\">\n                    <FolderOpen className=\"w-4 h-4\" />\n                    Create & Manage Your Bundles\n                  </CardTitle>\n                </CardHeader>\n                <CardContent className=\"space-y-6\">\n                  <div>\n                    <p className=\"text-xs text-muted-foreground font-normal mb-4\">\n                      Whether you used AI suggestions or want to create bundles manually,\n                      here's how to manage your bundle collection.\n                    </p>\n\n                    <div className=\"bg-accent/50 p-4 rounded-lg border mb-4\">\n                      <h4 className=\"text-xs font-medium text-foreground mb-2\">If you used AI analysis:</h4>\n                      <ol className=\"text-xs text-muted-foreground font-normal space-y-1 list-decimal list-inside\">\n                        <li>Go to the <strong>Config</strong> tab above</li>\n                        <li>Scroll to <strong>\"Paste Bundle Configuration\"</strong></li>\n                        <li>Paste the AI-generated JSON</li>\n                        <li>Click <strong>\"Apply Configuration\"</strong></li>\n                        <li>🎉 Your optimized bundles are ready!</li>\n                      </ol>\n                    </div>\n\n                    <div className=\"bg-accent/50 p-4 rounded-lg border mb-4\">\n                      <h4 className=\"text-xs font-medium text-foreground mb-2\">To create bundles manually:</h4>\n                      <ol className=\"text-xs text-muted-foreground font-normal space-y-1 list-decimal list-inside\">\n                        <li>Go to the <strong>Config</strong> tab above</li>\n                        <li>Click <strong>\"Add New Bundle\"</strong> at the bottom</li>\n                        <li>Name it something meaningful (e.g., \"frontend\", \"api\", \"core\")</li>\n                        <li>Add patterns like <code className=\"bg-muted px-1 rounded\">src/components/**/*</code></li>\n                        <li>Click <strong>\"Create Bundle\"</strong></li>\n                      </ol>\n                    </div>\n\n                    <Alert>\n                      <Sparkles className=\"w-4 h-4\" />\n                      <AlertDescription>\n                        <strong>Pro tip:</strong> You can test patterns before adding them!\n                        Use the \"Pattern Tester\" in the Config tab to see which files match.\n                      </AlertDescription>\n                    </Alert>\n                  </div>\n\n                  <div className=\"space-y-3\">\n                    <h4 className=\"text-xs font-medium\">Popular Manual Bundle Examples:</h4>\n                    <div className=\"grid gap-3\">\n                      <div className=\"bg-muted/50 p-3 rounded-md border\">\n                        <div className=\"font-medium text-xs\">Frontend Bundle</div>\n                        <code className=\"text-xs text-muted-foreground\">src/components/**/* • src/pages/**/* • *.css</code>\n                      </div>\n                      <div className=\"bg-muted/50 p-3 rounded-md border\">\n                        <div className=\"font-medium text-xs\">API Bundle</div>\n                        <code className=\"text-xs text-muted-foreground\">src/api/**/* • src/routes/**/* • src/models/**/*</code>\n                      </div>\n                      <div className=\"bg-muted/50 p-3 rounded-md border\">\n                        <div className=\"font-medium text-xs\">Tests Bundle</div>\n                        <code className=\"text-xs text-muted-foreground\">**/*.test.* • **/*.spec.* • __tests__/**/*</code>\n                      </div>\n                    </div>\n                  </div>\n\n                  <div className=\"flex justify-between\">\n                    <Button variant=\"outline\" size=\"sm\" className=\"h-7 text-xs\" onClick={() => setCurrentStep(1)}>Previous</Button>\n                    <Button onClick={() => { markStepComplete('bundles'); setCurrentStep(3); }} size=\"sm\" className=\"h-7 text-xs\">\n                      Continue to Optimization <ArrowRight className=\"w-3 h-3 ml-1\" />\n                    </Button>\n                  </div>\n                </CardContent>\n              </Card>\n            )}\n\n            {/* Step 4: Optimization */}\n            {currentStep === 3 && (\n              <Card>\n                <CardHeader>\n                  <CardTitle className=\"flex items-center gap-2 text-sm font-medium\">\n                    <Zap className=\"w-4 h-4\" />\n                    Optimize for AI Development\n                  </CardTitle>\n                </CardHeader>\n                <CardContent className=\"space-y-6\">\n                  <div>\n                    <p className=\"text-xs text-muted-foreground font-normal mb-4\">\n                      Now let's make your bundles perfect for AI assistants by controlling what they see.\n                    </p>\n\n                    <div className=\"grid md:grid-cols-2 gap-4\">\n                      <Card className=\"border-border\">\n                        <CardContent className=\"pt-6\">\n                          <Eye className=\"w-8 h-8 text-primary mb-3\" />\n                          <h3 className=\"text-xs font-medium mb-2\">Hidden Files Tab</h3>\n                          <div className=\"text-xs text-muted-foreground font-normal space-y-1\">\n                            <div>• Hide debug files from AI context</div>\n                            <div>• Remove temp/generated files</div>\n                            <div>• Create clean, focused bundles</div>\n                          </div>\n                        </CardContent>\n                      </Card>\n\n                      <Card className=\"border-border\">\n                        <CardContent className=\"pt-6\">\n                          <Sparkles className=\"w-8 h-8 text-primary mb-3\" />\n                          <h3 className=\"text-xs font-medium mb-2\">Cursor Rules Tab</h3>\n                          <div className=\"text-xs text-muted-foreground font-normal space-y-1\">\n                            <div>• Set coding standards</div>\n                            <div>• Define project context</div>\n                            <div>• Guide AI assistant behavior</div>\n                          </div>\n                        </CardContent>\n                      </Card>\n                    </div>\n                  </div>\n\n                  <div className=\"bg-accent/50 p-4 rounded-lg border\">\n                    <h4 className=\"text-xs font-medium text-foreground mb-2\">Try this workflow:</h4>\n                    <ol className=\"text-xs text-muted-foreground font-normal space-y-1 list-decimal list-inside\">\n                      <li>Go to <strong>Hidden Files</strong> tab</li>\n                      <li>Search for \"debug\" or \"test\" files</li>\n                      <li>Hide them from your main bundles</li>\n                      <li>Go to <strong>Cursor Rules</strong> tab</li>\n                      <li>Choose a template that matches your project</li>\n                      <li>Customize the rules for your team's preferences</li>\n                    </ol>\n                  </div>\n\n                  <Alert>\n                    <AlertTriangle className=\"w-4 h-4\" />\n                    <AlertDescription>\n                      <strong>Why this matters:</strong> Clean bundles = better AI responses.\n                      Removing noise helps AI focus on what's actually important in your code.\n                    </AlertDescription>\n                  </Alert>\n\n                  <div className=\"flex justify-between\">\n                    <Button variant=\"outline\" size=\"sm\" className=\"h-7 text-xs\" onClick={() => setCurrentStep(2)}>Previous</Button>\n                    <Button onClick={() => { markStepComplete('optimization'); setCurrentStep(4); }} size=\"sm\" className=\"h-7 text-xs\">\n                      Continue <ArrowRight className=\"w-3 h-3 ml-1\" />\n                    </Button>\n                  </div>\n                </CardContent>\n              </Card>\n            )}\n\n            {/* Step 5: Workflows */}\n            {currentStep === 4 && (\n              <Card>\n                <CardHeader>\n                  <CardTitle className=\"flex items-center gap-2 text-sm font-medium\">\n                    <Play className=\"w-4 h-4\" />\n                    Common Workflows & Next Steps\n                  </CardTitle>\n                </CardHeader>\n                <CardContent className=\"space-y-6\">\n                  <div className=\"grid gap-4\">\n                    <div className=\"bg-accent/50 p-4 rounded-lg border\">\n                      <h4 className=\"text-xs font-medium text-foreground mb-2\">🤖 Using with AI Assistants</h4>\n                      <div className=\"text-xs text-muted-foreground font-normal space-y-1\">\n                        <div>1. Create a focused bundle for your current task</div>\n                        <div>2. Copy the XML from the <strong>Bundles</strong> tab</div>\n                        <div>3. Paste into Claude, ChatGPT, or other AI tools</div>\n                        <div>4. Get more accurate, context-aware responses</div>\n                      </div>\n                    </div>\n\n                    <div className=\"bg-accent/50 p-4 rounded-lg border\">\n                      <h4 className=\"text-xs font-medium text-foreground mb-2\">📁 Organizing Large Projects</h4>\n                      <div className=\"text-xs text-muted-foreground font-normal space-y-1\">\n                        <div>1. Create bundles by feature or team responsibility</div>\n                        <div>2. Use hidden files to exclude work-in-progress code</div>\n                        <div>3. Monitor bundle sizes in the web interface</div>\n                        <div>4. Share specific bundles with team members</div>\n                      </div>\n                    </div>\n\n                    <div className=\"bg-accent/50 p-4 rounded-lg border\">\n                      <h4 className=\"text-xs font-medium text-foreground mb-2\">⚡ Advanced Tips</h4>\n                      <div className=\"text-xs text-muted-foreground font-normal space-y-1\">\n                        <div>• Bundle-specific hiding: Hide files from specific bundles only</div>\n                        <div>• Pattern testing: Use the pattern tester in Config tab</div>\n                        <div>• Real-time updates: Changes appear immediately</div>\n                        <div>• CLI integration: Use commands for automation</div>\n                      </div>\n                    </div>\n                  </div>\n\n                  <div className=\"bg-accent/50 p-4 rounded-lg border\">\n                    <h4 className=\"text-xs font-medium text-foreground mb-2\">🎯 Quick Start Checklist</h4>\n                    <div className=\"text-xs text-muted-foreground font-normal space-y-1\">\n                      <div>✅ Create 2-3 focused bundles</div>\n                      <div>✅ Hide debug/temp files</div>\n                      <div>✅ Set up cursor rules</div>\n                      <div>✅ Copy a bundle and try it with an AI assistant</div>\n                    </div>\n                  </div>\n\n                  <div className=\"flex justify-between\">\n                    <Button variant=\"outline\" size=\"sm\" className=\"h-7 text-xs\" onClick={() => setCurrentStep(3)}>Previous</Button>\n                    <Button onClick={() => markStepComplete('workflows')} size=\"sm\" className=\"h-7 text-xs bg-primary hover:bg-primary/90\">\n                      Get Started! <ExternalLink className=\"w-3 h-3 ml-1\" />\n                    </Button>\n                  </div>\n                </CardContent>\n              </Card>\n            )}\n\n            {/* Quick Reference Card */}\n            <Card>\n              <CardHeader>\n                <CardTitle className=\"text-sm font-medium\">Quick Reference</CardTitle>\n              </CardHeader>\n              <CardContent>\n                <div className=\"grid md:grid-cols-2 gap-4 text-sm\">\n                  <div>\n                    <h4 className=\"text-xs font-medium mb-2\">Web Interface Tabs</h4>\n                    <ul className=\"space-y-1 text-muted-foreground font-normal\">\n                      <li><strong>Bundles</strong> - View and copy bundle content</li>\n                      <li><strong>Files</strong> - Browse your project files</li>\n                      <li><strong>Config</strong> - Create and edit bundles</li>\n                      <li><strong>Hidden</strong> - Control file visibility</li>\n                      <li><strong>Cursor</strong> - Manage AI assistant rules</li>\n                    </ul>\n                  </div>\n                  <div>\n                    <h4 className=\"text-xs font-medium mb-2\">Key Features</h4>\n                    <ul className=\"space-y-1 text-muted-foreground font-normal\">\n                      <li>Real-time file watching and updates</li>\n                      <li>Bundle-specific file hiding</li>\n                      <li>Pattern testing and validation</li>\n                      <li>AI assistant context management</li>\n                      <li>XML export for AI tools</li>\n                    </ul>\n                  </div>\n                </div>\n              </CardContent>\n            </Card>\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/SimpleBundleConfig.tsx\" ext=\".tsx\" role=\"configuration\">\n        <cntx:meta size=\"9309\" modified=\"2025-06-25T06:33:32.771Z\" lines=\"286\" />\n        <cntx:content><![CDATA[import { useState } from 'react'\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'\nimport { Card, CardHeader, CardTitle, CardContent } from './ui/card'\nimport { Button } from './ui/button'\nimport { Input } from './ui/input'\nimport { Badge } from './ui/badge'\nimport { Plus, Save, Trash2, Eye } from 'lucide-react'\nimport { toast } from '@/lib/toast'\n\ninterface BundleConfig {\n  bundles: Record<string, string[]>\n}\n\nconst fetchConfig = async (): Promise<BundleConfig> => {\n  const response = await fetch('http://localhost:3333/api/config')\n  if (!response.ok) throw new Error('Failed to fetch config')\n  return response.json()\n}\n\nconst saveConfig = async (config: BundleConfig): Promise<void> => {\n  const response = await fetch('http://localhost:3333/api/config', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(config)\n  })\n  if (!response.ok) throw new Error('Failed to save config')\n}\n\nconst testPattern = async (pattern: string): Promise<string[]> => {\n  const response = await fetch('http://localhost:3333/api/test-pattern', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ pattern })\n  })\n  if (!response.ok) throw new Error('Failed to test pattern')\n  return response.json()\n}\n\nexport function SimpleBundleConfig() {\n  const queryClient = useQueryClient()\n  const [editingBundle, setEditingBundle] = useState<string | null>(null)\n  const [newBundleName, setNewBundleName] = useState('')\n  const [showAddBundle, setShowAddBundle] = useState(false)\n  const [testingPattern, setTestingPattern] = useState('')\n  const [testResults, setTestResults] = useState<string[]>([])\n\n  const { data: config, isLoading } = useQuery({\n    queryKey: ['config'],\n    queryFn: fetchConfig\n  })\n\n  const saveMutation = useMutation({\n    mutationFn: saveConfig,\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['config'] })\n      queryClient.invalidateQueries({ queryKey: ['bundles'] })\n      setEditingBundle(null)\n      toast.success('Configuration saved!')\n    },\n    onError: (error) => {\n      toast.error(`Failed to save: ${error.message}`)\n    }\n  })\n\n  const handleSave = () => {\n    if (!config) return\n    saveMutation.mutate(config)\n  }\n\n  const handleAddBundle = () => {\n    if (!config || !newBundleName.trim()) return\n    \n    const updatedConfig = {\n      ...config,\n      bundles: {\n        ...config.bundles,\n        [newBundleName]: ['**/*']\n      }\n    }\n    \n    saveMutation.mutate(updatedConfig)\n    setNewBundleName('')\n    setShowAddBundle(false)\n  }\n\n  const handleDeleteBundle = (bundleName: string) => {\n    if (!config) return\n    \n    const { [bundleName]: deleted, ...remainingBundles } = config.bundles\n    const updatedConfig = {\n      ...config,\n      bundles: remainingBundles\n    }\n    \n    saveMutation.mutate(updatedConfig)\n  }\n\n  const handlePatternChange = (bundleName: string, patterns: string[]) => {\n    if (!config) return\n    \n    const updatedConfig = {\n      ...config,\n      bundles: {\n        ...config.bundles,\n        [bundleName]: patterns\n      }\n    }\n    \n    saveMutation.mutate(updatedConfig)\n  }\n\n  const handleTestPattern = async () => {\n    if (!testingPattern.trim()) return\n    \n    try {\n      const results = await testPattern(testingPattern)\n      setTestResults(results)\n    } catch (error) {\n      toast.error('Failed to test pattern')\n    }\n  }\n\n  if (isLoading) {\n    return <div className=\"p-4\">Loading...</div>\n  }\n\n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle className=\"flex items-center justify-between\">\n          Bundle Configuration\n          <Button\n            onClick={handleSave}\n            disabled={saveMutation.isPending}\n            size=\"sm\"\n          >\n            <Save className=\"w-4 h-4 mr-1\" />\n            Save All\n          </Button>\n        </CardTitle>\n      </CardHeader>\n      <CardContent className=\"space-y-6\">\n        {/* Existing Bundles */}\n        <div className=\"space-y-4\">\n          {config && Object.entries(config.bundles).map(([bundleName, patterns]) => (\n            <div key={bundleName} className=\"border rounded-lg p-4\">\n              <div className=\"flex items-center justify-between mb-3\">\n                <h3 className=\"font-medium\">{bundleName}</h3>\n                <div className=\"flex gap-2\">\n                  <Button\n                    variant=\"outline\"\n                    size=\"sm\"\n                    onClick={() => setEditingBundle(editingBundle === bundleName ? null : bundleName)}\n                  >\n                    {editingBundle === bundleName ? 'Done' : 'Edit'}\n                  </Button>\n                  <Button\n                    variant=\"outline\"\n                    size=\"sm\"\n                    onClick={() => handleDeleteBundle(bundleName)}\n                  >\n                    <Trash2 className=\"w-4 h-4\" />\n                  </Button>\n                </div>\n              </div>\n              \n              {editingBundle === bundleName ? (\n                <div className=\"space-y-2\">\n                  {patterns.map((pattern, index) => (\n                    <div key={index} className=\"flex gap-2\">\n                      <Input\n                        value={pattern}\n                        onChange={(e) => {\n                          const newPatterns = [...patterns]\n                          newPatterns[index] = e.target.value\n                          handlePatternChange(bundleName, newPatterns)\n                        }}\n                        placeholder=\"e.g., src/**/*.ts\"\n                      />\n                      {patterns.length > 1 && (\n                        <Button\n                          variant=\"outline\"\n                          size=\"sm\"\n                          onClick={() => {\n                            const newPatterns = patterns.filter((_, i) => i !== index)\n                            handlePatternChange(bundleName, newPatterns)\n                          }}\n                        >\n                          <Trash2 className=\"w-4 h-4\" />\n                        </Button>\n                      )}\n                    </div>\n                  ))}\n                  <Button\n                    variant=\"outline\"\n                    size=\"sm\"\n                    onClick={() => handlePatternChange(bundleName, [...patterns, '**/*'])}\n                  >\n                    <Plus className=\"w-4 h-4 mr-1\" />\n                    Add Pattern\n                  </Button>\n                </div>\n              ) : (\n                <div className=\"flex flex-wrap gap-1\">\n                  {patterns.map((pattern, index) => (\n                    <Badge key={index} variant=\"secondary\">\n                      {pattern}\n                    </Badge>\n                  ))}\n                </div>\n              )}\n            </div>\n          ))}\n        </div>\n\n        {/* Add New Bundle */}\n        {showAddBundle ? (\n          <div className=\"border rounded-lg p-4 bg-muted/50\">\n            <div className=\"space-y-3\">\n              <Input\n                placeholder=\"Bundle name\"\n                value={newBundleName}\n                onChange={(e) => setNewBundleName(e.target.value)}\n              />\n              <div className=\"flex gap-2\">\n                <Button onClick={handleAddBundle} disabled={!newBundleName.trim()}>\n                  Create Bundle\n                </Button>\n                <Button variant=\"outline\" onClick={() => setShowAddBundle(false)}>\n                  Cancel\n                </Button>\n              </div>\n            </div>\n          </div>\n        ) : (\n          <Button\n            variant=\"outline\"\n            onClick={() => setShowAddBundle(true)}\n            className=\"w-full\"\n          >\n            <Plus className=\"w-4 h-4 mr-1\" />\n            Add New Bundle\n          </Button>\n        )}\n\n        {/* Pattern Tester */}\n        <Card>\n          <CardHeader>\n            <CardTitle>Test a Pattern</CardTitle>\n          </CardHeader>\n          <CardContent className=\"space-y-3\">\n            <div className=\"flex gap-2\">\n              <Input\n                placeholder=\"e.g., src/**/*.ts\"\n                value={testingPattern}\n                onChange={(e) => setTestingPattern(e.target.value)}\n              />\n              <Button onClick={handleTestPattern}>\n                <Eye className=\"w-4 h-4 mr-1\" />\n                Test\n              </Button>\n            </div>\n            \n            {testResults.length > 0 && (\n              <div className=\"mt-3\">\n                <p className=\"text-sm text-muted-foreground mb-2\">\n                  Found {testResults.length} files:\n                </p>\n                <div className=\"max-h-32 overflow-y-auto text-xs space-y-1 bg-muted/50 p-2 rounded\">\n                  {testResults.slice(0, 20).map((file, index) => (\n                    <div key={index}>{file}</div>\n                  ))}\n                  {testResults.length > 20 && (\n                    <div className=\"text-muted-foreground\">\n                      ... and {testResults.length - 20} more files\n                    </div>\n                  )}\n                </div>\n              </div>\n            )}\n          </CardContent>\n        </Card>\n      </CardContent>\n    </Card>\n  )\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/theme-provider.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"392\" modified=\"2025-06-25T03:16:23.069Z\" lines=\"15\" />\n        <cntx:content><![CDATA[// web/src/components/theme-provider.tsx\n\"use client\"\n\nimport { ThemeProvider as NextThemesProvider } from \"next-themes\"\nimport { type ReactNode } from \"react\"\n\ninterface ThemeProviderProps {\n  children: ReactNode\n  [key: string]: unknown\n}\n\nexport function ThemeProvider({ children, ...props }: ThemeProviderProps) {\n  return <NextThemesProvider {...props}>{children}</NextThemesProvider>\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/theme-toggle.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"698\" modified=\"2025-06-25T03:28:29.061Z\" lines=\"25\" />\n        <cntx:content><![CDATA[// web/src/components/theme-toggle.tsx\n\"use client\"\n\nimport { Moon, Sun } from \"lucide-react\"\nimport { useTheme } from \"next-themes\"\n\nimport { Button } from \"@/components/ui/button\"\n\nexport function ThemeToggle() {\n  const { theme, setTheme } = useTheme()\n\n  return (\n    <Button\n      variant=\"ghost\"\n      size=\"sm\"\n      onClick={() => setTheme(theme === \"light\" ? \"dark\" : \"light\")}\n      className=\"h-8 w-8 p-0\"\n    >\n      <Sun className=\"h-4 w-4 rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0\" />\n      <Moon className=\"absolute h-4 w-4 rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100\" />\n      <span className=\"sr-only\">Toggle theme</span>\n    </Button>\n  )\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/alert.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"1614\" modified=\"2025-06-06T23:18:00.618Z\" lines=\"67\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst alertVariants = cva(\n  \"relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-card text-card-foreground\",\n        destructive:\n          \"text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nfunction Alert({\n  className,\n  variant,\n  ...props\n}: React.ComponentProps<\"div\"> & VariantProps<typeof alertVariants>) {\n  return (\n    <div\n      data-slot=\"alert\"\n      role=\"alert\"\n      className={cn(alertVariants({ variant }), className)}\n      {...props}\n    />\n  )\n}\n\nfunction AlertTitle({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"alert-title\"\n      className={cn(\n        \"col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction AlertDescription({\n  className,\n  ...props\n}: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"alert-description\"\n      className={cn(\n        \"text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Alert, AlertTitle, AlertDescription }\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/badge.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"1631\" modified=\"2025-06-06T23:02:18.357Z\" lines=\"47\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst badgeVariants = cva(\n  \"inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90\",\n        secondary:\n          \"border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90\",\n        destructive:\n          \"border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60\",\n        outline:\n          \"text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nfunction Badge({\n  className,\n  variant,\n  asChild = false,\n  ...props\n}: React.ComponentProps<\"span\"> &\n  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {\n  const Comp = asChild ? Slot : \"span\"\n\n  return (\n    <Comp\n      data-slot=\"badge\"\n      className={cn(badgeVariants({ variant }), className)}\n      {...props}\n    />\n  )\n}\n\nexport { Badge, badgeVariants }\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/button.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"2123\" modified=\"2025-06-06T23:02:18.326Z\" lines=\"60\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"bg-primary text-primary-foreground shadow-xs hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60\",\n        outline:\n          \"border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50\",\n        secondary:\n          \"bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80\",\n        ghost:\n          \"hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-9 px-4 py-2 has-[>svg]:px-3\",\n        sm: \"h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5\",\n        lg: \"h-10 rounded-md px-6 has-[>svg]:px-4\",\n        icon: \"size-9\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nfunction Button({\n  className,\n  variant,\n  size,\n  asChild = false,\n  ...props\n}: React.ComponentProps<\"button\"> &\n  VariantProps<typeof buttonVariants> & {\n    asChild?: boolean\n  }) {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      data-slot=\"button\"\n      className={cn(buttonVariants({ variant, size, className }))}\n      {...props}\n    />\n  )\n}\n\nexport { Button, buttonVariants }\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/card.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"1989\" modified=\"2025-06-06T22:59:58.927Z\" lines=\"93\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Card({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card\"\n      className={cn(\n        \"bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction CardHeader({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-header\"\n      className={cn(\n        \"@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction CardTitle({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-title\"\n      className={cn(\"leading-none font-semibold\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction CardDescription({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-description\"\n      className={cn(\"text-muted-foreground text-sm\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction CardAction({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-action\"\n      className={cn(\n        \"col-start-2 row-span-2 row-start-1 self-start justify-self-end\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction CardContent({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-content\"\n      className={cn(\"px-6\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction CardFooter({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-footer\"\n      className={cn(\"flex items-center px-6 [.border-t]:pt-6\", className)}\n      {...props}\n    />\n  )\n}\n\nexport {\n  Card,\n  CardHeader,\n  CardFooter,\n  CardTitle,\n  CardAction,\n  CardDescription,\n  CardContent,\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/input.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"967\" modified=\"2025-06-06T23:18:00.535Z\" lines=\"22\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Input({ className, type, ...props }: React.ComponentProps<\"input\">) {\n  return (\n    <input\n      type={type}\n      data-slot=\"input\"\n      className={cn(\n        \"file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n        \"focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]\",\n        \"aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Input }\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/label.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"597\" modified=\"2025-06-06T23:18:00.593Z\" lines=\"23\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Label({\n  className,\n  ...props\n}: React.ComponentProps<typeof LabelPrimitive.Root>) {\n  return (\n    <LabelPrimitive.Root\n      data-slot=\"label\"\n      className={cn(\n        \"flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Label }\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/select.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"4353\" modified=\"2025-06-25T16:14:36.394Z\" lines=\"118\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\nimport * as SelectPrimitive from \"@radix-ui/react-select\"\nimport { Check, ChevronDown } from \"lucide-react\"\nimport { cn } from \"@/lib/utils\"\n\nconst Select = SelectPrimitive.Root\n\nconst SelectGroup = SelectPrimitive.Group\n\nconst SelectValue = SelectPrimitive.Value\n\nconst SelectTrigger = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <SelectPrimitive.Icon asChild>\n      <ChevronDown className=\"h-4 w-4 opacity-50\" />\n    </SelectPrimitive.Icon>\n  </SelectPrimitive.Trigger>\n))\nSelectTrigger.displayName = SelectPrimitive.Trigger.displayName\n\nconst SelectContent = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>\n>(({ className, children, position = \"popper\", ...props }, ref) => (\n  <SelectPrimitive.Portal>\n    <SelectPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"relative z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n        position === \"popper\" &&\n          \"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1\",\n        className\n      )}\n      position={position}\n      {...props}\n    >\n      <SelectPrimitive.Viewport\n        className={cn(\n          \"p-1\",\n          position === \"popper\" &&\n            \"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]\"\n        )}\n      >\n        {children}\n      </SelectPrimitive.Viewport>\n    </SelectPrimitive.Content>\n  </SelectPrimitive.Portal>\n))\nSelectContent.displayName = SelectPrimitive.Content.displayName\n\nconst SelectLabel = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Label\n    ref={ref}\n    className={cn(\"py-1.5 pl-8 pr-2 text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nSelectLabel.displayName = SelectPrimitive.Label.displayName\n\nconst SelectItem = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <SelectPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </SelectPrimitive.ItemIndicator>\n    </span>\n\n    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>\n  </SelectPrimitive.Item>\n))\nSelectItem.displayName = SelectPrimitive.Item.displayName\n\nconst SelectSeparator = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nSelectSeparator.displayName = SelectPrimitive.Separator.displayName\n\nexport {\n  Select,\n  SelectGroup,\n  SelectValue,\n  SelectTrigger,\n  SelectContent,\n  SelectLabel,\n  SelectItem,\n  SelectSeparator,\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/sonner.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"1193\" modified=\"2025-06-25T06:26:50.021Z\" lines=\"36\" />\n        <cntx:content><![CDATA[import { useTheme } from \"next-themes\"\nimport { Toaster as Sonner, type ToasterProps } from \"sonner\"\n\nconst Toaster = ({ ...props }: ToasterProps) => {\n  const { theme = \"system\" } = useTheme()\n\n  return (\n    <Sonner\n      theme={theme as ToasterProps[\"theme\"]}\n      className=\"toaster group\"\n      style={\n        {\n          \"--normal-bg\": \"var(--popover)\",\n          \"--normal-text\": \"var(--popover-foreground)\",\n          \"--normal-border\": \"var(--border)\",\n          \"--success-bg\": \"var(--color-success)\",\n          \"--success-text\": \"var(--color-success-foreground)\",\n          \"--success-border\": \"var(--color-success)\",\n          \"--error-bg\": \"var(--destructive)\",\n          \"--error-text\": \"var(--destructive-foreground)\",\n          \"--error-border\": \"var(--destructive)\",\n          \"--info-bg\": \"var(--color-info)\",\n          \"--info-text\": \"var(--color-info-foreground)\",\n          \"--info-border\": \"var(--color-info)\",\n          \"--warning-bg\": \"var(--color-warning)\",\n          \"--warning-text\": \"var(--color-warning-foreground)\",\n          \"--warning-border\": \"var(--color-warning)\",\n        } as React.CSSProperties\n      }\n      {...props}\n    />\n  )\n}\n\nexport { Toaster }\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/tabs.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"1955\" modified=\"2025-06-06T22:59:58.902Z\" lines=\"65\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\nimport * as TabsPrimitive from \"@radix-ui/react-tabs\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Tabs({\n  className,\n  ...props\n}: React.ComponentProps<typeof TabsPrimitive.Root>) {\n  return (\n    <TabsPrimitive.Root\n      data-slot=\"tabs\"\n      className={cn(\"flex flex-col gap-2\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction TabsList({\n  className,\n  ...props\n}: React.ComponentProps<typeof TabsPrimitive.List>) {\n  return (\n    <TabsPrimitive.List\n      data-slot=\"tabs-list\"\n      className={cn(\n        \"bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction TabsTrigger({\n  className,\n  ...props\n}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {\n  return (\n    <TabsPrimitive.Trigger\n      data-slot=\"tabs-trigger\"\n      className={cn(\n        \"data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction TabsContent({\n  className,\n  ...props\n}: React.ComponentProps<typeof TabsPrimitive.Content>) {\n  return (\n    <TabsPrimitive.Content\n      data-slot=\"tabs-content\"\n      className={cn(\"flex-1 outline-none\", className)}\n      {...props}\n    />\n  )\n}\n\nexport { Tabs, TabsList, TabsTrigger, TabsContent }\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/textarea.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"759\" modified=\"2025-06-06T23:18:00.602Z\" lines=\"19\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Textarea({ className, ...props }: React.ComponentProps<\"textarea\">) {\n  return (\n    <textarea\n      data-slot=\"textarea\"\n      className={cn(\n        \"border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Textarea }\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/toast.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"5236\" modified=\"2025-06-25T15:29:16.823Z\" lines=\"132\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\nimport * as ToastPrimitives from \"@radix-ui/react-toast\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { X } from \"lucide-react\"\nimport { cn } from \"@/lib/utils\"\n\nconst toastVariants = cva(\n  \"group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full\",\n  {\n    variants: {\n      variant: {\n        default: \"border bg-background text-foreground\",\n        destructive:\n          \"destructive border-destructive bg-destructive text-destructive-foreground\",\n        success:\n          \"border-[color:var(--color-success)]/20 bg-[color:var(--color-success)]/5 text-[color:var(--color-success)]\",\n        warning:\n          \"border-[color:var(--color-warning)]/20 bg-[color:var(--color-warning)]/5 text-[color:var(--color-warning)]\",\n        info:\n          \"border-[color:var(--color-info)]/20 bg-[color:var(--color-info)]/5 text-[color:var(--color-info)]\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nconst ToastProvider = ToastPrimitives.Provider\n\nconst ToastViewport = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Viewport>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Viewport\n    ref={ref}\n    className={cn(\n      \"fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]\",\n      className\n    )}\n    {...props}\n  />\n))\nToastViewport.displayName = ToastPrimitives.Viewport.displayName\n\nconst Toast = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Root>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &\n    VariantProps<typeof toastVariants>\n>(({ className, variant, ...props }, ref) => {\n  return (\n    <ToastPrimitives.Root\n      ref={ref}\n      className={cn(toastVariants({ variant }), className)}\n      {...props}\n    />\n  )\n})\nToast.displayName = ToastPrimitives.Root.displayName\n\nconst ToastAction = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Action>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Action\n    ref={ref}\n    className={cn(\n      \"inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive\",\n      className\n    )}\n    {...props}\n  />\n))\nToastAction.displayName = ToastPrimitives.Action.displayName\n\nconst ToastClose = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Close>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Close\n    ref={ref}\n    className={cn(\n      \"absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600\",\n      className\n    )}\n    toast-close=\"\"\n    {...props}\n  >\n    <X className=\"h-4 w-4\" />\n  </ToastPrimitives.Close>\n))\nToastClose.displayName = ToastPrimitives.Close.displayName\n\nconst ToastTitle = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Title>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Title\n    ref={ref}\n    className={cn(\"text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nToastTitle.displayName = ToastPrimitives.Title.displayName\n\nconst ToastDescription = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Description>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Description\n    ref={ref}\n    className={cn(\"text-sm opacity-90\", className)}\n    {...props}\n  />\n))\nToastDescription.displayName = ToastPrimitives.Description.displayName\n\ntype ToastProps = React.ComponentPropsWithoutRef<typeof Toast>\n\ntype ToastActionElement = React.ReactElement<typeof ToastAction>\n\nexport {\n  type ToastProps,\n  type ToastActionElement,\n  ToastProvider,\n  ToastViewport,\n  Toast,\n  ToastAction,\n  ToastClose,\n  ToastTitle,\n  ToastDescription,\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/toaster.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"771\" modified=\"2025-06-25T15:29:30.977Z\" lines=\"33\" />\n        <cntx:content><![CDATA[import {\n  Toast,\n  ToastClose,\n  ToastDescription,\n  ToastProvider,\n  ToastTitle,\n  ToastViewport,\n} from \"@/components/ui/toast\"\nimport { useToast } from \"@/hooks/use-toast\"\n\nexport function Toaster() {\n  const { toasts } = useToast()\n\n  return (\n    <ToastProvider>\n      {toasts.map(function ({ id, title, description, action, ...props }) {\n        return (\n          <Toast key={id} {...props}>\n            <div className=\"grid gap-1\">\n              {title && <ToastTitle>{title}</ToastTitle>}\n              {description && (\n                <ToastDescription>{description}</ToastDescription>\n              )}\n            </div>\n            {action}\n            <ToastClose />\n          </Toast>\n        )\n      })}\n      <ToastViewport />\n    </ToastProvider>\n  )\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/utils/buttonHelpers.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"987\" modified=\"2025-06-25T06:22:12.459Z\" lines=\"28\" />\n        <cntx:content><![CDATA[// utils/buttonHelpers.tsx\nimport { Loader2, CheckCircle, AlertCircle } from 'lucide-react'\nimport type { ButtonState } from '../hooks/useButtonFeedback'\n\nexport function getButtonIcon(state: ButtonState, defaultIcon: React.ReactNode) {\n  switch (state) {\n    case 'loading':\n      return <Loader2 className=\"w-4 h-4 animate-spin\" />\n    case 'success':\n      return <CheckCircle className=\"w-4 h-4 text-[color:var(--color-success)]\" />\n    case 'error':\n      return <AlertCircle className=\"w-4 h-4 text-destructive\" />\n    default:\n      return defaultIcon\n  }\n}\n\nexport function getButtonClassName(state: ButtonState, baseClassName = '') {\n  const stateClasses = {\n    loading: 'opacity-75',\n    success: 'border-[color:var(--color-success)]/50 bg-[color:var(--color-success)]/5 text-[color:var(--color-success)]',\n    error: 'border-destructive/50 bg-destructive/5 text-destructive',\n    idle: ''\n  }\n\n  return `transition-all duration-200 ${baseClassName} ${stateClasses[state]}`\n}\n]]></cntx:content>\n      </cntx:file>\n    </cntx:group>\n    <cntx:group type=\"hooks\" description=\"Custom React hooks and state management\">\n      <cntx:file path=\"web/src/hooks/use-toast.ts\" ext=\".ts\">\n        <cntx:meta size=\"3890\" modified=\"2025-06-25T15:26:00.144Z\" lines=\"190\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\nimport type {\n  ToastActionElement,\n  ToastProps,\n} from \"@/components/ui/toast\"\n\nconst TOAST_LIMIT = 3\nconst TOAST_REMOVE_DELAY = 5000\n\ntype ToasterToast = ToastProps & {\n  id: string\n  title?: React.ReactNode\n  description?: React.ReactNode\n  action?: ToastActionElement\n}\n\nconst actionTypes = {\n  ADD_TOAST: \"ADD_TOAST\",\n  UPDATE_TOAST: \"UPDATE_TOAST\",\n  DISMISS_TOAST: \"DISMISS_TOAST\",\n  REMOVE_TOAST: \"REMOVE_TOAST\",\n} as const\n\nlet count = 0\n\nfunction genId() {\n  count = (count + 1) % Number.MAX_SAFE_INTEGER\n  return count.toString()\n}\n\ntype ActionType = typeof actionTypes\n\ntype Action =\n  | {\n      type: ActionType[\"ADD_TOAST\"]\n      toast: ToasterToast\n    }\n  | {\n      type: ActionType[\"UPDATE_TOAST\"]\n      toast: Partial<ToasterToast>\n    }\n  | {\n      type: ActionType[\"DISMISS_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n  | {\n      type: ActionType[\"REMOVE_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n\ninterface State {\n  toasts: ToasterToast[]\n}\n\nconst toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()\n\nconst addToRemoveQueue = (toastId: string) => {\n  if (toastTimeouts.has(toastId)) {\n    return\n  }\n\n  const timeout = setTimeout(() => {\n    toastTimeouts.delete(toastId)\n    dispatch({\n      type: \"REMOVE_TOAST\",\n      toastId: toastId,\n    })\n  }, TOAST_REMOVE_DELAY)\n\n  toastTimeouts.set(toastId, timeout)\n}\n\nexport const reducer = (state: State, action: Action): State => {\n  switch (action.type) {\n    case \"ADD_TOAST\":\n      return {\n        ...state,\n        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),\n      }\n\n    case \"UPDATE_TOAST\":\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === action.toast.id ? { ...t, ...action.toast } : t\n        ),\n      }\n\n    case \"DISMISS_TOAST\": {\n      const { toastId } = action\n\n      // ! Side effects ! - This could be extracted into a dismissToast() action,\n      // but I'll keep it here for simplicity\n      if (toastId) {\n        addToRemoveQueue(toastId)\n      } else {\n        state.toasts.forEach((toast) => {\n          addToRemoveQueue(toast.id)\n        })\n      }\n\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === toastId || toastId === undefined\n            ? {\n                ...t,\n                open: false,\n              }\n            : t\n        ),\n      }\n    }\n    case \"REMOVE_TOAST\":\n      if (action.toastId === undefined) {\n        return {\n          ...state,\n          toasts: [],\n        }\n      }\n      return {\n        ...state,\n        toasts: state.toasts.filter((t) => t.id !== action.toastId),\n      }\n  }\n}\n\nconst listeners: Array<(state: State) => void> = []\n\nlet memoryState: State = { toasts: [] }\n\nfunction dispatch(action: Action) {\n  memoryState = reducer(memoryState, action)\n  listeners.forEach((listener) => {\n    listener(memoryState)\n  })\n}\n\ntype Toast = Omit<ToasterToast, \"id\">\n\nfunction toast({ ...props }: Toast) {\n  const id = genId()\n\n  const update = (props: ToasterToast) =>\n    dispatch({\n      type: \"UPDATE_TOAST\",\n      toast: { ...props, id },\n    })\n  const dismiss = () => dispatch({ type: \"DISMISS_TOAST\", toastId: id })\n\n  dispatch({\n    type: \"ADD_TOAST\",\n    toast: {\n      ...props,\n      id,\n      open: true,\n      onOpenChange: (open) => {\n        if (!open) dismiss()\n      },\n    },\n  })\n\n  return {\n    id: id,\n    dismiss,\n    update,\n  }\n}\n\nfunction useToast() {\n  const [state, setState] = React.useState<State>(memoryState)\n\n  React.useEffect(() => {\n    listeners.push(setState)\n    return () => {\n      const index = listeners.indexOf(setState)\n      if (index > -1) {\n        listeners.splice(index, 1)\n      }\n    }\n  }, [state])\n\n  return {\n    ...state,\n    toast,\n    dismiss: (toastId?: string) => dispatch({ type: \"DISMISS_TOAST\", toastId }),\n  }\n}\n\nexport { useToast, toast }]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/hooks/useButtonFeedback.ts\" ext=\".ts\">\n        <cntx:meta size=\"1123\" modified=\"2025-06-07T01:43:23.151Z\" lines=\"42\" />\n        <cntx:content><![CDATA[// hooks/useButtonFeedback.ts\nimport { useState } from 'react'\n\nexport type ButtonState = 'idle' | 'loading' | 'success' | 'error'\n\nexport function useButtonFeedback() {\n  const [buttonStates, setButtonStates] = useState<Record<string, ButtonState>>(\n    {}\n  )\n\n  const setButtonState = (key: string, state: ButtonState) => {\n    setButtonStates((prev) => ({ ...prev, [key]: state }))\n\n    // Auto-clear success/error states\n    if (state === 'success') {\n      setTimeout(() => {\n        setButtonStates((prev) => ({ ...prev, [key]: 'idle' }))\n      }, 2000)\n    } else if (state === 'error') {\n      setTimeout(() => {\n        setButtonStates((prev) => ({ ...prev, [key]: 'idle' }))\n      }, 3000)\n    }\n  }\n\n  const getButtonState = (key: string): ButtonState => {\n    return buttonStates[key] || 'idle'\n  }\n\n  const isLoading = (key: string) => getButtonState(key) === 'loading'\n  const isSuccess = (key: string) => getButtonState(key) === 'success'\n  const isError = (key: string) => getButtonState(key) === 'error'\n\n  return {\n    setButtonState,\n    getButtonState,\n    isLoading,\n    isSuccess,\n    isError,\n  }\n}\n]]></cntx:content>\n      </cntx:file>\n    </cntx:group>\n    <cntx:group type=\"utilities\" description=\"Helper functions, utilities, and shared libraries\">\n      <cntx:file path=\"web/src/lib/toast.ts\" ext=\".ts\">\n        <cntx:meta size=\"709\" modified=\"2025-06-25T06:31:06.099Z\" lines=\"32\" />\n        <cntx:content><![CDATA[import { toast as baseToast } from \"@/hooks/use-toast\"\n\nexport const toast = {\n  success: (message: string, description?: string) => {\n    return baseToast({\n      variant: \"success\",\n      title: message,\n      description,\n    })\n  },\n  error: (message: string, description?: string) => {\n    return baseToast({\n      variant: \"destructive\",\n      title: message,\n      description,\n    })\n  },\n  info: (message: string, description?: string) => {\n    return baseToast({\n      variant: \"info\",\n      title: message,\n      description,\n    })\n  },\n  warning: (message: string, description?: string) => {\n    return baseToast({\n      variant: \"warning\", \n      title: message,\n      description,\n    })\n  },\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/lib/utils.ts\" ext=\".ts\">\n        <cntx:meta size=\"166\" modified=\"2025-06-06T22:59:49.030Z\" lines=\"7\" />\n        <cntx:content><![CDATA[import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n]]></cntx:content>\n      </cntx:file>\n    </cntx:group>\n    <cntx:group type=\"configuration\" description=\"Configuration files, settings, and build configs\">\n      <cntx:file path=\"mcp-config-example.json\" ext=\".json\" role=\"configuration\">\n        <cntx:meta size=\"129\" modified=\"2025-06-18T12:09:04.597Z\" lines=\"9\" />\n        <cntx:content><![CDATA[{\n  \"mcpServers\": {\n    \"cntx-ui\": {\n      \"command\": \"cntx-ui\",\n      \"args\": [\"mcp\"],\n      \"cwd\": \"{{projectDir}}\"\n    }\n  }\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"package.json\" ext=\".json\" role=\"package-config\">\n        <cntx:meta size=\"1451\" modified=\"2025-06-26T18:47:25.767Z\" lines=\"60\" />\n        <cntx:content><![CDATA[{\n  \"name\": \"cntx-ui\",\n  \"type\": \"module\",\n  \"version\": \"2.0.12\",\n  \"description\": \"File context management tool with web UI and MCP server for AI development workflows - bundle project files for LLM consumption\",\n  \"keywords\": [\n    \"ai-development\",\n    \"mcp-server\",\n    \"file-bundling\",\n    \"context-management\",\n    \"llm-tools\",\n    \"claude-desktop\",\n    \"model-context-protocol\",\n    \"file-aggregation\",\n    \"project-context\",\n    \"ai-workflow\",\n    \"codebase-bundling\",\n    \"development-tools\",\n    \"websocket\",\n    \"react\",\n    \"cli-tool\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/nothingdao/cntx-ui.git\"\n  },\n  \"author\": \"whaleen\",\n  \"license\": \"MIT\",\n  \"bin\": {\n    \"cntx-ui\": \"./bin/cntx-ui.js\"\n  },\n  \"files\": [\n    \"bin/cntx-ui.js\",\n    \"server.js\",\n    \"lib/\",\n    \"README.md\",\n    \"web/dist\",\n    \"mcp-config-example.json\"\n  ],\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  },\n  \"scripts\": {\n    \"dev\": \"node server.js\",\n    \"build\": \"cd web && npm install && npm run build\",\n    \"build:web\": \"cd web && npm install && npm run build\",\n    \"dev:web\": \"cd web && npm run dev\",\n    \"prebuild\": \"npm run build:web\",\n    \"prepublishOnly\": \"npm run build:web\",\n    \"test:local\": \"npm pack && npm install -g ./cntx-ui-2.0.0.tgz\"\n  },\n  \"dependencies\": {\n    \"glob\": \"^8.1.0\",\n    \"tree-sitter\": \"^0.21.1\",\n    \"tree-sitter-javascript\": \"^0.23.1\",\n    \"tree-sitter-typescript\": \"^0.23.2\",\n    \"ws\": \"^8.13.0\"\n  }\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"test-mcp.json\" ext=\".json\">\n        <cntx:meta size=\"153\" modified=\"2025-06-25T01:57:16.148Z\" lines=\"1\" />\n        <cntx:content><![CDATA[{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"initialize\",\"params\":{\"protocolVersion\":\"2024-11-05\",\"capabilities\":{},\"clientInfo\":{\"name\":\"test\",\"version\":\"1.0.0\"}}}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/eslint.config.js\" ext=\".js\" role=\"configuration\">\n        <cntx:meta size=\"734\" modified=\"2025-06-06T22:55:53.330Z\" lines=\"29\" />\n        <cntx:content><![CDATA[import js from '@eslint/js'\nimport globals from 'globals'\nimport reactHooks from 'eslint-plugin-react-hooks'\nimport reactRefresh from 'eslint-plugin-react-refresh'\nimport tseslint from 'typescript-eslint'\n\nexport default tseslint.config(\n  { ignores: ['dist'] },\n  {\n    extends: [js.configs.recommended, ...tseslint.configs.recommended],\n    files: ['**/*.{ts,tsx}'],\n    languageOptions: {\n      ecmaVersion: 2020,\n      globals: globals.browser,\n    },\n    plugins: {\n      'react-hooks': reactHooks,\n      'react-refresh': reactRefresh,\n    },\n    rules: {\n      ...reactHooks.configs.recommended.rules,\n      'react-refresh/only-export-components': [\n        'warn',\n        { allowConstantExport: true },\n      ],\n    },\n  },\n)\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/package.json\" ext=\".json\" role=\"package-config\">\n        <cntx:meta size=\"1218\" modified=\"2025-06-25T16:13:53.050Z\" lines=\"46\" />\n        <cntx:content><![CDATA[{\n  \"name\": \"web\",\n  \"private\": true,\n  \"version\": \"0.0.0\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"vite\",\n    \"build\": \"tsc -b && vite build\",\n    \"lint\": \"eslint .\",\n    \"preview\": \"vite preview\"\n  },\n  \"dependencies\": {\n    \"@radix-ui/react-label\": \"^2.1.7\",\n    \"@radix-ui/react-select\": \"^2.2.5\",\n    \"@radix-ui/react-slot\": \"^1.2.3\",\n    \"@radix-ui/react-tabs\": \"^1.1.12\",\n    \"@radix-ui/react-toast\": \"^1.2.14\",\n    \"@tailwindcss/vite\": \"^4.1.8\",\n    \"@tanstack/react-query\": \"^5.80.6\",\n    \"class-variance-authority\": \"^0.7.1\",\n    \"clsx\": \"^2.1.1\",\n    \"lucide-react\": \"^0.513.0\",\n    \"next-themes\": \"^0.4.6\",\n    \"react\": \"^19.1.0\",\n    \"react-dom\": \"^19.1.0\",\n    \"sonner\": \"^2.0.5\",\n    \"tailwind-merge\": \"^3.3.0\",\n    \"tailwindcss\": \"^4.1.8\"\n  },\n  \"devDependencies\": {\n    \"@eslint/js\": \"^9.25.0\",\n    \"@types/node\": \"^22.15.30\",\n    \"@types/react\": \"^19.1.2\",\n    \"@types/react-dom\": \"^19.1.2\",\n    \"@vitejs/plugin-react\": \"^4.4.1\",\n    \"eslint\": \"^9.25.0\",\n    \"eslint-plugin-react-hooks\": \"^5.2.0\",\n    \"eslint-plugin-react-refresh\": \"^0.4.19\",\n    \"globals\": \"^16.0.0\",\n    \"tw-animate-css\": \"^1.3.4\",\n    \"typescript\": \"~5.8.3\",\n    \"typescript-eslint\": \"^8.30.1\",\n    \"vite\": \"^6.3.5\"\n  }\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/tsconfig.json\" ext=\".json\" role=\"configuration\">\n        <cntx:meta size=\"214\" modified=\"2025-06-06T22:58:20.358Z\" lines=\"14\" />\n        <cntx:content><![CDATA[{\n  \"files\": [],\n  \"references\": [\n    { \"path\": \"./tsconfig.app.json\" },\n    { \"path\": \"./tsconfig.node.json\" }\n  ],\n   \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/*\": [\"./src/*\"]\n    }\n  }\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/tsconfig.node.json\" ext=\".json\" role=\"configuration\">\n        <cntx:meta size=\"598\" modified=\"2025-06-07T02:03:31.047Z\" lines=\"25\" />\n        <cntx:content><![CDATA[{\n  \"compilerOptions\": {\n    \"tsBuildInfoFile\": \"./node_modules/.tmp/tsconfig.node.tsbuildinfo\",\n    \"target\": \"ES2022\",\n    \"lib\": [\"ES2023\"],\n    \"module\": \"ESNext\",\n    \"skipLibCheck\": true,\n\n    /* Bundler mode */\n    \"moduleResolution\": \"bundler\",\n    \"allowImportingTsExtensions\": true,\n    \"verbatimModuleSyntax\": true,\n    \"moduleDetection\": \"force\",\n    \"noEmit\": true,\n\n    /* Linting */\n    \"strict\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"noUncheckedSideEffectImports\": true\n  },\n  \"include\": [\"vite.config.ts\"]\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/vite.config.ts\" ext=\".ts\" role=\"configuration\">\n        <cntx:meta size=\"833\" modified=\"2025-06-07T02:03:25.557Z\" lines=\"36\" />\n        <cntx:content><![CDATA[import path from 'path'\nimport tailwindcss from '@tailwindcss/vite'\nimport react from '@vitejs/plugin-react'\nimport { defineConfig } from 'vite'\n\n// https://vite.dev/config/\nexport default defineConfig({\n  plugins: [react(), tailwindcss()],\n  base: './', // Important: Use relative paths for serving from any location\n  build: {\n    outDir: 'dist',\n    assetsDir: 'assets',\n    sourcemap: false, // Reduce bundle size\n    rollupOptions: {\n      output: {\n        manualChunks: undefined, // Keep everything in one chunk for simplicity\n      },\n    },\n  },\n  resolve: {\n    alias: {\n      '@': path.resolve(__dirname, './src'),\n    },\n  },\n  server: {\n    port: 5173,\n    proxy: {\n      // Proxy API calls during development\n      '/api': {\n        target: 'http://localhost:3333',\n        changeOrigin: true,\n      },\n    },\n  },\n})\n]]></cntx:content>\n      </cntx:file>\n    </cntx:group>\n    <cntx:group type=\"tests\" description=\"Test files and testing utilities\">\n      <cntx:file path=\"temp_treesitter_test.js\" ext=\".js\">\n        <cntx:meta size=\"731\" modified=\"2025-06-26T19:44:21.169Z\" lines=\"24\" />\n        <cntx:content><![CDATA[import Parser from 'tree-sitter';\nimport JavaScript from 'tree-sitter-javascript';\n\nasync function runTest() {\n  const parser = new Parser();\n  parser.setLanguage(JavaScript);\n\n  const sourceCode = 'function add(a, b) { return a + b; }';\n  const tree = parser.parse(sourceCode);\n  const rootNode = tree.rootNode;\n\n  console.log('Root Node Type:', rootNode.type);\n  console.log('Root Node Text:', rootNode.text);\n  console.log('Root Node hasError():', rootNode.hasError());\n\n  // Try to access a child node\n  const functionNode = rootNode.namedChild(0);\n  if (functionNode) {\n    console.log('Function Node Type:', functionNode.type);\n    console.log('Function Node Text:', functionNode.text);\n  }\n}\n\nrunTest().catch(console.error);]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"test-chunker.mjs\" ext=\".mjs\">\n        <cntx:meta size=\"1772\" modified=\"2025-06-26T00:50:45.006Z\" lines=\"46\" />\n        <cntx:content><![CDATA[import SemanticChunker from './lib/semantic-chunker.js';\n\nconst chunker = new SemanticChunker();\n\nconsole.log('🔍 Analyzing web/src directory for semantic chunks...\\n');\n\ntry {\n  const result = await chunker.analyzeProject('.', ['web/src/**/*.{js,jsx,ts,tsx}']);\n  \n  console.log('=== PROJECT ANALYSIS RESULTS ===\\n');\n  \n  // Show summary stats\n  console.log(`📊 Analysis Summary:`);\n  console.log(`- Total files analyzed: ${result.totalFiles}`);\n  console.log(`- File types found: ${Object.keys(result.fileTypes).join(', ')}`);\n  console.log(`- Semantic chunks identified: ${result.chunks.length}`);\n  console.log(`- Total functions found: ${result.totalFunctions}`);\n  console.log(`- Total exports found: ${result.totalExports}\\n`);\n  \n  // Show chunks\n  console.log('📦 Semantic Chunks:');\n  result.chunks.forEach((chunk, i) => {\n    console.log(`\\n${i + 1}. ${chunk.name} (${chunk.files.length} files)`);\n    console.log(`   Purpose: ${chunk.purpose}`);\n    console.log(`   Files: ${chunk.files.slice(0, 3).join(', ')}${chunk.files.length > 3 ? '...' : ''}`);\n  });\n  \n  // Show some interesting files\n  console.log('\\n🎯 Interesting Files:');\n  result.files.slice(0, 5).forEach(file => {\n    console.log(`\\n📄 ${file.path}`);\n    console.log(`   Type: ${file.fileType}`);\n    console.log(`   Functions: ${file.functions.length}`);\n    console.log(`   Exports: ${file.exports.length}`);\n    console.log(`   Lines: ${file.complexity.lines}`);\n    if (file.reactComponents.length > 0) {\n      console.log(`   React Components: ${file.reactComponents.join(', ')}`);\n    }\n    if (file.hooks.length > 0) {\n      console.log(`   Hooks: ${file.hooks.join(', ')}`);\n    }\n  });\n  \n} catch (error) {\n  console.error('❌ Error analyzing project:', error.message);\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"test-complexity.js\" ext=\".js\">\n        <cntx:meta size=\"494\" modified=\"2025-06-26T21:29:03.269Z\" lines=\"12\" />\n        <cntx:content><![CDATA[import SemanticSplitter from './lib/semantic-splitter.js';\n\nconst splitter = new SemanticSplitter();\nconst result = await splitter.extractSemanticChunks('.', ['web/src/App.tsx']);\n\nconsole.log('Sample complexity scores:');\nresult.chunks.slice(0, 5).forEach(chunk => {\n  console.log(`- ${chunk.name}: ${chunk.complexity.score} (${chunk.complexity.level})`);\n  console.log(`  Size: ${chunk.size} chars`);\n  console.log(`  Code preview: ${chunk.code.substring(0, 100)}...`);\n  console.log('');\n});]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"test-local.sh\" ext=\".sh\">\n        <cntx:meta size=\"2975\" modified=\"2025-06-07T02:05:09.889Z\" lines=\"134\" />\n        <cntx:content><![CDATA[#!/bin/bash\n\n# test-local.sh - Script to test cntx-ui locally before publishing\n\nset -e\n\necho \"🧪 Testing cntx-ui locally...\"\n\n# Create a temporary test directory\nTEST_DIR=\"/tmp/cntx-ui-test-$(date +%s)\"\necho \"📁 Creating test directory: $TEST_DIR\"\nmkdir -p \"$TEST_DIR\"\n\n# Create a simple test project\ncd \"$TEST_DIR\"\necho \"📝 Creating test project files...\"\n\n# Create package.json\ncat > package.json << 'EOF'\n{\n  \"name\": \"test-project\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"echo 'dev script'\"\n  }\n}\nEOF\n\n# Create some test files\nmkdir -p src/components src/api docs\necho \"export const hello = 'world'\" > src/index.js\necho \"export const Component = () => <div>Hello</div>\" > src/components/App.jsx\necho \"export const api = () => 'api'\" > src/api/routes.js\necho \"# Test Project\" > README.md\necho \"# Documentation\" > docs/guide.md\n\necho \"✅ Test project created with files:\"\nfind . -type f -name \"*.js\" -o -name \"*.jsx\" -o -name \"*.json\" -o -name \"*.md\" | sort\n\n# Initialize cntx-ui\necho \"🚀 Initializing cntx-ui...\"\ncntx-ui init\n\n# Check if files were created\necho \"🔍 Checking generated files...\"\nif [ -f \".cntx/config.json\" ]; then\n    echo \"✅ Config file created\"\n    cat .cntx/config.json\nelse\n    echo \"❌ Config file not created\"\n    exit 1\nfi\n\nif [ -f \".cntxignore\" ]; then\n    echo \"✅ Ignore file created\"\nelse\n    echo \"❌ Ignore file not created\"\n    exit 1\nfi\n\nif [ -f \".cursorrules\" ]; then\n    echo \"✅ Cursor rules created\"\nelse\n    echo \"❌ Cursor rules not created\"\n    exit 1\nfi\n\n# Test bundle generation\necho \"📦 Testing bundle generation...\"\ncntx-ui bundle master\n\nif [ -f \".cntx/bundles.json\" ]; then\n    echo \"✅ Bundles generated\"\nelse\n    echo \"❌ Bundles not generated\"\n    exit 1\nfi\n\n# Test status command\necho \"📊 Testing status command...\"\ncntx-ui status\n\n# Start server in background and test web interface\necho \"🌐 Testing web server...\"\necho \"Starting server on port 8899...\"\n\n# Kill any existing process on port 8899\nlsof -ti:8899 | xargs kill -9 2>/dev/null || true\n\n# Start server in background\ncntx-ui watch 8899 &\nSERVER_PID=$!\n\n# Wait for server to start\nsleep 3\n\n# Test API endpoints\necho \"🔌 Testing API endpoints...\"\n\n# Test bundles endpoint\nif curl -s http://localhost:8899/api/bundles > /dev/null; then\n    echo \"✅ API endpoint working\"\nelse\n    echo \"❌ API endpoint not working\"\n    kill $SERVER_PID 2>/dev/null\n    exit 1\nfi\n\n# Test web interface\nif curl -s http://localhost:8899/ | grep -q \"cntx-ui\"; then\n    echo \"✅ Web interface accessible\"\nelse\n    echo \"⚠️  Web interface not available (this is OK if web wasn't built)\"\nfi\n\n# Stop server\necho \"🛑 Stopping server...\"\nkill $SERVER_PID 2>/dev/null || true\n\n# Cleanup\necho \"🧹 Cleaning up...\"\ncd /\nrm -rf \"$TEST_DIR\"\n\necho \"\"\necho \"🎉 All tests passed!\"\necho \"✅ cntx-ui is working correctly\"\necho \"\"\necho \"🚀 Ready to publish!\"\necho \"   Run: npm publish\"\necho \"   Or: npm publish --tag beta\"\necho \"\"\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"test-treesitter.mjs\" ext=\".mjs\">\n        <cntx:meta size=\"2881\" modified=\"2025-06-26T16:28:57.720Z\" lines=\"67\" />\n        <cntx:content><![CDATA[import TreesitterSemanticChunker from './lib/treesitter-semantic-chunker.js';\n\nconst chunker = new TreesitterSemanticChunker({\n  namingStrategy: 'domain-based'\n});\n\nconsole.log('🚀 TREESITTER SEMANTIC CHUNKING TEST');\nconsole.log('====================================\\n');\n\nconsole.log('🔍 Testing treesitter-based analysis...\\n');\n\ntry {\n  const result = await chunker.analyzeProject('.', ['web/src/**/*.{js,jsx,ts,tsx}']);\n  \n  // Project Overview\n  console.log('📊 PROJECT OVERVIEW');\n  console.log(`📁 Files analyzed: ${result.summary.totalFiles}`);\n  console.log(`📦 Semantic chunks created: ${result.summary.totalChunks}`);\n  console.log(`💾 Total code size: ${Math.round(result.summary.totalSize / 1024)}KB`);\n  console.log(`📏 Total lines of code: ${result.summary.totalLines.toLocaleString()}`);\n  \n  // Semantic Types\n  console.log('\\n🎯 SEMANTIC TYPES');\n  Object.entries(result.summary.semanticTypes).forEach(([type, count]) => {\n    console.log(`   ${type}: ${count} files`);\n  });\n  \n  // Business Domains  \n  console.log('\\n🏢 BUSINESS DOMAINS');\n  Object.entries(result.summary.businessDomains).forEach(([domain, count]) => {\n    console.log(`   ${domain}: ${count} occurrences`);\n  });\n  \n  // Technical Patterns\n  console.log('\\n⚙️ TECHNICAL PATTERNS');\n  Object.entries(result.summary.technicalPatterns).forEach(([pattern, count]) => {\n    console.log(`   ${pattern}: ${count} files`);\n  });\n  \n  // Smart Chunks\n  console.log('\\n🧩 SMART SEMANTIC CHUNKS');\n  console.log('==========================');\n  result.chunks.forEach((chunk, i) => {\n    console.log(`\\n${i + 1}. 📦 ${chunk.name.toUpperCase()}`);\n    console.log(`   📊 ${chunk.files.length} files | ${Math.round(chunk.size / 1024)}KB | ${chunk.purpose}`);\n    console.log(`   🎯 Cohesion: ${chunk.cohesion.toFixed(2)} | Complexity: ${chunk.complexity.level}`);\n    console.log(`   🏢 Domains: ${chunk.businessDomains.join(', ') || 'none'}`);\n    console.log(`   ⚙️ Patterns: ${chunk.technicalPatterns.join(', ') || 'none'}`);\n    console.log(`   📁 Files: ${chunk.files.slice(0, 3).map(f => f.split('/').pop()).join(', ')}${chunk.files.length > 3 ? `... +${chunk.files.length - 3} more` : ''}`);\n    \n    if (chunk.recommendations.length > 0) {\n      console.log(`   💡 ${chunk.recommendations[0].message}`);\n    }\n  });\n  \n  console.log('\\n✨ TREESITTER ANALYSIS COMPLETE!');\n  console.log('=================================');\n  console.log('🚀 Treesitter provides deeper semantic understanding');\n  console.log('🧠 Smart clustering based on AST analysis');\n  console.log('🎯 Business domain extraction from code structure');\n  console.log('📊 Technical pattern recognition');\n  console.log('🔗 Dependency relationship mapping');\n  \n} catch (error) {\n  console.error('❌ Treesitter analysis failed:', error.message);\n  console.error(error.stack);\n}]]></cntx:content>\n      </cntx:file>\n    </cntx:group>\n    <cntx:group type=\"documentation\" description=\"README files, docs, and guides\">\n      <cntx:file path=\"README.md\" ext=\".md\" role=\"documentation\">\n        <cntx:meta size=\"8016\" modified=\"2025-06-25T02:56:05.734Z\" lines=\"372\" />\n        <cntx:content><![CDATA[# cntx-ui\n\nMinimal file bundling and tagging tool for AI development with web interface.\n\n## Features\n\n- File bundling and organization for AI development workflows\n- Web-based UI for managing bundles and configurations\n- **Model Context Protocol (MCP) server** for AI integration\n- Hidden files management\n- Cursor rules integration\n- WebSocket-based real-time updates\n- CLI tools for automation\n\n## Installation\n\n### Global Installation (Recommended)\n\n```bash\nnpm install -g cntx-ui\n```\n\n### Local Development Installation\n\n```bash\ngit clone https://github.com/nothingdao/cntx-ui.git\ncd cntx-ui\nnpm install\n```\n\n## Usage\n\n### Initialize a Project\n\n```bash\n# Initialize cntx-ui in your project\ncntx-ui init\n\n# Start the web interface\ncntx-ui watch\n\n# Visit http://localhost:3333 to access the web UI\n```\n\n### CLI Commands\n\n```bash\n# Generate bundles\ncntx-ui bundle <name>\n\n# Check project status\ncntx-ui status\n\n# Start web server on custom port\ncntx-ui watch [port]\n\n# Start web server with MCP status tracking\ncntx-ui watch --with-mcp\n\n# Start MCP server for AI integration\ncntx-ui mcp\n\n# Add project to Claude Desktop MCP configuration\ncntx-ui setup-mcp\n```\n\n### MCP Integration\n\ncntx-ui can function as an MCP (Model Context Protocol) server, providing AI tools with direct access to your project bundles:\n\n```bash\n# Start MCP server\ncntx-ui mcp\n```\n\n**Available MCP Resources:**\n- `cntx://bundle/<name>` - Access any bundle as XML content\n- `cntx://file/<path>` - Access individual project files\n\n**Available MCP Tools:**\n- `list_bundles` - List all available bundles\n- `get_bundle` - Retrieve specific bundle content  \n- `generate_bundle` - Regenerate a bundle\n- `get_file_tree` - Get project file structure\n- `get_project_status` - Get current project status\n\n## Development\n\n### Prerequisites\n\n- Node.js >= 18.0.0\n- npm\n\n### Setup Development Environment\n\n1. **Clone and install dependencies:**\n   ```bash\n   git clone https://github.com/nothingdao/cntx-ui.git\n   cd cntx-ui\n   npm install\n   ```\n\n2. **Install web dependencies:**\n   ```bash\n   cd web\n   npm install\n   cd ..\n   ```\n\n### Development Workflow\n\n#### Running in Development Mode\n\n1. **Start the backend server:**\n   ```bash\n   npm run dev\n   ```\n\n2. **Start the frontend development server:**\n   ```bash\n   npm run dev:web\n   ```\n   \n   The web interface will be available at `http://localhost:5173` (Vite dev server)\n\n#### Building the Project\n\n1. **Build web interface only:**\n   ```bash\n   npm run build:web\n   ```\n\n2. **Build entire project:**\n   ```bash\n   npm run build\n   ```\n\n3. **Automated build with validation:**\n   ```bash\n   ./build.sh\n   ```\n\n### Project Structure\n\n```\ncntx-ui/\n├── bin/                    # CLI executable\n├── web/                    # React frontend\n│   ├── src/\n│   │   ├── components/     # React components\n│   │   ├── hooks/          # Custom hooks\n│   │   ├── utils/          # Utility functions\n│   │   └── lib/            # Libraries and configurations\n│   ├── dist/               # Built frontend (generated)\n│   └── package.json        # Frontend dependencies\n├── server.js               # WebSocket server\n├── package.json            # Main package configuration\n├── build.sh                # Build automation script\n└── test-local.sh           # Local testing script\n```\n\n### Available Scripts\n\n| Script | Description |\n|--------|-------------|\n| `npm run dev` | Start backend server |\n| `npm run dev:web` | Start frontend dev server |\n| `npm run build` | Build entire project |\n| `npm run build:web` | Build frontend only |\n| `npm test:local` | Install and test package locally |\n\n## MCP Server Setup\n\n### Quick Setup with setup-mcp Command\n\nThe easiest way to configure cntx-ui for Claude Desktop:\n\n```bash\n# Navigate to your project directory\ncd /path/to/your/project\n\n# Initialize cntx-ui if not already done\ncntx-ui init\n\n# Add this project to Claude Desktop MCP configuration\ncntx-ui setup-mcp\n```\n\nThis automatically adds your project to Claude Desktop's configuration file and allows you to work with multiple projects simultaneously.\n\n### Claude Desktop Integration\n\n#### Multi-Project Setup (Recommended)\n\nYou can use cntx-ui across multiple projects by running `setup-mcp` in each project directory:\n\n```bash\n# Project 1\ncd /Users/you/project1\ncntx-ui setup-mcp\n\n# Project 2  \ncd /Users/you/project2\ncntx-ui setup-mcp\n```\n\nThis creates entries in your Claude Desktop config (`~/Library/Application Support/Claude/claude_desktop_config.json`):\n\n```json\n{\n  \"mcpServers\": {\n    \"cntx-ui-project1\": {\n      \"command\": \"sh\",\n      \"args\": [\"-c\", \"cd /Users/you/project1 && node /path/to/cntx-ui/bin/cntx-ui.js mcp\"],\n      \"cwd\": \"/Users/you/project1\"\n    },\n    \"cntx-ui-project2\": {\n      \"command\": \"sh\", \n      \"args\": [\"-c\", \"cd /Users/you/project2 && node /path/to/cntx-ui/bin/cntx-ui.js mcp\"],\n      \"cwd\": \"/Users/you/project2\"\n    }\n  }\n}\n```\n\n#### Manual Configuration\n\nFor manual setup, add to your Claude Desktop configuration:\n\n```json\n{\n  \"mcpServers\": {\n    \"cntx-ui-projectname\": {\n      \"command\": \"sh\",\n      \"args\": [\"-c\", \"cd /path/to/your/project && cntx-ui mcp\"],\n      \"cwd\": \"/path/to/your/project\"\n    }\n  }\n}\n```\n\n### Other MCP Clients\n\nFor other MCP-compatible clients, use:\n- **Command**: `cntx-ui mcp`\n- **Transport**: stdio\n- **Working Directory**: Your project root\n\n### MCP Workflow\n\n1. **Setup**: Run `cntx-ui setup-mcp` in each project you want to use with Claude Desktop\n2. **Visual Configuration**: Use `cntx-ui watch` to configure bundles via web UI\n3. **AI Integration**: AI clients connect via MCP to access bundles across all configured projects\n4. **Real-time Updates**: Changes in web UI immediately available to AI tools\n5. **Multi-Project**: Claude Desktop can access bundles from all configured projects simultaneously\n\n## Testing\n\n### Local Testing\n\n1. **Run automated test suite:**\n   ```bash\n   ./test-local.sh\n   ```\n\n2. **Manual testing:**\n   ```bash\n   # Build and pack\n   npm run build\n   npm pack\n   \n   # Install globally for testing\n   npm install -g ./cntx-ui-*.tgz\n   \n   # Test in a new project\n   mkdir test-project && cd test-project\n   cntx-ui init\n   cntx-ui watch\n   ```\n\n### Test Coverage\n\nThe test suite covers:\n- Project initialization\n- Bundle generation\n- Web server functionality\n- API endpoints\n- File management operations\n\n## Publishing\n\n### Prerequisites for Publishing\n\n- npm account with publish permissions\n- Clean git working directory\n- All tests passing\n\n### Publishing Steps\n\n1. **Update version:**\n   ```bash\n   npm version patch  # or minor/major\n   ```\n\n2. **Build and validate:**\n   ```bash\n   ./build.sh\n   ```\n\n3. **Test locally:**\n   ```bash\n   ./test-local.sh\n   ```\n\n4. **Publish to npm:**\n   ```bash\n   # Stable release\n   npm publish\n   \n   # Beta release\n   npm publish --tag beta\n   ```\n\n### Automated Publishing Workflow\n\nUse the build script for a complete workflow:\n\n```bash\n./build.sh\n# Follow prompts for local testing\n# If tests pass, run: npm publish\n```\n\n## Configuration\n\n### Environment Variables\n\n- `PORT` - Override default server port (default: 3333)\n- `NODE_ENV` - Set environment (development/production)\n\n### Project Configuration\n\ncntx-ui creates these files in your project:\n- `.cntx/config.json` - Main configuration\n- `.cntxignore` - Files to ignore\n- `.cursorrules` - Cursor editor rules\n\n## Contributing\n\n1. Fork the repository\n2. Create a feature branch\n3. Make changes following the existing code style\n4. Run tests: `./test-local.sh`\n5. Submit a pull request\n\n## Technology Stack\n\n- **Backend:** Node.js, WebSocket (ws)\n- **Frontend:** React 19, TypeScript, Vite\n- **UI:** Tailwind CSS, Radix UI\n- **State Management:** TanStack Query\n- **Build Tools:** Vite, TypeScript compiler\n\n## License\n\nMIT\n\n## Support\n\n- GitHub Issues: [Report bugs or request features](https://github.com/nothingdao/cntx-ui/issues)\n- Documentation: Check the web interface for detailed usage guides\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"VISION.md\" ext=\".md\">\n        <cntx:meta size=\"3524\" modified=\"2025-06-26T16:23:26.175Z\" lines=\"111\" />\n        <cntx:content><![CDATA[We're building the interface layer between human mental models and machine understanding of codebases.\n\n## The Complete Knowledge Graph\n\nWhat we're really creating is a traversable knowledge graph for AI agents:\n\n```\n// The full context system an AI agent can navigate:\n{\n  project: {\n    fileTree: rawFileStructure,           // Raw filesystem\n    bundles: humanDefinedCollections,     // Explicit human organization\n    chunks: aiDiscoveredPatterns,         // Machine-learned semantic groups\n    aiRules: contextualInstructions,      // How to work with this code\n    metadata: projectUnderstanding        // What this codebase \"does\"\n  }\n}\n```\n\n## Multi-Layer Understanding System\n\nLayer 1: Raw Structure (File Tree)\n\n- Physical organization\n- What files exist, where they are\n\nLayer 2: Human Intent (Bundles)\n\n- \"These files should be considered together\"\n- Explicit human curation for specific purposes\n\nLayer 3: Machine Discovery (Semantic Chunks)\n\n- \"These files naturally cluster together\"\n- AI-discovered relationships and patterns\n\nLayer 4: Working Instructions (AI Rules + Context)\n\n- \"When working on X, consider Y\"\n- How to navigate and modify the code effectively\n\n## The Human ↔ Machine Interface\n\nThis becomes a bidirectional translation layer:\n\nHuman → Machine:\n\n- \"I'm working on authentication\" → AI gets auth chunks + related bundles +\n  security rules\n- \"This is an e-commerce app\" → AI understands domain context for better\n  suggestions\n- \"These files are related\" → Creates explicit bundle relationships\n\nMachine → Human:\n\n- AI discovers \"payment processing is tightly coupled across 12 files\"\n- AI suggests \"these utility functions could be shared between features\"\n- AI provides \"here's what your codebase is primarily about\" overview\n\nOngoing Repository Intelligence\n\nAs the tool runs continuously, it builds living documentation:\n\n```\n// Repository understanding that evolves:\n{\n  codebasePersonality: {\n    primaryPurpose: \"E-commerce platform with React frontend\",\n    architecturalPatterns: [\"feature-based organization\", \"custom hooks\npattern\"],\n    complexityHotspots: [\"payment processing\", \"user authentication\"],\n    evolutionTrends: [\"moving from REST to GraphQL\", \"adding TypeScript\ngradually\"]\n  },\n\n  workingMemory: {\n    recentChanges: \"Auth system refactored last week\",\n    emergingPatterns: \"New utilities being created for form handling\",\n    maintenanceNeeds: \"Several components showing high complexity\"\n  }\n}\n```\n\n## The \"What Is This Codebase About?\" Dashboard\n\nUsers get a high-level strategic view:\n\n- Semantic Map: Visual representation of chunks and relationships\n- Complexity Overview: Where the hard problems live\n- Evolution Tracking: How the code is changing over time\n- AI Recommendations: Suggested improvements and organizational changes\n- Context Preparation: Pre-built knowledge packages for different types of AI\n  assistance\n\nThis creates a self-documenting, AI-optimized codebase where both humans and\nmachines can quickly understand:\n\n1. What this code does\n2. How it's organized\n3. Where to make changes\n4. How different parts relate\n5. What context an AI agent needs to help effectively\n\nThe tool becomes the source of truth for codebase understanding, continuously\nlearning and improving its model of the project while giving humans control\nover the organizational principles.\n\nThis is exactly the kind of human-AI collaboration interface that will become\nessential as codebases get more complex and AI assistance becomes more\nsophisticated.\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/README.md\" ext=\".md\" role=\"documentation\">\n        <cntx:meta size=\"1942\" modified=\"2025-06-06T22:55:53.329Z\" lines=\"55\" />\n        <cntx:content><![CDATA[# React + TypeScript + Vite\n\nThis template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.\n\nCurrently, two official plugins are available:\n\n- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh\n- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh\n\n## Expanding the ESLint configuration\n\nIf you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:\n\n```js\nexport default tseslint.config({\n  extends: [\n    // Remove ...tseslint.configs.recommended and replace with this\n    ...tseslint.configs.recommendedTypeChecked,\n    // Alternatively, use this for stricter rules\n    ...tseslint.configs.strictTypeChecked,\n    // Optionally, add this for stylistic rules\n    ...tseslint.configs.stylisticTypeChecked,\n  ],\n  languageOptions: {\n    // other options...\n    parserOptions: {\n      project: ['./tsconfig.node.json', './tsconfig.app.json'],\n      tsconfigRootDir: import.meta.dirname,\n    },\n  },\n})\n```\n\nYou can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:\n\n```js\n// eslint.config.js\nimport reactX from 'eslint-plugin-react-x'\nimport reactDom from 'eslint-plugin-react-dom'\n\nexport default tseslint.config({\n  plugins: {\n    // Add the react-x and react-dom plugins\n    'react-x': reactX,\n    'react-dom': reactDom,\n  },\n  rules: {\n    // other rules...\n    // Enable its recommended typescript rules\n    ...reactX.configs['recommended-typescript'].rules,\n    ...reactDom.configs.recommended.rules,\n  },\n})\n```\n]]></cntx:content>\n      </cntx:file>\n    </cntx:group>\n    <cntx:group type=\"other\" description=\"Additional project files\">\n      <cntx:file path=\"bin/cntx-ui-mcp.sh\" ext=\".sh\">\n        <cntx:meta size=\"106\" modified=\"2025-06-25T02:01:20.530Z\" lines=\"3\" />\n        <cntx:content><![CDATA[#!/bin/bash\n# Wrapper script to run cntx-ui MCP server in current directory\ncd \"$(pwd)\" && npx cntx-ui mcp]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"bin/cntx-ui.js\" ext=\".js\">\n        <cntx:meta size=\"1928\" modified=\"2025-06-25T02:46:24.504Z\" lines=\"74\" />\n        <cntx:content><![CDATA[#!/usr/bin/env node\n\nimport { startServer, startMCPServer, generateBundle, initConfig, getStatus, setupMCP } from '../server.js';\n\nconst args = process.argv.slice(2);\nconst command = args[0] || 'watch';\n\n// Graceful shutdown\nprocess.on('SIGINT', () => {\n  console.log('\\n👋 Shutting down cntx-ui...');\n  process.exit(0);\n});\n\nswitch (command) {\n  case 'watch':\n    const port = parseInt(args[1]) || 3333;\n    const withMcp = args.includes('--with-mcp');\n    startServer({ port, withMcp });\n    break;\n\n  case 'mcp':\n    // MCP server mode - runs on stdio\n    startMCPServer({ cwd: process.cwd() });\n    break;\n\n  case 'bundle':\n    const bundleName = args[1] || 'master';\n    try {\n      generateBundle(bundleName);\n      console.log(`✅ Bundle '${bundleName}' generated`);\n    } catch (e) {\n      console.error(`❌ Bundle '${bundleName}' not found`);\n    }\n    break;\n\n  case 'init':\n    initConfig();\n    break;\n\n  case 'status':\n    getStatus();\n    break;\n\n  case 'setup-mcp':\n    setupMCP();\n    break;\n\n  default:\n    console.log(`cntx-ui v2.0.8\n        \nUsage:\n  cntx-ui init                Initialize configuration\n  cntx-ui watch [port]        Start web server (default port: 3333)\n  cntx-ui watch --with-mcp    Start web server with MCP status tracking\n  cntx-ui mcp                 Start MCP server (stdio transport)\n  cntx-ui setup-mcp           Add this project to Claude Desktop MCP config\n  cntx-ui bundle [name]       Generate specific bundle (default: master)\n  cntx-ui status              Show current status\n  \nExamples:\n  cntx-ui init\n  cntx-ui watch 8080\n  cntx-ui watch --with-mcp\n  cntx-ui setup-mcp\n  cntx-ui mcp\n  cntx-ui bundle api\n\nMCP Usage:\n  The MCP server provides AI-accessible bundle management:\n  - Resources: Access bundles and files via cntx:// URIs\n  - Tools: List bundles, generate bundles, get project status\n  - Integration: Use with Claude Desktop, Cursor, or other MCP clients`);\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"build.sh\" ext=\".sh\">\n        <cntx:meta size=\"2029\" modified=\"2025-06-07T02:04:41.966Z\" lines=\"83\" />\n        <cntx:content><![CDATA[#!/bin/bash\n\n# build.sh - Script to build and test cntx-ui with web interface\n\nset -e  # Exit on any error\n\necho \"🏗️  Building cntx-ui with web interface...\"\n\n# Check if we're in the right directory\nif [ ! -f \"package.json\" ] || [ ! -d \"web\" ]; then\n    echo \"❌ Error: Please run this script from the cntx-ui root directory\"\n    exit 1\nfi\n\n# Clean previous builds\necho \"🧹 Cleaning previous builds...\"\nrm -rf web/dist\nrm -rf *.tgz\n\n# Install root dependencies\necho \"📦 Installing root dependencies...\"\nnpm install\n\n# Build web interface\necho \"🌐 Building web interface...\"\ncd web\nnpm install\nnpm run build\ncd ..\n\n# Verify build\nif [ ! -d \"web/dist\" ]; then\n    echo \"❌ Error: Web build failed - dist directory not found\"\n    exit 1\nfi\n\necho \"✅ Web interface built successfully\"\necho \"📁 Files in web/dist:\"\nls -la web/dist/\n\n# Test build locally\necho \"🧪 Testing local build...\"\nnpm pack\n\n# Get the package file name\nPACKAGE_FILE=$(ls cntx-ui-*.tgz | head -n 1)\n\nif [ -z \"$PACKAGE_FILE\" ]; then\n    echo \"❌ Error: Package file not found\"\n    exit 1\nfi\n\necho \"📦 Created package: $PACKAGE_FILE\"\necho \"📏 Package size: $(du -h $PACKAGE_FILE | cut -f1)\"\n\n# Optional: Test install locally\nread -p \"🤔 Test install locally? (y/N): \" -n 1 -r\necho\nif [[ $REPLY =~ ^[Yy]$ ]]; then\n    echo \"🔧 Installing locally for testing...\"\n    npm install -g ./$PACKAGE_FILE\n    \n    echo \"✅ Installed! Test with:\"\n    echo \"   mkdir test-project && cd test-project\"\n    echo \"   cntx-ui init\"\n    echo \"   cntx-ui watch\"\n    echo \"   # Then visit http://localhost:3333\"\nfi\n\necho \"\"\necho \"🎉 Build complete!\"\necho \"\"\necho \"📋 Next steps:\"\necho \"   1. Test the package locally (if not done above)\"\necho \"   2. If everything works, publish with: npm publish\"\necho \"   3. Or publish as beta: npm publish --tag beta\"\necho \"\"\necho \"🔍 To test in another project:\"\necho \"   mkdir /tmp/test-project && cd /tmp/test-project\"\necho \"   npm install -g $PWD/$PACKAGE_FILE\"\necho \"   cntx-ui init && cntx-ui watch\"\necho \"\"\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"debug-chunker-fields.mjs\" ext=\".mjs\">\n        <cntx:meta size=\"1032\" modified=\"2025-06-26T16:44:44.392Z\" lines=\"29\" />\n        <cntx:content><![CDATA[import TreesitterSemanticChunker from './lib/treesitter-semantic-chunker.js';\n\nconst chunker = new TreesitterSemanticChunker();\n\nconsole.log('🔍 Debugging treesitter chunker fields...');\n\ntry {\n  const result = await chunker.analyzeProject('.', ['web/src/App.tsx']);\n  \n  console.log('\\n📄 File Analysis Sample:');\n  const firstFile = Object.values(result.files)[0];\n  console.log('businessDomain:', firstFile.businessDomain);\n  console.log('technicalPatterns:', firstFile.technicalPatterns);\n  console.log('semanticType:', firstFile.semanticType);\n  \n  if (result.chunks.length > 0) {\n    console.log('\\n📦 First Chunk:');\n    const chunk = result.chunks[0];\n    console.log('name:', chunk.name);\n    console.log('businessDomains:', chunk.businessDomains);\n    console.log('technicalPatterns:', chunk.technicalPatterns);\n    console.log('cohesion:', chunk.cohesion);\n    console.log('All chunk keys:', Object.keys(chunk));\n  }\n  \n} catch (error) {\n  console.error('❌ Error:', error.message);\n  console.error(error.stack);\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"debug-chunker.mjs\" ext=\".mjs\">\n        <cntx:meta size=\"1141\" modified=\"2025-06-26T00:53:06.601Z\" lines=\"38\" />\n        <cntx:content><![CDATA[import SemanticChunker from './lib/semantic-chunker.js';\n\nconst chunker = new SemanticChunker();\n\nconsole.log('🔍 Running full analysis...\\n');\n\ntry {\n  // Run the full analysis\n  const result = await chunker.analyzeProject('.', ['web/src/**/*.{js,jsx,ts,tsx}']);\n  \n  console.log('✅ Full analysis completed!');\n  console.log('Result keys:', Object.keys(result));\n  \n  if (result.summary) {\n    console.log('\\n📊 Summary:', {\n      totalFiles: result.summary.totalFiles,\n      totalChunks: result.summary.totalChunks,\n      totalSize: result.summary.totalSize\n    });\n  }\n  \n  if (result.chunks && result.chunks.length > 0) {\n    console.log('\\n📦 First few chunks:');\n    result.chunks.slice(0, 3).forEach((chunk, i) => {\n      console.log(`${i + 1}. ${chunk.name} (${chunk.files?.length || 0} files)`);\n    });\n  }\n  \n  if (result.files) {\n    const fileKeys = Object.keys(result.files);\n    console.log(`\\n📄 Analyzed ${fileKeys.length} files`);\n    console.log('First few files:', fileKeys.slice(0, 3));\n  }\n  \n} catch (error) {\n  console.error('❌ Error during full analysis:', error.message);\n  console.error(error.stack);\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"debug-server-call.mjs\" ext=\".mjs\">\n        <cntx:meta size=\"1023\" modified=\"2025-06-26T16:45:06.782Z\" lines=\"31\" />\n        <cntx:content><![CDATA[import TreesitterSemanticChunker from './lib/treesitter-semantic-chunker.js';\n\nconst chunker = new TreesitterSemanticChunker({\n  namingStrategy: 'domain-based',\n  includeImports: true,\n  includeExports: true,\n  detectComponentTypes: true,\n  groupRelatedFiles: true\n});\n\nconsole.log('🔍 Debugging server-style call...');\n\ntry {\n  // Use same patterns as server\n  const patterns = ['web/src/**/*.{js,jsx,ts,tsx}', 'src/**/*.{js,jsx,ts,tsx}'];\n  const result = await chunker.analyzeProject(process.cwd(), patterns);\n  \n  console.log('\\n📦 Chunks from server-style call:');\n  result.chunks.slice(0, 2).forEach((chunk, i) => {\n    console.log(`${i + 1}. ${chunk.name}`);\n    console.log('   businessDomains:', chunk.businessDomains);\n    console.log('   technicalPatterns:', chunk.technicalPatterns);\n    console.log('   cohesion:', chunk.cohesion);\n    console.log('   keys:', Object.keys(chunk));\n    console.log('');\n  });\n  \n} catch (error) {\n  console.error('❌ Error:', error.message);\n  console.error(error.stack);\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"examples/claude-mcp-setup.sh\" ext=\".sh\">\n        <cntx:meta size=\"1380\" modified=\"2025-06-25T02:21:03.315Z\" lines=\"45\" />\n        <cntx:content><![CDATA[#!/bin/bash\n# Copy this script to your project root and run it to set up cntx-ui MCP for Claude Desktop\n\nPROJECT_DIR=\"$(pwd)\"\nPROJECT_NAME=\"$(basename \"$PROJECT_DIR\")\"\nCONFIG_FILE=\"$HOME/Library/Application Support/Claude/claude_desktop_config.json\"\n\n# Create config directory if it doesn't exist\nmkdir -p \"$(dirname \"$CONFIG_FILE\")\"\n\n# Read existing config or create empty one\nif [ -f \"$CONFIG_FILE\" ]; then\n    EXISTING_CONFIG=$(cat \"$CONFIG_FILE\")\nelse\n    EXISTING_CONFIG='{\"mcpServers\":{}}'\nfi\n\n# Use Node.js to merge the configs properly\nnode -e \"\nconst fs = require('fs');\nconst config = $EXISTING_CONFIG;\n\nif (!config.mcpServers) config.mcpServers = {};\n\n// Add this project's MCP server\nconfig.mcpServers['cntx-ui-$PROJECT_NAME'] = {\n    'command': 'npx',\n    'args': ['cntx-ui', 'mcp'],\n    'cwd': '$PROJECT_DIR'\n};\n\nfs.writeFileSync('$CONFIG_FILE', JSON.stringify(config, null, 2));\n\"\n\necho \"✅ Added cntx-ui-$PROJECT_NAME MCP server for: $PROJECT_DIR\"\necho \"📋 Your Claude Desktop config now includes multiple projects:\"\nnode -e \"\nconst config = JSON.parse(require('fs').readFileSync('$CONFIG_FILE', 'utf8'));\nObject.keys(config.mcpServers || {}).forEach(name => {\n    if (name.startsWith('cntx-ui-')) {\n        console.log('  • ' + name + ': ' + config.mcpServers[name].cwd);\n    }\n});\n\"\necho \"🔄 Please restart Claude Desktop to use the updated configuration\"]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"lib/function-level-chunker.js\" ext=\".js\">\n        <cntx:meta size=\"11627\" modified=\"2025-06-26T20:39:43.807Z\" lines=\"406\" />\n        <cntx:content><![CDATA[/**\n * Function-Level Semantic Chunker\n * Extracts individual functions/methods/components as discrete chunks\n * with intelligent context inclusion\n */\n\nimport { readFileSync, existsSync } from 'fs'\nimport { extname, basename, dirname, join } from 'path'\nimport glob from 'glob'\n\nexport default class FunctionLevelChunker {\n  constructor(options = {}) {\n    this.options = {\n      includeContext: true,\n      maxContextLines: 50,\n      groupRelated: true,\n      ...options\n    }\n  }\n\n  /**\n   * Extract function-level chunks from project\n   */\n  async extractFunctionChunks(projectPath, patterns = ['**/*.{js,jsx,ts,tsx,mjs}']) {\n    console.log('🔍 Starting function-level extraction...')\n    \n    const files = this.findFiles(projectPath, patterns)\n    console.log(`📁 Found ${files.length} files to analyze`)\n    \n    const allFunctions = []\n    let processedFiles = 0\n    \n    for (const filePath of files) {\n      try {\n        const functions = this.extractFunctionsFromFile(filePath, projectPath)\n        allFunctions.push(...functions)\n        processedFiles++\n      } catch (error) {\n        console.warn(`Failed to extract from ${filePath}: ${error.message}`)\n      }\n    }\n    \n    console.log(`✅ Extracted ${allFunctions.length} functions from ${processedFiles} files`)\n    \n    // Create semantic chunks from functions\n    const chunks = this.createFunctionChunks(allFunctions)\n    console.log(`📦 Created ${chunks.length} function-level chunks`)\n    \n    return {\n      summary: {\n        totalFiles: processedFiles,\n        totalFunctions: allFunctions.length,\n        totalChunks: chunks.length\n      },\n      functions: allFunctions,\n      chunks: chunks\n    }\n  }\n\n  /**\n   * Find files to analyze\n   */\n  findFiles(projectPath, patterns) {\n    const files = []\n    \n    for (const pattern of patterns) {\n      const matches = glob.sync(pattern, {\n        cwd: projectPath,\n        ignore: [\n          'node_modules/**', 'dist/**', 'build/**', '.git/**',\n          '*.test.*', '*.spec.*', '**/test/**', '**/tests/**',\n          '**/*.min.js', '**/*.bundle.js'\n        ]\n      })\n      \n      files.push(...matches.filter(file => \n        !file.includes('node_modules') && \n        !file.includes('dist/') &&\n        !file.includes('.min.')\n      ))\n    }\n    \n    return [...new Set(files)]\n  }\n\n  /**\n   * Extract all functions from a single file\n   */\n  extractFunctionsFromFile(relativePath, projectPath) {\n    const fullPath = join(projectPath, relativePath)\n    if (!existsSync(fullPath)) return []\n    \n    const content = readFileSync(fullPath, 'utf8')\n    const lines = content.split('\\n')\n    \n    const functions = []\n    \n    // Try tree-sitter first, fallback to regex\n    try {\n      const treeSitterFunctions = this.extractWithTreeSitter(content, relativePath)\n      functions.push(...treeSitterFunctions)\n    } catch (error) {\n      // Fallback to regex extraction\n      const regexFunctions = this.extractWithRegex(content, lines, relativePath)\n      functions.push(...regexFunctions)\n    }\n    \n    return functions\n  }\n\n  /**\n   * Extract functions using regex patterns (robust fallback)\n   */\n  extractWithRegex(content, lines, filePath) {\n    const functions = []\n    \n    // Patterns for different function types\n    const patterns = [\n      // Function declarations: function name() {}\n      {\n        pattern: /^[\\s]*(?:export\\s+)?(?:async\\s+)?function\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*\\(/gm,\n        type: 'function'\n      },\n      // Arrow functions: const name = () => {}\n      {\n        pattern: /^[\\s]*(?:export\\s+)?const\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?:async\\s+)?\\([^)]*\\)\\s*=>/gm,\n        type: 'arrow_function'\n      },\n      // Class methods: methodName() {}\n      {\n        pattern: /^[\\s]*(?:async\\s+)?([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*\\([^)]*\\)\\s*\\{/gm,\n        type: 'method'\n      },\n      // React components: export function ComponentName() {}\n      {\n        pattern: /^[\\s]*export\\s+(?:default\\s+)?function\\s+([A-Z][a-zA-Z0-9_$]*)\\s*\\(/gm,\n        type: 'react_component'\n      }\n    ]\n    \n    for (const { pattern, type } of patterns) {\n      let match\n      while ((match = pattern.exec(content)) !== null) {\n        const functionName = match[1]\n        const startIndex = match.index\n        \n        // Find the line number\n        const lineNumber = content.substring(0, startIndex).split('\\n').length\n        \n        // Extract function body\n        const functionInfo = this.extractFunctionBody(content, startIndex, lines, lineNumber)\n        \n        if (functionInfo && functionInfo.code.length > 10) { // Only include substantial functions\n          functions.push({\n            name: functionName,\n            type: type,\n            filePath: filePath,\n            startLine: lineNumber,\n            endLine: functionInfo.endLine,\n            code: functionInfo.code,\n            context: this.extractContext(content, functionInfo, filePath),\n            signature: match[0].trim()\n          })\n        }\n      }\n    }\n    \n    return functions\n  }\n\n  /**\n   * Extract function body by finding matching braces\n   */\n  extractFunctionBody(content, startIndex, lines, startLine) {\n    // Find opening brace\n    let braceIndex = content.indexOf('{', startIndex)\n    if (braceIndex === -1) {\n      // Handle arrow functions without braces: const fn = () => expression\n      const lineEnd = content.indexOf('\\n', startIndex)\n      if (lineEnd !== -1) {\n        const functionCode = content.substring(startIndex, lineEnd)\n        return {\n          code: functionCode,\n          endLine: startLine\n        }\n      }\n      return null\n    }\n    \n    // Count braces to find matching closing brace\n    let braceCount = 1\n    let currentIndex = braceIndex + 1\n    let inString = false\n    let stringChar = null\n    \n    while (currentIndex < content.length && braceCount > 0) {\n      const char = content[currentIndex]\n      const prevChar = content[currentIndex - 1]\n      \n      // Handle string literals to avoid counting braces inside strings\n      if ((char === '\"' || char === \"'\" || char === '`') && prevChar !== '\\\\') {\n        if (!inString) {\n          inString = true\n          stringChar = char\n        } else if (char === stringChar) {\n          inString = false\n          stringChar = null\n        }\n      }\n      \n      if (!inString) {\n        if (char === '{') braceCount++\n        else if (char === '}') braceCount--\n      }\n      \n      currentIndex++\n    }\n    \n    if (braceCount !== 0) return null // Unmatched braces\n    \n    // Extract the function code\n    const functionCode = content.substring(startIndex, currentIndex)\n    const endLine = startLine + functionCode.split('\\n').length - 1\n    \n    return {\n      code: functionCode.trim(),\n      endLine: endLine\n    }\n  }\n\n  /**\n   * Extract relevant context for a function\n   */\n  extractContext(content, functionInfo, filePath) {\n    const context = {\n      imports: this.extractImports(content),\n      types: this.extractTypes(content),\n      dependencies: [],\n      calledFunctions: this.extractCalledFunctions(functionInfo.code)\n    }\n    \n    return context\n  }\n\n  /**\n   * Extract import statements\n   */\n  extractImports(content) {\n    const imports = []\n    const importPattern = /import\\s+(?:{[^}]+}|\\*\\s+as\\s+\\w+|\\w+)\\s+from\\s+['\"`]([^'\"`]+)['\"`]/g\n    \n    let match\n    while ((match = importPattern.exec(content)) !== null) {\n      imports.push(match[1])\n    }\n    \n    return imports\n  }\n\n  /**\n   * Extract type definitions\n   */\n  extractTypes(content) {\n    const types = []\n    const typePattern = /(?:type|interface)\\s+([A-Z][a-zA-Z0-9]*)/g\n    \n    let match\n    while ((match = typePattern.exec(content)) !== null) {\n      types.push(match[1])\n    }\n    \n    return types\n  }\n\n  /**\n   * Extract function calls within code\n   */\n  extractCalledFunctions(code) {\n    const calls = []\n    const callPattern = /([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*\\(/g\n    \n    let match\n    while ((match = callPattern.exec(code)) !== null) {\n      const funcName = match[1]\n      // Filter out common keywords and built-ins\n      if (!['if', 'for', 'while', 'switch', 'catch', 'console', 'Object', 'Array'].includes(funcName)) {\n        calls.push(funcName)\n      }\n    }\n    \n    return [...new Set(calls)] // Remove duplicates\n  }\n\n  /**\n   * Create semantic chunks from extracted functions\n   */\n  createFunctionChunks(functions) {\n    const chunks = []\n    \n    // Group functions by file and related functionality\n    const fileGroups = this.groupFunctionsByFile(functions)\n    \n    for (const [filePath, fileFunctions] of Object.entries(fileGroups)) {\n      // Create individual function chunks\n      for (const func of fileFunctions) {\n        chunks.push({\n          name: `${func.name}`,\n          type: 'function',\n          subtype: func.type,\n          filePath: func.filePath,\n          functions: [func],\n          size: func.code.length,\n          complexity: this.calculateComplexity(func.code),\n          context: func.context,\n          purpose: this.determinePurpose(func),\n          tags: this.generateTags(func)\n        })\n      }\n    }\n    \n    return chunks\n  }\n\n  /**\n   * Group functions by file\n   */\n  groupFunctionsByFile(functions) {\n    const groups = {}\n    \n    for (const func of functions) {\n      if (!groups[func.filePath]) {\n        groups[func.filePath] = []\n      }\n      groups[func.filePath].push(func)\n    }\n    \n    return groups\n  }\n\n  /**\n   * Calculate function complexity\n   */\n  calculateComplexity(code) {\n    const complexityIndicators = [\n      'if', 'else', 'for', 'while', 'switch', 'case', 'try', 'catch',\n      '&&', '||', '?', ':', 'async', 'await'\n    ]\n    \n    let complexity = 1 // Base complexity\n    \n    for (const indicator of complexityIndicators) {\n      const count = (code.match(new RegExp(`\\\\b${indicator}\\\\b`, 'g')) || []).length\n      complexity += count\n    }\n    \n    return {\n      score: complexity,\n      level: complexity < 5 ? 'low' : complexity < 15 ? 'medium' : 'high'\n    }\n  }\n\n  /**\n   * Determine function purpose\n   */\n  determinePurpose(func) {\n    const name = func.name.toLowerCase()\n    const code = func.code.toLowerCase()\n    \n    if (func.type === 'react_component') return 'React component'\n    if (name.startsWith('use') && func.type === 'function') return 'React hook'\n    if (name.includes('test') || name.includes('spec')) return 'Test function'\n    if (name.includes('get') || name.includes('fetch')) return 'Data retrieval'\n    if (name.includes('create') || name.includes('add')) return 'Data creation'\n    if (name.includes('update') || name.includes('edit')) return 'Data modification'\n    if (name.includes('delete') || name.includes('remove')) return 'Data deletion'\n    if (name.includes('validate') || name.includes('check')) return 'Validation'\n    if (code.includes('express') || code.includes('router')) return 'API endpoint'\n    \n    return 'Utility function'\n  }\n\n  /**\n   * Generate tags for function\n   */\n  generateTags(func) {\n    const tags = []\n    \n    tags.push(func.type)\n    if (func.context.imports.length > 0) tags.push('has-imports')\n    if (func.context.calledFunctions.length > 3) tags.push('complex-logic')\n    if (func.code.includes('async')) tags.push('async')\n    if (func.code.includes('export')) tags.push('exported')\n    if (func.name.match(/^[A-Z]/)) tags.push('component-style')\n    \n    return tags\n  }\n\n  /**\n   * Fallback tree-sitter extraction (if available)\n   */\n  extractWithTreeSitter(content, filePath) {\n    // TODO: Implement tree-sitter extraction for functions\n    // For now, return empty to force regex fallback\n    return []\n  }\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"lib/mcp-server.js\" ext=\".js\">\n        <cntx:meta size=\"10553\" modified=\"2025-06-25T01:52:30.294Z\" lines=\"391\" />\n        <cntx:content><![CDATA[import { readFileSync } from 'fs';\nimport { join, relative } from 'path';\n\nexport class MCPServer {\n  constructor(cntxServer) {\n    this.cntxServer = cntxServer;\n    this.clientCapabilities = null;\n    this.serverInfo = {\n      name: 'cntx-ui',\n      version: '2.0.8'\n    };\n  }\n\n  // JSON-RPC 2.0 message handler\n  async handleMessage(message) {\n    try {\n      const request = typeof message === 'string' ? JSON.parse(message) : message;\n      \n      // Handle JSON-RPC 2.0 format\n      if (!request.jsonrpc || request.jsonrpc !== '2.0') {\n        return this.createErrorResponse(null, -32600, 'Invalid Request');\n      }\n\n      const response = await this.routeRequest(request);\n      return response;\n    } catch (error) {\n      return this.createErrorResponse(null, -32700, 'Parse error');\n    }\n  }\n\n  async routeRequest(request) {\n    const { method, params, id } = request;\n\n    try {\n      switch (method) {\n        case 'initialize':\n          return this.handleInitialize(params, id);\n        \n        case 'initialized':\n        case 'notifications/initialized':\n          return null; // No response needed for notification\n        \n        case 'resources/list':\n          return this.handleListResources(id);\n        \n        case 'resources/read':\n          return this.handleReadResource(params, id);\n        \n        case 'tools/list':\n          return this.handleListTools(id);\n        \n        case 'tools/call':\n          return this.handleCallTool(params, id);\n        \n        case 'prompts/list':\n          return this.createErrorResponse(id, -32601, 'Method not found');\n        \n        default:\n          return this.createErrorResponse(id, -32601, 'Method not found');\n      }\n    } catch (error) {\n      return this.createErrorResponse(id, -32603, 'Internal error', error.message);\n    }\n  }\n\n  // Initialize MCP session\n  handleInitialize(params, id) {\n    this.clientCapabilities = params?.capabilities || {};\n    \n    return this.createSuccessResponse(id, {\n      protocolVersion: '2024-11-05',\n      capabilities: {\n        resources: {\n          subscribe: true,\n          listChanged: true\n        },\n        tools: {}\n      },\n      serverInfo: this.serverInfo\n    });\n  }\n\n  // List available resources (bundles)\n  handleListResources(id) {\n    const resources = [];\n    \n    this.cntxServer.bundles.forEach((bundle, name) => {\n      resources.push({\n        uri: `cntx://bundle/${name}`,\n        name: `Bundle: ${name}`,\n        description: `File bundle containing ${bundle.files.length} files`,\n        mimeType: 'application/xml'\n      });\n    });\n\n    // Add individual file resources\n    const allFiles = this.cntxServer.getAllFiles();\n    allFiles.slice(0, 100).forEach((filePath) => { // Limit to first 100 files\n      resources.push({\n        uri: `cntx://file/${filePath}`,\n        name: `File: ${filePath}`,\n        description: `Individual file: ${filePath}`,\n        mimeType: this.getMimeType(filePath)\n      });\n    });\n\n    return this.createSuccessResponse(id, {\n      resources\n    });\n  }\n\n  // Read a specific resource\n  handleReadResource(params, id) {\n    const { uri } = params;\n    \n    if (!uri || !uri.startsWith('cntx://')) {\n      return this.createErrorResponse(id, -32602, 'Invalid URI');\n    }\n\n    try {\n      if (uri.startsWith('cntx://bundle/')) {\n        const bundleName = uri.replace('cntx://bundle/', '');\n        const bundle = this.cntxServer.bundles.get(bundleName);\n        \n        if (!bundle) {\n          return this.createErrorResponse(id, -32602, 'Bundle not found');\n        }\n\n        return this.createSuccessResponse(id, {\n          contents: [{\n            uri,\n            mimeType: 'application/xml',\n            text: bundle.content\n          }]\n        });\n      } else if (uri.startsWith('cntx://file/')) {\n        const filePath = uri.replace('cntx://file/', '');\n        const fullPath = join(this.cntxServer.CWD, filePath);\n        \n        try {\n          const content = readFileSync(fullPath, 'utf8');\n          return this.createSuccessResponse(id, {\n            contents: [{\n              uri,\n              mimeType: this.getMimeType(filePath),\n              text: content\n            }]\n          });\n        } catch (error) {\n          return this.createErrorResponse(id, -32602, 'File not found');\n        }\n      }\n\n      return this.createErrorResponse(id, -32602, 'Invalid resource URI');\n    } catch (error) {\n      return this.createErrorResponse(id, -32603, 'Internal error reading resource');\n    }\n  }\n\n  // List available tools\n  handleListTools(id) {\n    const tools = [\n      {\n        name: 'list_bundles',\n        description: 'List all available file bundles',\n        inputSchema: {\n          type: 'object',\n          properties: {},\n          required: []\n        }\n      },\n      {\n        name: 'get_bundle',\n        description: 'Get the content of a specific bundle',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            name: {\n              type: 'string',\n              description: 'Name of the bundle to retrieve'\n            }\n          },\n          required: ['name']\n        }\n      },\n      {\n        name: 'generate_bundle',\n        description: 'Regenerate a specific bundle',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            name: {\n              type: 'string',\n              description: 'Name of the bundle to regenerate'\n            }\n          },\n          required: ['name']\n        }\n      },\n      {\n        name: 'get_file_tree',\n        description: 'Get the project file tree',\n        inputSchema: {\n          type: 'object',\n          properties: {},\n          required: []\n        }\n      },\n      {\n        name: 'get_project_status',\n        description: 'Get current project status and bundle information',\n        inputSchema: {\n          type: 'object',\n          properties: {},\n          required: []\n        }\n      }\n    ];\n\n    return this.createSuccessResponse(id, { tools });\n  }\n\n  // Handle tool execution\n  async handleCallTool(params, id) {\n    const { name, arguments: args = {} } = params;\n\n    try {\n      switch (name) {\n        case 'list_bundles':\n          return this.toolListBundles(id);\n        \n        case 'get_bundle':\n          return this.toolGetBundle(args, id);\n        \n        case 'generate_bundle':\n          return this.toolGenerateBundle(args, id);\n        \n        case 'get_file_tree':\n          return this.toolGetFileTree(id);\n        \n        case 'get_project_status':\n          return this.toolGetProjectStatus(id);\n        \n        default:\n          return this.createErrorResponse(id, -32602, 'Unknown tool');\n      }\n    } catch (error) {\n      return this.createErrorResponse(id, -32603, 'Tool execution failed', error.message);\n    }\n  }\n\n  // Tool implementations\n  toolListBundles(id) {\n    const bundles = [];\n    this.cntxServer.bundles.forEach((bundle, name) => {\n      bundles.push({\n        name,\n        fileCount: bundle.files.length,\n        size: bundle.size,\n        lastGenerated: bundle.lastGenerated,\n        changed: bundle.changed,\n        patterns: bundle.patterns\n      });\n    });\n\n    return this.createSuccessResponse(id, {\n      content: [{\n        type: 'text',\n        text: `Available bundles:\\n${bundles.map(b => \n          `• ${b.name}: ${b.fileCount} files (${(b.size / 1024).toFixed(1)}KB) ${b.changed ? '[CHANGED]' : '[SYNCED]'}`\n        ).join('\\n')}`\n      }]\n    });\n  }\n\n  toolGetBundle(args, id) {\n    const { name } = args;\n    const bundle = this.cntxServer.bundles.get(name);\n    \n    if (!bundle) {\n      return this.createErrorResponse(id, -32602, `Bundle '${name}' not found`);\n    }\n\n    return this.createSuccessResponse(id, {\n      content: [{\n        type: 'text',\n        text: bundle.content\n      }]\n    });\n  }\n\n  toolGenerateBundle(args, id) {\n    const { name } = args;\n    \n    if (!this.cntxServer.bundles.has(name)) {\n      return this.createErrorResponse(id, -32602, `Bundle '${name}' not found`);\n    }\n\n    this.cntxServer.generateBundle(name);\n    this.cntxServer.saveBundleStates();\n    \n    const bundle = this.cntxServer.bundles.get(name);\n    \n    return this.createSuccessResponse(id, {\n      content: [{\n        type: 'text',\n        text: `Bundle '${name}' regenerated successfully. Contains ${bundle.files.length} files (${(bundle.size / 1024).toFixed(1)}KB).`\n      }]\n    });\n  }\n\n  toolGetFileTree(id) {\n    const fileTree = this.cntxServer.getFileTree();\n    const treeText = fileTree.map(file => \n      `${file.path} (${(file.size / 1024).toFixed(1)}KB)`\n    ).join('\\n');\n\n    return this.createSuccessResponse(id, {\n      content: [{\n        type: 'text',\n        text: `Project file tree:\\n${treeText}`\n      }]\n    });\n  }\n\n  toolGetProjectStatus(id) {\n    const bundleCount = this.cntxServer.bundles.size;\n    const changedBundles = Array.from(this.cntxServer.bundles.entries())\n      .filter(([_, bundle]) => bundle.changed)\n      .map(([name, _]) => name);\n\n    const statusText = `Project Status:\nWorking Directory: ${relative(process.cwd(), this.cntxServer.CWD)}\nTotal Bundles: ${bundleCount}\nChanged Bundles: ${changedBundles.length > 0 ? changedBundles.join(', ') : 'None'}\n\nBundle Details:\n${Array.from(this.cntxServer.bundles.entries()).map(([name, bundle]) => \n  `• ${name}: ${bundle.files.length} files, ${(bundle.size / 1024).toFixed(1)}KB ${bundle.changed ? '[CHANGED]' : '[SYNCED]'}`\n).join('\\n')}`;\n\n    return this.createSuccessResponse(id, {\n      content: [{\n        type: 'text',\n        text: statusText\n      }]\n    });\n  }\n\n  // Helper methods\n  getMimeType(filePath) {\n    const ext = filePath.split('.').pop()?.toLowerCase();\n    const mimeTypes = {\n      'js': 'application/javascript',\n      'jsx': 'application/javascript',\n      'ts': 'application/typescript',\n      'tsx': 'application/typescript',\n      'json': 'application/json',\n      'xml': 'application/xml',\n      'html': 'text/html',\n      'css': 'text/css',\n      'md': 'text/markdown',\n      'txt': 'text/plain',\n      'py': 'text/x-python',\n      'java': 'text/x-java',\n      'c': 'text/x-c',\n      'cpp': 'text/x-c++',\n      'php': 'text/x-php'\n    };\n    return mimeTypes[ext] || 'text/plain';\n  }\n\n  createSuccessResponse(id, result) {\n    return {\n      jsonrpc: '2.0',\n      id,\n      result\n    };\n  }\n\n  createErrorResponse(id, code, message, data = null) {\n    const error = { code, message };\n    if (data) error.data = data;\n    \n    return {\n      jsonrpc: '2.0',\n      id,\n      error\n    };\n  }\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"lib/mcp-transport.js\" ext=\".js\">\n        <cntx:meta size=\"2604\" modified=\"2025-06-25T01:58:02.449Z\" lines=\"97\" />\n        <cntx:content><![CDATA[import { MCPServer } from './mcp-server.js';\n\nexport class MCPTransport {\n  constructor(cntxServer) {\n    this.mcpServer = new MCPServer(cntxServer);\n    this.buffer = '';\n  }\n\n  // Start stdio transport\n  start() {\n    console.error('🚀 MCP server starting on stdio transport');\n    \n    // Handle incoming messages from stdin\n    process.stdin.on('data', (data) => {\n      this.handleIncomingData(data.toString());\n    });\n\n    // Handle process cleanup\n    process.on('SIGINT', () => {\n      console.error('📡 MCP server shutting down');\n      process.exit(0);\n    });\n\n    process.on('SIGTERM', () => {\n      console.error('📡 MCP server shutting down');\n      process.exit(0);\n    });\n\n    // Set stdin to raw mode for proper JSON-RPC communication\n    process.stdin.setEncoding('utf8');\n    \n    console.error('✅ MCP server ready for JSON-RPC messages');\n  }\n\n  // Handle incoming data and parse JSON-RPC messages\n  async handleIncomingData(data) {\n    this.buffer += data;\n    \n    // Split by newlines to handle multiple messages\n    const lines = this.buffer.split('\\n');\n    this.buffer = lines.pop() || ''; // Keep incomplete line in buffer\n\n    for (const line of lines) {\n      if (line.trim()) {\n        try {\n          const message = JSON.parse(line.trim());\n          await this.processMessage(message);\n        } catch (error) {\n          console.error('❌ Failed to parse JSON-RPC message:', error.message);\n          this.sendError(null, -32700, 'Parse error');\n        }\n      }\n    }\n  }\n\n  // Process a single JSON-RPC message\n  async processMessage(message) {\n    try {\n      const response = await this.mcpServer.handleMessage(message);\n      \n      // Only send response if not null (notifications don't need responses)\n      if (response !== null) {\n        this.sendMessage(response);\n      }\n    } catch (error) {\n      console.error('❌ Error processing message:', error.message);\n      this.sendError(message.id || null, -32603, 'Internal error');\n    }\n  }\n\n  // Send a message via stdout\n  sendMessage(message) {\n    const messageStr = JSON.stringify(message);\n    process.stdout.write(messageStr + '\\n');\n  }\n\n  // Send an error response\n  sendError(id, code, message, data = null) {\n    const error = { code, message };\n    if (data) error.data = data;\n    \n    const response = {\n      jsonrpc: '2.0',\n      id,\n      error\n    };\n    \n    this.sendMessage(response);\n  }\n}\n\n// Factory function to start MCP transport\nexport function startMCPTransport(cntxServer) {\n  const transport = new MCPTransport(cntxServer);\n  transport.start();\n  return transport;\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"lib/semantic-integration.js\" ext=\".js\">\n        <cntx:meta size=\"13532\" modified=\"2025-06-26T00:47:15.738Z\" lines=\"441\" />\n        <cntx:content><![CDATA[/**\n * Semantic Chunking Integration for cntx-ui Server\n * Extends the existing server with semantic analysis capabilities\n */\n\nimport SemanticChunker from './semantic-chunker.js'\nimport { readFileSync, writeFileSync } from 'fs'\nimport { join } from 'path'\n\nclass SemanticIntegration {\n  constructor(projectPath = process.cwd()) {\n    this.projectPath = projectPath\n    this.chunker = new SemanticChunker({\n      includeImports: true,\n      includeExports: true,\n      detectComponentTypes: true,\n      groupRelatedFiles: true,\n      minChunkSize: 100,\n      maxChunkSize: 10000\n    })\n  }\n\n  /**\n   * Analyze project and generate semantic bundle suggestions\n   */\n  async generateSemanticBundles() {\n    try {\n      console.log('🔍 Analyzing project for semantic chunking...')\n      \n      // Analyze different file types separately\n      const analyses = await Promise.all([\n        this.chunker.analyzeProject(this.projectPath, ['web/src/components/**/*.{tsx,ts}']),\n        this.chunker.analyzeProject(this.projectPath, ['web/src/hooks/**/*.{tsx,ts}']),\n        this.chunker.analyzeProject(this.projectPath, ['web/src/lib/**/*.{tsx,ts}']),\n        this.chunker.analyzeProject(this.projectPath, ['web/src/utils/**/*.{tsx,ts}']),\n        this.chunker.analyzeProject(this.projectPath, ['lib/**/*.js']),\n      ])\n\n      const [componentsAnalysis, hooksAnalysis, libAnalysis, utilsAnalysis, serverAnalysis] = analyses\n\n      // Generate bundle suggestions\n      const suggestions = this.generateBundleSuggestions([\n        { name: 'components', analysis: componentsAnalysis },\n        { name: 'hooks', analysis: hooksAnalysis },\n        { name: 'lib', analysis: libAnalysis },\n        { name: 'utils', analysis: utilsAnalysis },\n        { name: 'server', analysis: serverAnalysis }\n      ])\n\n      console.log('✅ Semantic analysis complete!')\n      \n      return {\n        timestamp: new Date().toISOString(),\n        projectPath: this.projectPath,\n        suggestions,\n        analyses: {\n          components: this.chunker.formatResults(componentsAnalysis),\n          hooks: this.chunker.formatResults(hooksAnalysis),\n          lib: this.chunker.formatResults(libAnalysis),\n          utils: this.chunker.formatResults(utilsAnalysis),\n          server: this.chunker.formatResults(serverAnalysis)\n        },\n        summary: this.generateOverallSummary(analyses)\n      }\n    } catch (error) {\n      console.error('❌ Semantic analysis failed:', error.message)\n      throw error\n    }\n  }\n\n  /**\n   * Generate bundle configuration suggestions based on semantic analysis\n   */\n  generateBundleSuggestions(namedAnalyses) {\n    const suggestions = {\n      recommended: {},\n      alternative: {},\n      notes: []\n    }\n\n    for (const { name, analysis } of namedAnalyses) {\n      if (analysis.chunks.length === 0) continue\n\n      // Recommended: Group by semantic purpose\n      const purposeGroups = this.groupChunksByPurpose(analysis.chunks)\n      \n      for (const [purpose, chunks] of Object.entries(purposeGroups)) {\n        const bundleName = `${name}-${purpose}`\n        const patterns = this.generatePatternsForChunks(chunks)\n        \n        suggestions.recommended[bundleName] = patterns\n      }\n\n      // Alternative: Group by directory structure\n      const dirGroups = this.groupChunksByDirectory(analysis.chunks)\n      \n      for (const [dir, chunks] of Object.entries(dirGroups)) {\n        const bundleName = `${name}-${dir}`\n        const patterns = this.generatePatternsForChunks(chunks)\n        \n        suggestions.alternative[bundleName] = patterns\n      }\n    }\n\n    // Add specialized bundles\n    this.addSpecializedBundles(suggestions, namedAnalyses)\n\n    // Add optimization notes\n    this.addOptimizationNotes(suggestions, namedAnalyses)\n\n    return suggestions\n  }\n\n  /**\n   * Group chunks by their primary purpose\n   */\n  groupChunksByPurpose(chunks) {\n    const groups = {}\n    \n    for (const chunk of chunks) {\n      const purpose = chunk.purpose || 'misc'\n      if (!groups[purpose]) {\n        groups[purpose] = []\n      }\n      groups[purpose].push(chunk)\n    }\n    \n    return groups\n  }\n\n  /**\n   * Group chunks by directory structure\n   */\n  groupChunksByDirectory(chunks) {\n    const groups = {}\n    \n    for (const chunk of chunks) {\n      // Extract directory from chunk name or files\n      const dir = chunk.name.split('-')[0] || 'misc'\n      if (!groups[dir]) {\n        groups[dir] = []\n      }\n      groups[dir].push(chunk)\n    }\n    \n    return groups\n  }\n\n  /**\n   * Generate glob patterns for chunks\n   */\n  generatePatternsForChunks(chunks) {\n    const patterns = new Set()\n    \n    for (const chunk of chunks) {\n      for (const file of chunk.files) {\n        // Convert file paths to glob patterns\n        const pattern = this.fileToGlobPattern(file)\n        patterns.add(pattern)\n      }\n    }\n    \n    return Array.from(patterns)\n  }\n\n  /**\n   * Convert file path to glob pattern\n   */\n  fileToGlobPattern(filePath) {\n    // Extract directory and create pattern\n    const parts = filePath.split('/')\n    const dir = parts.slice(0, -1).join('/')\n    const ext = parts[parts.length - 1].split('.').pop()\n    \n    return `${dir}/**/*.${ext}`\n  }\n\n  /**\n   * Add specialized bundle suggestions\n   */\n  addSpecializedBundles(suggestions, namedAnalyses) {\n    // UI Components bundle\n    const componentsAnalysis = namedAnalyses.find(a => a.name === 'components')?.analysis\n    if (componentsAnalysis?.chunks.length > 0) {\n      const uiComponents = componentsAnalysis.chunks.filter(c => \n        c.name.includes('ui') || c.tags.includes('has-components')\n      )\n      \n      if (uiComponents.length > 0) {\n        suggestions.recommended['ui-system'] = [\n          'web/src/components/ui/**/*.tsx',\n          'web/src/components/theme-*.tsx'\n        ]\n      }\n    }\n\n    // Test files bundle\n    suggestions.recommended['tests'] = [\n      '**/*.test.{js,jsx,ts,tsx}',\n      '**/*.spec.{js,jsx,ts,tsx}',\n      '**/__tests__/**/*'\n    ]\n\n    // Configuration bundle\n    suggestions.recommended['config'] = [\n      '*.config.{js,ts}',\n      '*.json',\n      'package.json',\n      'tsconfig*.json',\n      '.env*'\n    ]\n\n    // Documentation bundle\n    suggestions.recommended['docs'] = [\n      '**/*.md',\n      'docs/**/*',\n      'README*'\n    ]\n  }\n\n  /**\n   * Add optimization notes and recommendations\n   */\n  addOptimizationNotes(suggestions, namedAnalyses) {\n    suggestions.notes = []\n\n    // Analyze bundle sizes\n    const totalFiles = namedAnalyses.reduce((sum, a) => sum + a.analysis.summary.totalFiles, 0)\n    const totalChunks = namedAnalyses.reduce((sum, a) => sum + a.analysis.summary.totalChunks, 0)\n    \n    suggestions.notes.push({\n      type: 'info',\n      message: `Project has ${totalFiles} files organized into ${totalChunks} semantic chunks`\n    })\n\n    // Check for large files\n    const largeFiles = []\n    for (const { analysis } of namedAnalyses) {\n      for (const [path, file] of Object.entries(analysis.files)) {\n        if (file.lines > 300) {\n          largeFiles.push({ path, lines: file.lines })\n        }\n      }\n    }\n\n    if (largeFiles.length > 0) {\n      suggestions.notes.push({\n        type: 'warning',\n        message: `${largeFiles.length} files exceed 300 lines and may benefit from splitting`,\n        details: largeFiles.slice(0, 3).map(f => `${f.path} (${f.lines} lines)`)\n      })\n    }\n\n    // Check for high complexity\n    const complexFiles = []\n    for (const { analysis } of namedAnalyses) {\n      for (const [path, file] of Object.entries(analysis.files)) {\n        if (file.complexity?.level === 'high') {\n          complexFiles.push({ path, score: file.complexity.score })\n        }\n      }\n    }\n\n    if (complexFiles.length > 0) {\n      suggestions.notes.push({\n        type: 'optimization',\n        message: `${complexFiles.length} files have high complexity and may need refactoring`,\n        details: complexFiles.slice(0, 3).map(f => `${f.path} (score: ${f.score})`)\n      })\n    }\n\n    // Suggest bundle patterns\n    suggestions.notes.push({\n      type: 'suggestion',\n      message: 'Consider using semantic bundles for better AI context understanding',\n      details: [\n        'UI components grouped by functionality',\n        'Hooks grouped by domain logic',\n        'Utilities grouped by purpose',\n        'Tests separated for focused debugging'\n      ]\n    })\n  }\n\n  /**\n   * Generate overall project summary\n   */\n  generateOverallSummary(analyses) {\n    const totalFiles = analyses.reduce((sum, a) => sum + a.summary.totalFiles, 0)\n    const totalSize = analyses.reduce((sum, a) => sum + a.summary.totalSize, 0)\n    const totalLines = analyses.reduce((sum, a) => sum + a.summary.totalLines, 0)\n    const totalChunks = analyses.reduce((sum, a) => sum + a.summary.totalChunks, 0)\n\n    const fileTypes = {}\n    const filePurposes = {}\n    const complexityDistribution = {}\n\n    for (const analysis of analyses) {\n      // Merge file types\n      for (const [type, count] of Object.entries(analysis.summary.fileTypes)) {\n        fileTypes[type] = (fileTypes[type] || 0) + count\n      }\n      \n      // Merge purposes\n      for (const [purpose, count] of Object.entries(analysis.summary.filePurposes)) {\n        filePurposes[purpose] = (filePurposes[purpose] || 0) + count\n      }\n      \n      // Merge complexity\n      for (const [level, count] of Object.entries(analysis.summary.complexityDistribution)) {\n        complexityDistribution[level] = (complexityDistribution[level] || 0) + count\n      }\n    }\n\n    return {\n      totalFiles,\n      totalSize,\n      totalLines,\n      totalChunks,\n      fileTypes,\n      filePurposes,\n      complexityDistribution,\n      averageFileSize: Math.round(totalSize / totalFiles),\n      averageLinesPerFile: Math.round(totalLines / totalFiles),\n      formattedSize: this.formatBytes(totalSize)\n    }\n  }\n\n  /**\n   * Convert semantic suggestions to cntx-ui bundle format\n   */\n  convertToConfigFormat(suggestions) {\n    return {\n      bundles: {\n        // Keep existing master bundle\n        master: ['**/*'],\n        \n        // Add recommended semantic bundles\n        ...suggestions.recommended,\n        \n        // Add alternative bundles as commented examples\n        // ...suggestions.alternative (uncomment to use directory-based grouping)\n      }\n    }\n  }\n\n  /**\n   * Save analysis results to file\n   */\n  async saveAnalysisResults(results, outputPath = 'semantic-analysis.json') {\n    try {\n      const fullPath = join(this.projectPath, outputPath)\n      writeFileSync(fullPath, JSON.stringify(results, null, 2))\n      console.log(`📁 Analysis saved to ${fullPath}`)\n      return fullPath\n    } catch (error) {\n      console.error('❌ Failed to save analysis:', error.message)\n      throw error\n    }\n  }\n\n  /**\n   * Generate bundle config suggestions file\n   */\n  async generateBundleConfigSuggestions(results, outputPath = 'semantic-bundle-suggestions.json') {\n    try {\n      const config = this.convertToConfigFormat(results.suggestions)\n      const fullPath = join(this.projectPath, outputPath)\n      \n      const output = {\n        timestamp: results.timestamp,\n        description: 'Semantic chunking suggestions for cntx-ui bundles',\n        usage: 'Copy the bundles object to your .cntx/bundles.json file',\n        ...config,\n        notes: results.suggestions.notes,\n        summary: results.summary\n      }\n      \n      writeFileSync(fullPath, JSON.stringify(output, null, 2))\n      console.log(`📦 Bundle suggestions saved to ${fullPath}`)\n      return fullPath\n    } catch (error) {\n      console.error('❌ Failed to save bundle suggestions:', error.message)\n      throw error\n    }\n  }\n\n  /**\n   * Format bytes to human readable\n   */\n  formatBytes(bytes) {\n    if (bytes === 0) return '0 Bytes'\n    const k = 1024\n    const sizes = ['Bytes', 'KB', 'MB', 'GB']\n    const i = Math.floor(Math.log(bytes) / Math.log(k))\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]\n  }\n}\n\nexport default SemanticIntegration\n\n// CLI usage\nif (import.meta.url === `file://${process.argv[1]}`) {\n  const integration = new SemanticIntegration()\n  \n  console.log('🚀 Starting semantic analysis integration...')\n  \n  try {\n    const results = await integration.generateSemanticBundles()\n    \n    // Save full analysis\n    await integration.saveAnalysisResults(results)\n    \n    // Save bundle suggestions\n    await integration.generateBundleConfigSuggestions(results)\n    \n    console.log('\\n📊 Project Summary:')\n    console.log(`📁 ${results.summary.totalFiles} files analyzed`)\n    console.log(`💾 ${results.summary.formattedSize} total size`)\n    console.log(`📦 ${results.summary.totalChunks} semantic chunks created`)\n    console.log(`🎯 ${Object.keys(results.suggestions.recommended).length} recommended bundles`)\n    \n    console.log('\\n🎯 Recommended Bundles:')\n    for (const [name, patterns] of Object.entries(results.suggestions.recommended)) {\n      console.log(`  • ${name}: ${patterns.length} patterns`)\n    }\n    \n    console.log('\\n💡 Notes:')\n    results.suggestions.notes.forEach(note => {\n      const emoji = note.type === 'warning' ? '⚠️' : note.type === 'optimization' ? '🔧' : '💡'\n      console.log(`  ${emoji} ${note.message}`)\n    })\n    \n    console.log('\\n✅ Semantic integration complete!')\n    console.log('📄 Check semantic-bundle-suggestions.json for ready-to-use bundle configurations')\n    \n  } catch (error) {\n    console.error('❌ Integration failed:', error.message)\n    process.exit(1)\n  }\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"lib/semantic-splitter.js\" ext=\".js\">\n        <cntx:meta size=\"18236\" modified=\"2025-06-26T22:26:39.401Z\" lines=\"595\" />\n        <cntx:content><![CDATA[/**\n * True Semantic Splitting - Function-level code chunks with context\n * Creates surgical, self-contained chunks for AI consumption\n * Operates parallel to file-level bundle system\n */\n\nimport { readFileSync, existsSync } from 'fs'\nimport { extname, basename, dirname, join } from 'path'\nimport glob from 'glob'\n\nexport default class SemanticSplitter {\n  constructor(options = {}) {\n    this.options = {\n      maxChunkSize: 2000,       // Max chars per chunk\n      includeContext: true,     // Include imports/types needed\n      groupRelated: true,       // Group related functions\n      minFunctionSize: 50,      // Skip tiny functions\n      ...options\n    }\n  }\n\n  /**\n   * Extract semantic chunks from project\n   */\n  async extractSemanticChunks(projectPath, patterns = ['**/*.{js,jsx,ts,tsx,mjs}'], bundleConfig = null) {\n    console.log('🔪 Starting semantic splitting...')\n    \n    const files = this.findFiles(projectPath, patterns)\n    console.log(`📁 Found ${files.length} files to split`)\n    \n    // Load bundle configuration if provided\n    this.bundleConfig = bundleConfig\n    \n    const allFunctions = []\n    const allTypes = []\n    const allImports = []\n    \n    // Extract all code elements\n    for (const filePath of files) {\n      try {\n        const elements = this.extractCodeElements(filePath, projectPath)\n        allFunctions.push(...elements.functions)\n        allTypes.push(...elements.types)\n        allImports.push(...elements.imports)\n      } catch (error) {\n        console.warn(`Failed to extract from ${filePath}: ${error.message}`)\n      }\n    }\n    \n    console.log(`⚡ Extracted ${allFunctions.length} functions, ${allTypes.length} types`)\n    \n    // Create semantic chunks\n    const chunks = this.createSemanticChunks(allFunctions, allTypes, allImports)\n    console.log(`🧩 Created ${chunks.length} semantic chunks`)\n    \n    return {\n      summary: {\n        totalFiles: files.length,\n        totalFunctions: allFunctions.length,\n        totalChunks: chunks.length,\n        averageChunkSize: chunks.reduce((sum, c) => sum + c.code.length, 0) / chunks.length\n      },\n      chunks: chunks\n    }\n  }\n\n  /**\n   * Find files to analyze (same logic as bundles)\n   */\n  findFiles(projectPath, patterns) {\n    const files = []\n    \n    for (const pattern of patterns) {\n      const matches = glob.sync(pattern, {\n        cwd: projectPath,\n        ignore: [\n          'node_modules/**', 'dist/**', 'build/**', '.git/**',\n          '*.test.*', '*.spec.*', '**/test/**', '**/tests/**',\n          '**/*.min.js', '**/*.bundle.js'\n        ]\n      })\n      \n      files.push(...matches.filter(file => \n        !file.includes('node_modules') && \n        !file.includes('dist/') &&\n        !file.includes('.min.')\n      ))\n    }\n    \n    return [...new Set(files)]\n  }\n\n  /**\n   * Extract functions, types, and imports from a file\n   */\n  extractCodeElements(relativePath, projectPath) {\n    const fullPath = join(projectPath, relativePath)\n    if (!existsSync(fullPath)) return { functions: [], types: [], imports: [] }\n    \n    const content = readFileSync(fullPath, 'utf8')\n    const lines = content.split('\\n')\n    \n    return {\n      functions: this.extractFunctions(content, lines, relativePath),\n      types: this.extractTypes(content, lines, relativePath),\n      imports: this.extractImports(content, relativePath)\n    }\n  }\n\n  /**\n   * Extract functions with robust regex patterns\n   */\n  extractFunctions(content, lines, filePath) {\n    const functions = []\n    \n    // Pattern 1: Regular function declarations\n    const functionRegex = /^(\\s*)(?:export\\s+)?(?:async\\s+)?function\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*\\([^)]*\\)\\s*\\{/gm\n    \n    // Pattern 2: Arrow functions assigned to const/let\n    const arrowRegex = /^(\\s*)(?:export\\s+)?const\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?:async\\s+)?\\([^)]*\\)\\s*=>\\s*[\\{]/gm\n    \n    // Pattern 3: Class methods\n    const methodRegex = /^(\\s+)(?:async\\s+)?([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*\\([^)]*\\)\\s*\\{/gm\n    \n    // Pattern 4: React components (function components)\n    const componentRegex = /^(\\s*)(?:export\\s+(?:default\\s+)?)?function\\s+([A-Z][a-zA-Z0-9_$]*)\\s*\\([^)]*\\)\\s*\\{/gm\n    \n    const patterns = [\n      { regex: functionRegex, type: 'function' },\n      { regex: arrowRegex, type: 'arrow_function' },\n      { regex: methodRegex, type: 'method' },\n      { regex: componentRegex, type: 'react_component' }\n    ]\n    \n    for (const { regex, type } of patterns) {\n      let match\n      while ((match = regex.exec(content)) !== null) {\n        const functionName = match[2]\n        const indentation = match[1]\n        const startIndex = match.index\n        \n        // Skip if it's a keyword or common false positive\n        if (['if', 'for', 'while', 'switch', 'catch'].includes(functionName)) {\n          continue\n        }\n        \n        const startLine = content.substring(0, startIndex).split('\\n').length\n        const functionBody = this.extractFunctionBody(content, startIndex)\n        \n        if (functionBody && functionBody.length > this.options.minFunctionSize) {\n          functions.push({\n            name: functionName,\n            type: type,\n            filePath: filePath,\n            startLine: startLine,\n            code: functionBody,\n            indentation: indentation.length,\n            isExported: match[0].includes('export'),\n            isAsync: match[0].includes('async'),\n            size: functionBody.length\n          })\n        }\n      }\n    }\n    \n    return functions\n  }\n\n  /**\n   * Extract function body using brace matching\n   */\n  extractFunctionBody(content, startIndex) {\n    const openBraceIndex = content.indexOf('{', startIndex)\n    if (openBraceIndex === -1) return null\n    \n    let braceCount = 0\n    let currentIndex = openBraceIndex\n    let inString = false\n    let stringChar = null\n    \n    while (currentIndex < content.length) {\n      const char = content[currentIndex]\n      const prevChar = content[currentIndex - 1] || ''\n      \n      // Handle string literals\n      if ((char === '\"' || char === \"'\" || char === '`') && prevChar !== '\\\\') {\n        if (!inString) {\n          inString = true\n          stringChar = char\n        } else if (char === stringChar) {\n          inString = false\n          stringChar = null\n        }\n      }\n      \n      // Count braces outside strings\n      if (!inString) {\n        if (char === '{') braceCount++\n        else if (char === '}') braceCount--\n        \n        if (braceCount === 0) {\n          // Found the closing brace\n          return content.substring(startIndex, currentIndex + 1).trim()\n        }\n      }\n      \n      currentIndex++\n    }\n    \n    return null // Unmatched braces\n  }\n\n  /**\n   * Extract type definitions and interfaces\n   */\n  extractTypes(content, lines, filePath) {\n    const types = []\n    \n    // TypeScript interfaces\n    const interfaceRegex = /^(\\s*)(?:export\\s+)?interface\\s+([A-Z][a-zA-Z0-9_$]*)\\s*\\{/gm\n    \n    // Type aliases\n    const typeRegex = /^(\\s*)(?:export\\s+)?type\\s+([A-Z][a-zA-Z0-9_$]*)\\s*=/gm\n    \n    const patterns = [\n      { regex: interfaceRegex, type: 'interface' },\n      { regex: typeRegex, type: 'type_alias' }\n    ]\n    \n    for (const { regex, type } of patterns) {\n      let match\n      while ((match = regex.exec(content)) !== null) {\n        const typeName = match[2]\n        const startIndex = match.index\n        const startLine = content.substring(0, startIndex).split('\\n').length\n        \n        let typeBody\n        if (type === 'interface') {\n          typeBody = this.extractTypeBody(content, startIndex)\n        } else {\n          // For type aliases, extract until semicolon or newline\n          const endIndex = content.indexOf(';', startIndex)\n          typeBody = content.substring(startIndex, endIndex + 1).trim()\n        }\n        \n        if (typeBody) {\n          types.push({\n            name: typeName,\n            type: type,\n            filePath: filePath,\n            startLine: startLine,\n            code: typeBody,\n            isExported: match[0].includes('export')\n          })\n        }\n      }\n    }\n    \n    return types\n  }\n\n  /**\n   * Extract type body (similar to function body)\n   */\n  extractTypeBody(content, startIndex) {\n    const openBraceIndex = content.indexOf('{', startIndex)\n    if (openBraceIndex === -1) return null\n    \n    let braceCount = 0\n    let currentIndex = openBraceIndex\n    \n    while (currentIndex < content.length) {\n      const char = content[currentIndex]\n      \n      if (char === '{') braceCount++\n      else if (char === '}') braceCount--\n      \n      if (braceCount === 0) {\n        return content.substring(startIndex, currentIndex + 1).trim()\n      }\n      \n      currentIndex++\n    }\n    \n    return null\n  }\n\n  /**\n   * Extract import statements\n   */\n  extractImports(content, filePath) {\n    const imports = []\n    const importRegex = /^(\\s*)import\\s+(.+?)\\s+from\\s+['\"`]([^'\"`]+)['\"`]/gm\n    \n    let match\n    while ((match = importRegex.exec(content)) !== null) {\n      const importStatement = match[0].trim()\n      const importPath = match[3]\n      \n      imports.push({\n        statement: importStatement,\n        path: importPath,\n        filePath: filePath,\n        isRelative: importPath.startsWith('.'),\n        isExternal: !importPath.startsWith('.')\n      })\n    }\n    \n    return imports\n  }\n\n  /**\n   * Create semantic chunks from extracted elements\n   */\n  createSemanticChunks(functions, types, imports) {\n    const chunks = []\n    \n    // Create function-level chunks\n    for (const func of functions) {\n      const chunk = this.createFunctionChunk(func, types, imports)\n      if (chunk) {\n        chunks.push(chunk)\n      }\n    }\n    \n    // Create type-only chunks for standalone types\n    for (const type of types) {\n      if (!this.isTypeUsedInFunctions(type, functions)) {\n        chunks.push(this.createTypeChunk(type, imports))\n      }\n    }\n    \n    return chunks\n  }\n\n  /**\n   * Create a semantic chunk for a function with its context\n   */\n  createFunctionChunk(func, allTypes, allImports) {\n    let chunkCode = ''\n    const includedImports = new Set()\n    const includedTypes = new Set()\n    \n    // Find relevant imports for this function\n    const fileImports = allImports.filter(imp => imp.filePath === func.filePath)\n    \n    // Find types referenced in the function\n    const referencedTypes = this.findReferencedTypes(func.code, allTypes)\n    \n    // Add necessary imports\n    for (const imp of fileImports) {\n      if (this.isImportRelevant(imp, func.code)) {\n        chunkCode += imp.statement + '\\n'\n        includedImports.add(imp.path)\n      }\n    }\n    \n    // Add referenced types\n    for (const type of referencedTypes) {\n      chunkCode += '\\n' + type.code + '\\n'\n      includedTypes.add(type.name)\n    }\n    \n    // Add the function itself\n    chunkCode += '\\n' + func.code\n    \n    // Create chunk with adaptive sizing - never lose functions\n    let finalCode = chunkCode.trim()\n    let contextLevel = 'full'\n    \n    // If too large, try with reduced context\n    if (chunkCode.length > this.options.maxChunkSize) {\n      // Fallback 1: Function + essential imports only (no types)\n      finalCode = ''\n      for (const imp of fileImports.slice(0, 3)) { // Limit to 3 imports\n        if (this.isImportRelevant(imp, func.code)) {\n          finalCode += imp.statement + '\\n'\n        }\n      }\n      finalCode += '\\n' + func.code\n      contextLevel = 'reduced'\n    }\n    \n    // If still too large, function only\n    if (finalCode.length > this.options.maxChunkSize) {\n      finalCode = func.code\n      contextLevel = 'minimal'\n    }\n    \n    // Always create a chunk - never lose functions\n    return {\n      name: func.name,\n      type: 'function_chunk',\n      subtype: func.type,\n      code: finalCode,\n      size: finalCode.length,\n      filePath: func.filePath,\n      startLine: func.startLine,\n      isExported: func.isExported,\n      isAsync: func.isAsync,\n      complexity: this.calculateComplexity(func.code),\n      includes: {\n        imports: contextLevel === 'minimal' ? [] : Array.from(includedImports),\n        types: contextLevel === 'full' ? Array.from(includedTypes) : []\n      },\n      purpose: this.determinePurpose(func),\n      tags: [...this.generateTags(func), contextLevel === 'full' ? 'full-context' : contextLevel === 'reduced' ? 'reduced-context' : 'minimal-context'],\n      bundles: this.getFileBundles(func.filePath)\n    }\n  }\n\n  /**\n   * Create a chunk for standalone types\n   */\n  createTypeChunk(type, allImports) {\n    let chunkCode = ''\n    \n    // Add relevant imports if any\n    const fileImports = allImports.filter(imp => imp.filePath === type.filePath)\n    for (const imp of fileImports.slice(0, 3)) { // Limit imports\n      chunkCode += imp.statement + '\\n'\n    }\n    \n    chunkCode += '\\n' + type.code\n    \n    return {\n      name: type.name,\n      type: 'type_chunk',\n      subtype: type.type,\n      code: chunkCode.trim(),\n      size: chunkCode.length,\n      filePath: type.filePath,\n      startLine: type.startLine,\n      isExported: type.isExported,\n      purpose: 'Type definition',\n      tags: ['type', type.type],\n      bundles: this.getFileBundles(type.filePath)\n    }\n  }\n\n  /**\n   * Find types referenced in function code\n   */\n  findReferencedTypes(functionCode, allTypes) {\n    const referenced = []\n    \n    for (const type of allTypes) {\n      // Check if type name appears in function code\n      const typeRegex = new RegExp(`\\\\b${type.name}\\\\b`, 'g')\n      if (typeRegex.test(functionCode)) {\n        referenced.push(type)\n      }\n    }\n    \n    return referenced\n  }\n\n  /**\n   * Check if import is relevant to function\n   */\n  isImportRelevant(importStatement, functionCode) {\n    // Simple heuristic: check if any imported identifiers appear in function\n    const importMatch = importStatement.statement.match(/import\\s+(.+?)\\s+from/)\n    if (!importMatch) return false\n    \n    const imported = importMatch[1]\n    \n    // Handle different import styles\n    if (imported.includes('{')) {\n      // Named imports: import { foo, bar } from 'module'\n      const namedImports = imported.match(/\\{([^}]+)\\}/)?.[1]\n      if (namedImports) {\n        const names = namedImports.split(',').map(name => name.trim())\n        return names.some(name => functionCode.includes(name))\n      }\n    } else {\n      // Default import: import foo from 'module'\n      const defaultImport = imported.trim()\n      return functionCode.includes(defaultImport)\n    }\n    \n    return false\n  }\n\n  /**\n   * Check if type is used in any function\n   */\n  isTypeUsedInFunctions(type, functions) {\n    const typeRegex = new RegExp(`\\\\b${type.name}\\\\b`, 'g')\n    return functions.some(func => typeRegex.test(func.code))\n  }\n\n  /**\n   * Calculate function complexity (cyclomatic complexity)\n   */\n  calculateComplexity(code) {\n    let complexity = 1 // Base complexity\n    \n    // Simple complexity indicators - just count control flow structures\n    const indicators = {\n      'if': (code.match(/\\bif\\s*\\(/g) || []).length,\n      'else if': (code.match(/\\belse\\s+if\\b/g) || []).length,\n      'for': (code.match(/\\bfor\\s*\\(/g) || []).length,\n      'while': (code.match(/\\bwhile\\s*\\(/g) || []).length,\n      'switch': (code.match(/\\bswitch\\s*\\(/g) || []).length,\n      'case': (code.match(/\\bcase\\s+/g) || []).length,\n      'catch': (code.match(/\\bcatch\\s*\\(/g) || []).length,\n      'ternary': (code.match(/\\?\\s*[^?\\.\\s]/g) || []).length,\n      'logical_and': (code.match(/&&\\s*[^&=]/g) || []).length,\n      'logical_or': (code.match(/\\|\\|\\s*[^|=]/g) || []).length\n    }\n    \n    // Sum all complexity indicators\n    for (const count of Object.values(indicators)) {\n      complexity += count\n    }\n    \n    // Return complexity with reasonable thresholds\n    return {\n      score: complexity,\n      level: complexity <= 3 ? 'low' : complexity <= 8 ? 'medium' : 'high'\n    }\n  }\n\n  /**\n   * Determine function purpose\n   */\n  determinePurpose(func) {\n    const name = func.name.toLowerCase()\n    \n    if (func.type === 'react_component') return 'React component'\n    if (name.startsWith('use') && func.type === 'function') return 'React hook'\n    if (name.includes('api') || name.includes('endpoint')) return 'API handler'\n    if (name.includes('get') || name.includes('fetch')) return 'Data retrieval'\n    if (name.includes('create') || name.includes('add')) return 'Data creation'\n    if (name.includes('update') || name.includes('edit')) return 'Data modification'\n    if (name.includes('delete') || name.includes('remove')) return 'Data deletion'\n    if (name.includes('validate') || name.includes('check')) return 'Validation'\n    if (name.includes('parse') || name.includes('format')) return 'Data processing'\n    \n    return 'Utility function'\n  }\n\n  /**\n   * Generate tags for function\n   */\n  generateTags(func) {\n    const tags = [func.type]\n    \n    if (func.isExported) tags.push('exported')\n    if (func.isAsync) tags.push('async')\n    if (func.size > 1000) tags.push('large')\n    if (func.code.includes('console.log')) tags.push('has-logging')\n    if (func.code.includes('throw')) tags.push('can-throw')\n    if (func.code.includes('return')) tags.push('returns-value')\n    \n    return tags\n  }\n\n  /**\n   * Determine which bundles a file belongs to\n   */\n  getFileBundles(filePath) {\n    if (!this.bundleConfig?.bundles) return []\n    \n    const bundles = []\n    for (const [bundleName, patterns] of Object.entries(this.bundleConfig.bundles)) {\n      // Skip master bundle as requested\n      if (bundleName === 'master') continue\n      \n      // Check if file matches any pattern in this bundle\n      for (const pattern of patterns) {\n        if (this.matchesPattern(filePath, pattern)) {\n          bundles.push(bundleName)\n          break // Don't add the same bundle multiple times\n        }\n      }\n    }\n    \n    return bundles\n  }\n\n  /**\n   * Simple pattern matching (basic glob support)\n   */\n  matchesPattern(filePath, pattern) {\n    // Convert glob pattern to regex\n    const regex = pattern\n      .replace(/\\*\\*/g, '.*')  // ** matches any directories\n      .replace(/\\*/g, '[^/]*') // * matches any characters except /\n      .replace(/\\./g, '\\\\.')   // Escape dots\n    \n    return new RegExp(`^${regex}$`).test(filePath)\n  }\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"lib/treesitter-semantic-chunker.js\" ext=\".js\">\n        <cntx:meta size=\"47971\" modified=\"2025-06-26T20:26:54.461Z\" lines=\"1485\" />\n        <cntx:content><![CDATA[/**\n * Treesitter-based Semantic Chunker for JavaScript/TypeScript Files\n * Uses tree-sitter for true AST-based code analysis and semantic chunking\n * Supports JS/TS/JSX/TSX with equal treatment\n * Node ecosystem focus: React components, Express APIs, CLI tools, utilities\n */\n\nimport { readFileSync, existsSync } from 'fs'\nimport { extname, basename, dirname, relative, join } from 'path'\nimport glob from 'glob'\nimport { promisify } from 'util'\nimport Parser from 'tree-sitter'\nimport JavaScript from 'tree-sitter-javascript'\nimport TypeScript from 'tree-sitter-typescript'\n\nconst globAsync = promisify(glob)\n\nclass TreesitterSemanticChunker {\n  constructor(options = {}) {\n    this.options = {\n      includeImports: true,\n      includeExports: true,\n      detectComponentTypes: true,\n      groupRelatedFiles: true,\n      minChunkSize: 100,\n      maxChunkSize: 50000,\n      namingStrategy: 'domain-based', // domain-based, pattern-based, graph-based\n      ...options\n    }\n    \n    // Initialize parsers for different languages\n    this.parsers = {}\n    this.initializeParsers()\n    \n    // Semantic patterns for Node ecosystem\n    this.semanticPatterns = {\n      reactComponent: this.isReactComponent.bind(this),\n      reactHook: this.isReactHook.bind(this),\n      expressRoute: this.isExpressRoute.bind(this),\n      expressMiddleware: this.isExpressMiddleware.bind(this),\n      cliCommand: this.isCliCommand.bind(this),\n      utilityFunction: this.isUtilityFunction.bind(this),\n      apiHandler: this.isApiHandler.bind(this),\n      typeDefinition: this.isTypeDefinition.bind(this),\n      configModule: this.isConfigModule.bind(this)\n    }\n  }\n\n  /**\n   * Initialize tree-sitter parsers for different languages\n   */\n  initializeParsers() {\n    // JavaScript parser\n    this.parsers.javascript = new Parser()\n    this.parsers.javascript.setLanguage(JavaScript)\n    \n    // TypeScript parser  \n    this.parsers.typescript = new Parser()\n    this.parsers.typescript.setLanguage(TypeScript.typescript)\n    \n    // TSX parser\n    this.parsers.tsx = new Parser()\n    this.parsers.tsx.setLanguage(TypeScript.tsx)\n  }\n\n  /**\n   * Get appropriate parser for file extension\n   */\n  getParser(filePath) {\n    const ext = extname(filePath)\n    switch (ext) {\n      case '.ts': return this.parsers.typescript\n      case '.tsx': return this.parsers.tsx\n      case '.js':\n      case '.jsx':\n      default: return this.parsers.javascript\n    }\n  }\n\n  /**\n   * Main entry point - analyze files and create semantic chunks\n   */\n  async analyzeProject(projectPath, patterns = ['**/*.{js,jsx,ts,tsx}']) {\n    console.log('🔍 Starting treesitter-based semantic analysis...')\n    \n    const files = await this.findFiles(projectPath, patterns)\n    console.log(`📁 Found ${files.length} files to analyze`)\n    \n    const analysis = await this.analyzeFiles(files, projectPath)\n    const successfulFiles = Object.keys(analysis).filter(f => !analysis[f].error)\n    console.log(`✅ Analyzed ${Object.keys(analysis).length} files (${successfulFiles.length} successful)`)\n    if (successfulFiles.length > 0) {\n      console.log('📝 Sample successful files:', successfulFiles.slice(0, 5))\n    }\n    \n    const relationshipGraph = this.buildRelationshipGraph(analysis)\n    console.log(`🔗 Built relationship graph with ${Object.keys(relationshipGraph).length} nodes`)\n    \n    const chunks = await this.createSmartChunks(analysis, relationshipGraph)\n    console.log(`📦 Created ${chunks.length} semantic chunks`)\n    \n    return {\n      summary: this.generateSummary(analysis, chunks),\n      files: analysis,\n      chunks: chunks,\n      relationshipGraph,\n      recommendations: this.generateRecommendations(analysis, chunks)\n    }\n  }\n\n  /**\n   * Find files matching patterns\n   */\n  async findFiles(projectPath, patterns) {\n    const files = []\n    \n    for (const pattern of patterns) {\n      const matches = await globAsync(pattern, { \n        cwd: projectPath,\n        ignore: [\n          'node_modules/**', 'dist/**', 'build/**', '.git/**', \n          '*.test.*', '*.spec.*', '**/test/**', '**/tests/**',\n          '**/*.min.js', '**/*.bundle.js', '**/coverage/**',\n          '**/.next/**', '**/.cache/**', '**/tmp/**', '**/temp/**'\n        ]\n      })\n      \n      // Extra filter to ensure no node_modules files get through\n      const filteredMatches = matches.filter(file => \n        !file.includes('node_modules') && \n        !file.includes('dist/') &&\n        !file.includes('.min.') &&\n        !file.includes('.bundle.')\n      )\n      \n      files.push(...filteredMatches)\n    }\n    \n    return [...new Set(files)] // Remove duplicates\n  }\n\n  /**\n   * Analyze all files using treesitter\n   */\n  async analyzeFiles(filePaths, projectPath) {\n    const analysis = {}\n    \n    for (const relativePath of filePaths) {\n      // Bulletproof check to skip node_modules\n      if (relativePath.includes('node_modules')) {\n        console.log(`Skipping node_modules file: ${relativePath}`);\n        continue;\n      }\n\n      const fullPath = join(projectPath, relativePath)\n      if (!existsSync(fullPath)) continue\n      \n      try {\n        const content = readFileSync(fullPath, 'utf8')\n        const fileAnalysis = await this.analyzeFile(fullPath, content)\n        fileAnalysis.path = relativePath // Store relative path\n        analysis[relativePath] = fileAnalysis\n      } catch (error) {\n        // Silently skip files that can't be parsed - they won't be included in semantic analysis\n        // This is normal for complex files or unsupported syntax patterns\n        analysis[relativePath] = { error: error.message, path: relativePath }\n      }\n    }\n    \n    return analysis\n  }\n\n  /**\n   * Analyze a single file using treesitter AST\n   */\n  async analyzeFile(filePath, content) {\n    const parser = this.getParser(filePath)\n    \n    // Skip files that are too large or have syntax errors\n    if (content.length > 500000) { // Skip files > 500KB\n      throw new Error('File too large')\n    }\n    \n    let tree, rootNode\n    try {\n      // Use simple string parsing (confirmed working in tests)\n      tree = parser.parse(content)\n      rootNode = tree.rootNode\n      \n      // Check for parse errors\n      if (rootNode.hasError) {\n        throw new Error('Parse error in file')\n      }\n    } catch (error) {\n      throw new Error(`Tree-sitter parse failed: ${error.message}`)\n    }\n    \n    const analysis = {\n      path: filePath,\n      fileName: basename(filePath),\n      dirName: basename(dirname(filePath)),\n      extension: extname(filePath),\n      size: content.length,\n      lines: content.split('\\n').length,\n      \n      // AST-based analysis\n      ast: {\n        functions: this.extractFunctions(rootNode, content),\n        classes: this.extractClasses(rootNode, content),\n        imports: this.extractImports(rootNode, content),\n        exports: this.extractExports(rootNode, content),\n        variables: this.extractVariables(rootNode, content),\n        jsxElements: this.extractJsxElements(rootNode, content),\n        typeDefinitions: this.extractTypeDefinitions(rootNode, content)\n      },\n      \n      // Semantic classification\n      semanticType: this.classifyFileSemantics(rootNode, content, filePath),\n      businessDomain: this.extractBusinessDomain(rootNode, content, filePath),\n      technicalPatterns: this.identifyTechnicalPatterns(rootNode, content),\n      \n      // Relationships\n      dependencies: this.analyzeDependencies(rootNode, content),\n      complexity: this.calculateAstComplexity(rootNode),\n      \n      // Metadata\n      codeSignature: this.generateCodeSignature(rootNode, content)\n    }\n    \n    // Generate semantic tags based on AST analysis\n    analysis.semanticTags = this.generateSemanticTags(analysis)\n    \n    return analysis\n  }\n\n  /**\n   * Extract function declarations from AST\n   */\n  extractFunctions(rootNode, content) {\n    const functions = []\n    \n    // Function declarations\n    const functionDeclarations = this.queryNode(rootNode, '(function_declaration name: (identifier) @name)')\n    functions.push(...functionDeclarations.map(capture => ({\n      name: this.getNodeText(capture.node, content),\n      type: 'function_declaration',\n      startPosition: capture.node.startPosition,\n      endPosition: capture.node.endPosition,\n      isExported: this.isNodeExported(capture.node)\n    })))\n    \n    // Arrow functions\n    const arrowFunctions = this.queryNode(rootNode, '(variable_declarator name: (identifier) @name value: (arrow_function))')\n    functions.push(...arrowFunctions.map(capture => ({\n      name: this.getNodeText(capture.node, content),\n      type: 'arrow_function',\n      startPosition: capture.node.startPosition,\n      endPosition: capture.node.endPosition,\n      isExported: this.isNodeExported(capture.node.parent.parent)\n    })))\n    \n    // Method definitions\n    const methods = this.queryNode(rootNode, '(method_definition name: (property_name) @name)')\n    functions.push(...methods.map(capture => ({\n      name: this.getNodeText(capture.node, content),\n      type: 'method',\n      startPosition: capture.node.startPosition,\n      endPosition: capture.node.endPosition,\n      isExported: false // methods are part of classes\n    })))\n    \n    return functions\n  }\n\n  /**\n   * Extract class declarations from AST\n   */\n  extractClasses(rootNode, content) {\n    const classes = []\n    \n    const classDeclarations = this.queryNode(rootNode, '(class_declaration name: (identifier) @name)')\n    classes.push(...classDeclarations.map(capture => ({\n      name: this.getNodeText(capture.node, content),\n      type: 'class',\n      startPosition: capture.node.startPosition,\n      endPosition: capture.node.endPosition,\n      isExported: this.isNodeExported(capture.node.parent),\n      methods: this.extractClassMethods(capture.node.parent, content)\n    })))\n    \n    return classes\n  }\n\n  /**\n   * Extract class methods\n   */\n  extractClassMethods(classNode, content) {\n    const methods = []\n    \n    try {\n      const methodNodes = this.queryNode(classNode, '(method_definition)')\n      methods.push(...methodNodes.map(capture => ({\n        name: this.getNodeText(capture.node, content),\n        type: 'method',\n        startPosition: capture.node.startPosition,\n        endPosition: capture.node.endPosition\n      })))\n    } catch (error) {\n      // Handle case where method extraction fails\n    }\n    \n    return methods\n  }\n\n  /**\n   * Extract import statements from AST\n   */\n  extractImports(rootNode, content) {\n    const imports = []\n    \n    const importStatements = this.queryNode(rootNode, '(import_statement source: (string) @source)')\n    imports.push(...importStatements.map(capture => {\n      const source = this.getNodeText(capture.node, content).replace(/['\"]/g, '')\n      return {\n        source,\n        statement: this.getNodeText(capture.node.parent, content),\n        isRelative: source.startsWith('.'),\n        isExternal: !source.startsWith('.') && !source.startsWith('/'),\n        importedNames: this.extractImportedNames(capture.node.parent, content)\n      }\n    }))\n    \n    return imports\n  }\n\n  /**\n   * Extract export statements from AST  \n   */\n  extractExports(rootNode, content) {\n    const exports = []\n    \n    // Export declarations\n    const exportDeclarations = this.queryNode(rootNode, '(export_statement)')\n    exports.push(...exportDeclarations.map(capture => {\n      const exportNode = capture.node\n      const declaration = exportNode.namedChild(0)\n      \n      if (declaration) {\n        return {\n          type: declaration.type === 'export_clause' ? 'named' : 'declaration',\n          name: this.extractExportName(declaration, content),\n          statement: this.getNodeText(exportNode, content),\n          isDefault: this.getNodeText(exportNode, content).includes('default')\n        }\n      }\n      return null\n    }).filter(Boolean))\n    \n    return exports\n  }\n\n  /**\n   * Extract variable declarations from AST\n   */\n  extractVariables(rootNode, content) {\n    const variables = []\n    \n    const variableDeclarations = this.queryNode(rootNode, '(variable_declarator name: (identifier) @name)')\n    variables.push(...variableDeclarations.map(capture => ({\n      name: this.getNodeText(capture.node, content),\n      type: 'variable',\n      startPosition: capture.node.startPosition,\n      endPosition: capture.node.endPosition,\n      isExported: this.isNodeExported(capture.node.parent.parent),\n      declarationType: capture.node.parent.parent.type // const, let, var\n    })))\n    \n    return variables\n  }\n\n  /**\n   * Extract JSX elements from AST (for React components)\n   */\n  extractJsxElements(rootNode, content) {\n    const jsxElements = []\n    \n    try {\n      const jsxNodes = this.queryNode(rootNode, '(jsx_element)')\n      jsxElements.push(...jsxNodes.map(capture => ({\n        elementName: this.extractJsxElementName(capture.node, content),\n        startPosition: capture.node.startPosition,\n        endPosition: capture.node.endPosition\n      })))\n    } catch (error) {\n      // JSX might not be available in JavaScript parser\n    }\n    \n    return jsxElements\n  }\n\n  /**\n   * Extract TypeScript type definitions from AST\n   */\n  extractTypeDefinitions(rootNode, content) {\n    const types = []\n    \n    try {\n      // Interface declarations\n      const interfaces = this.queryNode(rootNode, '(interface_declaration name: (type_identifier) @name)')\n      types.push(...interfaces.map(capture => ({\n        name: this.getNodeText(capture.node, content),\n        type: 'interface',\n        startPosition: capture.node.startPosition,\n        endPosition: capture.node.endPosition,\n        isExported: this.isNodeExported(capture.node.parent)\n      })))\n      \n      // Type alias declarations  \n      const typeAliases = this.queryNode(rootNode, '(type_alias_declaration name: (type_identifier) @name)')\n      types.push(...typeAliases.map(capture => ({\n        name: this.getNodeText(capture.node, content),\n        type: 'type_alias',\n        startPosition: capture.node.startPosition,\n        endPosition: capture.node.endPosition,\n        isExported: this.isNodeExported(capture.node.parent)\n      })))\n    } catch (error) {\n      // TypeScript types might not be available in JavaScript parser\n    }\n    \n    return types\n  }\n\n  /**\n   * Classify file semantics based on AST patterns\n   */\n  classifyFileSemantics(rootNode, content, filePath) {\n    const classifications = []\n    \n    // Test each semantic pattern\n    for (const [patternName, patternFn] of Object.entries(this.semanticPatterns)) {\n      if (patternFn(rootNode, content, filePath)) {\n        classifications.push(patternName)\n      }\n    }\n    \n    // Return primary classification (most specific first)\n    const priority = ['reactComponent', 'reactHook', 'expressRoute', 'expressMiddleware', \n                     'cliCommand', 'apiHandler', 'typeDefinition', 'configModule', 'utilityFunction']\n    \n    for (const pattern of priority) {\n      if (classifications.includes(pattern)) {\n        return pattern\n      }\n    }\n    \n    return 'module'\n  }\n\n  /**\n   * Semantic pattern: React Component\n   */\n  isReactComponent(rootNode, content, filePath) {\n    // Check for JSX elements\n    const hasJsx = this.queryNode(rootNode, '(jsx_element)').length > 0\n    \n    // Check for React imports\n    const hasReactImport = content.includes(\"import React\") || content.includes(\"from 'react'\")\n    \n    // Check for component naming pattern\n    const fileName = basename(filePath, extname(filePath))\n    const hasComponentName = fileName[0] === fileName[0].toUpperCase()\n    \n    // Check for function that returns JSX\n    const functions = this.extractFunctions(rootNode, content)\n    const hasComponentFunction = functions.some(fn => \n      fn.isExported && fn.name[0] === fn.name[0].toUpperCase()\n    )\n    \n    return (hasJsx && (hasReactImport || hasComponentName)) || \n           (hasComponentFunction && hasReactImport)\n  }\n\n  /**\n   * Semantic pattern: React Hook\n   */\n  isReactHook(rootNode, content, filePath) {\n    const fileName = basename(filePath, extname(filePath))\n    const hasHookName = fileName.startsWith('use') && fileName[3] === fileName[3].toUpperCase()\n    \n    const functions = this.extractFunctions(rootNode, content)\n    const hasHookFunction = functions.some(fn => \n      fn.name.startsWith('use') && fn.name[3] === fn.name[3].toUpperCase() && fn.isExported\n    )\n    \n    const hasReactHookImports = content.includes(\"from 'react'\") && \n                                (content.includes('useState') || content.includes('useEffect'))\n    \n    return hasHookName || (hasHookFunction && hasReactHookImports)\n  }\n\n  /**\n   * Semantic pattern: Express Route\n   */\n  isExpressRoute(rootNode, content, filePath) {\n    const hasExpressImport = content.includes(\"from 'express'\") || content.includes(\"require('express')\")\n    const hasRouterMethods = /\\.(get|post|put|delete|patch)\\s*\\(/.test(content)\n    const hasRoutePattern = /['\"`]\\/[^'\"`]*['\"`]/.test(content)\n    \n    return hasExpressImport && hasRouterMethods && hasRoutePattern\n  }\n\n  /**\n   * Semantic pattern: Express Middleware\n   */\n  isExpressMiddleware(rootNode, content, filePath) {\n    const hasMiddlewarePattern = /\\(req,\\s*res,\\s*next\\)|function\\s*\\([^)]*req[^)]*res[^)]*next/.test(content)\n    const hasExpressImport = content.includes(\"from 'express'\") || content.includes(\"require('express')\")\n    const fileName = basename(filePath).toLowerCase()\n    \n    return (hasMiddlewarePattern && hasExpressImport) || fileName.includes('middleware')\n  }\n\n  /**\n   * Semantic pattern: CLI Command\n   */\n  isCliCommand(rootNode, content, filePath) {\n    const hasCommanderImport = content.includes('commander') || content.includes('yargs')\n    const hasProcessArgv = content.includes('process.argv')\n    const hasCliPatterns = content.includes('.command(') || content.includes('.option(')\n    const fileName = basename(filePath).toLowerCase()\n    \n    return hasCommanderImport || (hasProcessArgv && hasCliPatterns) || fileName.includes('cli')\n  }\n\n  /**\n   * Semantic pattern: Utility Function\n   */\n  isUtilityFunction(rootNode, content, filePath) {\n    const functions = this.extractFunctions(rootNode, content)\n    const hasMultipleExportedFunctions = functions.filter(fn => fn.isExported).length > 1\n    \n    const fileName = basename(filePath).toLowerCase()\n    const hasUtilityName = fileName.includes('util') || fileName.includes('helper') || fileName.includes('lib')\n    \n    const hasNoDomSpecificImports = !content.includes('react') && !content.includes('express')\n    \n    return hasUtilityName || (hasMultipleExportedFunctions && hasNoDomSpecificImports)\n  }\n\n  /**\n   * Semantic pattern: API Handler\n   */\n  isApiHandler(rootNode, content, filePath) {\n    const hasApiPattern = /api|handler|controller/i.test(filePath)\n    const hasFetchPattern = content.includes('fetch(') || content.includes('axios')\n    const hasHttpMethods = /\\b(GET|POST|PUT|DELETE|PATCH)\\b/.test(content)\n    \n    return hasApiPattern || (hasFetchPattern && hasHttpMethods)\n  }\n\n  /**\n   * Semantic pattern: Type Definition\n   */\n  isTypeDefinition(rootNode, content, filePath) {\n    const types = this.extractTypeDefinitions(rootNode, content)\n    const hasTypeDefinitions = types.length > 0\n    \n    const fileName = basename(filePath).toLowerCase()\n    const hasTypeFileName = fileName.includes('type') || fileName.includes('.d.ts')\n    \n    const hasOnlyTypes = hasTypeDefinitions && \n                        this.extractFunctions(rootNode, content).length === 0 &&\n                        this.extractClasses(rootNode, content).length === 0\n    \n    return hasTypeFileName || hasOnlyTypes\n  }\n\n  /**\n   * Semantic pattern: Config Module\n   */\n  isConfigModule(rootNode, content, filePath) {\n    const fileName = basename(filePath).toLowerCase()\n    const hasConfigName = fileName.includes('config') || fileName.includes('setting')\n    \n    const hasConfigPatterns = content.includes('module.exports') || content.includes('export default')\n    const hasConfigObject = /\\{[\\s\\S]*\\}/.test(content) && !/function|class/.test(content)\n    \n    return hasConfigName && (hasConfigPatterns || hasConfigObject)\n  }\n\n  /**\n   * Extract business domain terms from code\n   */\n  extractBusinessDomain(rootNode, content, filePath) {\n    const domains = []\n    \n    // Focus on meaningful path segments instead of generic business terms\n    const pathSegments = filePath.split('/').filter(s => s && s !== 'src' && s !== 'lib' && s !== 'components')\n    const fileName = basename(filePath, extname(filePath))\n    \n    // Extract domain from directory structure (more reliable than keywords)\n    if (pathSegments.length > 0) {\n      const relevantSegments = pathSegments.slice(-2) // Last 2 directories\n      domains.push(...relevantSegments.map(s => s.toLowerCase()))\n    }\n    \n    // Add meaningful file-based domains\n    if (fileName.toLowerCase().includes('config')) domains.push('configuration')\n    if (fileName.toLowerCase().includes('test')) domains.push('testing')\n    if (fileName.toLowerCase().includes('util')) domains.push('utilities')\n    if (fileName.toLowerCase().includes('api')) domains.push('api')\n    if (fileName.toLowerCase().includes('ui') || fileName.toLowerCase().includes('component')) {\n      domains.push('user-interface')\n    }\n    \n    // Only return meaningful, non-generic domains\n    return [...new Set(domains)].filter(domain => \n      domain.length > 2 && !['web', 'src', 'ts', 'js', 'tsx', 'jsx'].includes(domain)\n    )\n  }\n\n  /**\n   * Identify technical patterns in the code\n   */\n  identifyTechnicalPatterns(rootNode, content) {\n    const patterns = []\n    \n    // Framework patterns\n    if (content.includes('react')) patterns.push('react')\n    if (content.includes('express')) patterns.push('express')\n    if (content.includes('typescript')) patterns.push('typescript')\n    \n    // Architecture patterns\n    if (content.includes('async') && content.includes('await')) patterns.push('async-await')\n    if (content.includes('Promise')) patterns.push('promises')\n    if (content.includes('class') && content.includes('extends')) patterns.push('inheritance')\n    \n    // Design patterns\n    const functions = this.extractFunctions(rootNode, content)\n    if (functions.some(f => f.name.includes('Factory'))) patterns.push('factory-pattern')\n    if (functions.some(f => f.name.includes('Observer'))) patterns.push('observer-pattern')\n    \n    return patterns\n  }\n\n  /**\n   * Build relationship graph between files\n   */\n  buildRelationshipGraph(analysis) {\n    const graph = {}\n    \n    for (const [filePath, fileAnalysis] of Object.entries(analysis)) {\n      if (fileAnalysis.error) continue\n      \n      graph[filePath] = {\n        imports: [],\n        importedBy: [],\n        semanticSimilarity: {},\n        businessDomainOverlap: {},\n        technicalPatternOverlap: {}\n      }\n    }\n    \n    // Build import relationships\n    for (const [filePath, fileAnalysis] of Object.entries(analysis)) {\n      if (fileAnalysis.error) continue\n      \n      for (const imp of fileAnalysis.ast.imports) {\n        if (imp.isRelative) {\n          // Resolve relative import to actual file path\n          const importPath = this.resolveImportPath(filePath, imp.source)\n          if (graph[importPath]) {\n            graph[filePath].imports.push(importPath)\n            graph[importPath].importedBy.push(filePath)\n          }\n        }\n      }\n    }\n    \n    // Calculate semantic similarities\n    for (const [fileA, analysisA] of Object.entries(analysis)) {\n      if (analysisA.error) continue\n      \n      for (const [fileB, analysisB] of Object.entries(analysis)) {\n        if (analysisB.error || fileA === fileB) continue\n        \n        // Semantic type similarity\n        const semanticSimilarity = analysisA.semanticType === analysisB.semanticType ? 1.0 : 0.0\n        \n        // Business domain overlap\n        const domainOverlap = this.calculateOverlap(analysisA.businessDomain, analysisB.businessDomain)\n        \n        // Technical pattern overlap\n        const patternOverlap = this.calculateOverlap(analysisA.technicalPatterns, analysisB.technicalPatterns)\n        \n        if (semanticSimilarity > 0 || domainOverlap > 0 || patternOverlap > 0) {\n          graph[fileA].semanticSimilarity[fileB] = semanticSimilarity\n          graph[fileA].businessDomainOverlap[fileB] = domainOverlap\n          graph[fileA].technicalPatternOverlap[fileB] = patternOverlap\n        }\n      }\n    }\n    \n    return graph\n  }\n\n  /**\n   * Create smart chunks using clustering algorithms\n   */\n  async createSmartChunks(analysis, relationshipGraph) {\n    \n    // Start with individual files as nodes\n    const nodes = Object.keys(analysis).filter(path => !analysis[path].error)\n    console.log(`🧩 Starting with ${nodes.length} nodes for clustering`)\n    \n    // Apply different clustering strategies\n    const strategies = [\n      this.clusterBySemanticType.bind(this),\n      this.clusterByBusinessDomain.bind(this),\n      this.clusterByDependencyGraph.bind(this),\n      this.clusterByDirectoryStructure.bind(this)\n    ]\n    \n    let clusters = nodes.map(node => [node]) // Start with individual nodes\n    \n    // Apply clustering strategies\n    for (const strategy of strategies) {\n      clusters = strategy(clusters, analysis, relationshipGraph)\n      console.log(`📦 After ${strategy.name}: ${clusters.length} clusters`)\n    }\n    \n    // Convert clusters to named chunks\n    const chunks = []\n    const usedNames = new Set()\n    \n    for (const cluster of clusters) {\n      if (cluster.length === 0) continue\n      \n      let chunkName = await this.generateChunkName(cluster, analysis)\n      \n      // Ensure unique names\n      let uniqueName = chunkName\n      let counter = 1\n      while (usedNames.has(uniqueName)) {\n        uniqueName = `${chunkName}-${counter}`\n        counter++\n      }\n      usedNames.add(uniqueName)\n      \n      const chunk = {\n        name: uniqueName,\n        type: this.determineChunkType(cluster, analysis),\n        files: cluster,\n        size: cluster.reduce((sum, file) => sum + analysis[file].size, 0),\n        complexity: this.calculateClusterComplexity(cluster, analysis),\n        dependencies: this.calculateClusterDependencies(cluster, analysis),\n        businessDomains: this.extractClusterBusinessDomains(cluster, analysis),\n        technicalPatterns: this.extractClusterTechnicalPatterns(cluster, analysis),\n        purpose: this.determineClusterPurpose(cluster, analysis),\n        cohesion: this.calculateClusterCohesion(cluster, relationshipGraph),\n        recommendations: this.generateClusterRecommendations(cluster, analysis),\n        tags: this.generateTags(cluster, analysis)\n      }\n      \n      chunks.push(chunk)\n    }\n    \n    return chunks.sort((a, b) => b.cohesion - a.cohesion) // Sort by cohesion (best chunks first)\n  }\n\n  /**\n   * Cluster files by semantic type\n   */\n  clusterBySemanticType(clusters, analysis, relationshipGraph) {\n    const semanticGroups = {}\n    \n    for (const cluster of clusters) {\n      for (const file of cluster) {\n        const semanticType = analysis[file].semanticType\n        if (!semanticGroups[semanticType]) {\n          semanticGroups[semanticType] = []\n        }\n        semanticGroups[semanticType].push(file)\n      }\n    }\n    \n    return Object.values(semanticGroups).filter(group => group.length > 0)\n  }\n\n  /**\n   * Cluster files by business domain\n   */\n  clusterByBusinessDomain(clusters, analysis, relationshipGraph) {\n    const domainGroups = {}\n    \n    for (const cluster of clusters) {\n      for (const file of cluster) {\n        const domains = analysis[file].businessDomain\n        \n        if (domains.length === 0) {\n          // Files with no clear domain go to 'general' group\n          if (!domainGroups.general) domainGroups.general = []\n          domainGroups.general.push(file)\n        } else {\n          // Files go to their primary domain group\n          const primaryDomain = domains[0]\n          if (!domainGroups[primaryDomain]) domainGroups[primaryDomain] = []\n          domainGroups[primaryDomain].push(file)\n        }\n      }\n    }\n    \n    return Object.values(domainGroups).filter(group => group.length > 0)\n  }\n\n  /**\n   * Cluster files by dependency relationships\n   */\n  clusterByDependencyGraph(clusters, analysis, relationshipGraph) {\n    const dependencyGroups = []\n    const visited = new Set()\n    \n    for (const cluster of clusters) {\n      for (const file of cluster) {\n        if (visited.has(file)) continue\n        \n        // Find all files connected to this file through imports\n        const connected = this.findConnectedFiles(file, relationshipGraph, new Set())\n        \n        // Filter to only files in current clusters\n        const relevantConnected = connected.filter(f => \n          clusters.some(cluster => cluster.includes(f))\n        )\n        \n        if (relevantConnected.length > 1) {\n          dependencyGroups.push(relevantConnected)\n          relevantConnected.forEach(f => visited.add(f))\n        } else {\n          // Isolated file becomes its own group\n          dependencyGroups.push([file])\n          visited.add(file)\n        }\n      }\n    }\n    \n    return dependencyGroups.filter(group => group.length > 0)\n  }\n\n  /**\n   * Cluster files by directory structure\n   */\n  clusterByDirectoryStructure(clusters, analysis, relationshipGraph) {\n    const directoryGroups = {}\n    \n    for (const cluster of clusters) {\n      for (const file of cluster) {\n        const dir = dirname(file)\n        if (!directoryGroups[dir]) {\n          directoryGroups[dir] = []\n        }\n        directoryGroups[dir].push(file)\n      }\n    }\n    \n    return Object.values(directoryGroups).filter(group => group.length > 0)\n  }\n\n  /**\n   * Generate intelligent chunk name\n   */\n  async generateChunkName(files, analysis) {\n    const namingStrategies = {\n      domainBased: this.generateDomainBasedName.bind(this),\n      patternBased: this.generatePatternBasedName.bind(this),\n      functionalityBased: this.generateFunctionalityBasedName.bind(this)\n    }\n    \n    const names = {}\n    \n    for (const [strategy, generator] of Object.entries(namingStrategies)) {\n      try {\n        names[strategy] = generator(files, analysis)\n      } catch (error) {\n        names[strategy] = 'unnamed-chunk'\n      }\n    }\n    \n    // Choose best name based on strategy preference - prefer pattern-based for better names\n    const strategy = 'patternBased' // Force pattern-based naming\n    return names[strategy] || names.patternBased || names.functionalityBased || names.domainBased || 'unknown-chunk'\n  }\n\n  /**\n   * Generate domain-based chunk name\n   */\n  generateDomainBasedName(files, analysis) {\n    // Always fallback to pattern-based naming since domain extraction is unreliable\n    return this.generatePatternBasedName(files, analysis)\n  }\n\n  /**\n   * Generate pattern-based chunk name\n   */\n  generatePatternBasedName(files, analysis) {\n    const semanticTypes = files.map(file => analysis[file].semanticType)\n    const mostCommon = this.getMostCommon(semanticTypes)\n    \n    // Look at actual file names and directories for context\n    const commonPath = this.findCommonPath(files)\n    const dirName = commonPath ? basename(dirname(commonPath)) : null\n    \n    const typeNames = {\n      reactComponent: 'ui-components',\n      reactHook: 'react-hooks', \n      expressRoute: 'server-routes',\n      expressMiddleware: 'server-middleware',\n      utilityFunction: 'utility-functions',\n      typeDefinition: 'type-definitions',\n      configModule: 'configuration',\n      cliCommand: 'cli-tools',\n      apiHandler: 'api-endpoints',\n      module: 'shared-modules'\n    }\n    \n    let baseName = typeNames[mostCommon] || 'mixed-files'\n    \n    // Add more specific context based on file paths\n    if (commonPath) {\n      if (commonPath.includes('/components/ui/')) {\n        baseName = 'ui-library-components'\n      } else if (commonPath.includes('/components/')) {\n        baseName = 'application-components'\n      } else if (commonPath.includes('/hooks/')) {\n        baseName = 'custom-hooks'\n      } else if (commonPath.includes('/lib/')) {\n        baseName = 'core-utilities'\n      } else if (commonPath.includes('/utils/')) {\n        baseName = 'helper-utilities'\n      } else if (dirName && dirName !== 'src' && dirName !== 'components' && dirName !== 'lib') {\n        baseName = `${dirName}-${baseName}`\n      }\n    }\n    \n    return baseName\n  }\n\n  /**\n   * Generate functionality-based chunk name\n   */\n  generateFunctionalityBasedName(files, analysis) {\n    // Extract function names and find common themes\n    const allFunctions = files.flatMap(file => \n      analysis[file].ast.functions.map(fn => fn.name.toLowerCase())\n    )\n    \n    const commonWords = this.extractCommonWords(allFunctions)\n    \n    if (commonWords.length > 0) {\n      return commonWords.slice(0, 2).join('-') + '-logic'\n    }\n    \n    // Fallback to directory-based naming\n    const dirs = files.map(file => basename(dirname(file)))\n    const commonDir = this.getMostCommon(dirs)\n    \n    return commonDir + '-module'\n  }\n\n  /**\n   * Helper methods for AST analysis\n   */\n\n  queryNode(node, query) {\n    // Simplified query implementation\n    // In a full implementation, you'd use tree-sitter's query language\n    const results = []\n    \n    const traverse = (currentNode) => {\n      // Match based on node type for now\n      if (query.includes(currentNode.type)) {\n        results.push({ node: currentNode })\n      }\n      \n      for (let i = 0; i < currentNode.namedChildCount; i++) {\n        traverse(currentNode.namedChild(i))\n      }\n    }\n    \n    traverse(node)\n    return results\n  }\n\n  getNodeText(node, content) {\n    return content.slice(node.startIndex, node.endIndex)\n  }\n\n  isNodeExported(node) {\n    // Check if node is part of an export statement\n    let parent = node.parent\n    while (parent) {\n      if (parent.type === 'export_statement') {\n        return true\n      }\n      parent = parent.parent\n    }\n    return false\n  }\n\n  calculateOverlap(arrayA, arrayB) {\n    const setA = new Set(arrayA)\n    const setB = new Set(arrayB)\n    const intersection = new Set([...setA].filter(x => setB.has(x)))\n    const union = new Set([...setA, ...setB])\n    \n    return union.size === 0 ? 0 : intersection.size / union.size\n  }\n\n  getMostCommon(arr) {\n    const counts = {}\n    for (const item of arr) {\n      counts[item] = (counts[item] || 0) + 1\n    }\n    \n    return Object.entries(counts)\n      .sort(([,a], [,b]) => b - a)[0]?.[0] || 'unknown'\n  }\n\n  generateSemanticTags(analysis) {\n    const tags = []\n    \n    tags.push(analysis.semanticType)\n    tags.push(...analysis.businessDomain)\n    tags.push(...analysis.technicalPatterns)\n    \n    if (analysis.complexity.level) {\n      tags.push(`complexity-${analysis.complexity.level}`)\n    }\n    \n    if (analysis.lines < 50) tags.push('small')\n    else if (analysis.lines < 200) tags.push('medium')  \n    else tags.push('large')\n    \n    return [...new Set(tags)]\n  }\n\n  calculateAstComplexity(rootNode) {\n    let complexity = 1\n    \n    const complexityNodes = ['if_statement', 'while_statement', 'for_statement', \n                            'switch_statement', 'try_statement', 'catch_clause']\n    \n    const traverse = (node) => {\n      if (complexityNodes.includes(node.type)) {\n        complexity++\n      }\n      \n      for (let i = 0; i < node.namedChildCount; i++) {\n        traverse(node.namedChild(i))\n      }\n    }\n    \n    traverse(rootNode)\n    \n    return {\n      score: complexity,\n      level: complexity < 5 ? 'low' : complexity < 15 ? 'medium' : 'high'\n    }\n  }\n\n  /**\n   * Analyze dependencies from AST\n   */\n  analyzeDependencies(rootNode, content) {\n    const dependencies = {\n      internal: [],\n      external: [],\n      relative: []\n    }\n    \n    const imports = this.extractImports(rootNode, content)\n    \n    for (const imp of imports) {\n      if (imp.isRelative) {\n        dependencies.relative.push(imp.source)\n      } else if (imp.isExternal) {\n        dependencies.external.push(imp.source)\n      } else {\n        dependencies.internal.push(imp.source)\n      }\n    }\n    \n    return dependencies\n  }\n\n  /**\n   * Resolve relative import path to absolute path\n   */\n  resolveImportPath(fromFile, importPath) {\n    // Simplified path resolution\n    const dir = dirname(fromFile)\n    return join(dir, importPath)\n  }\n\n  /**\n   * Find all files connected through imports\n   */\n  findConnectedFiles(startFile, relationshipGraph, visited = new Set()) {\n    if (visited.has(startFile)) return []\n    \n    visited.add(startFile)\n    const connected = [startFile]\n    \n    if (relationshipGraph[startFile]) {\n      // Follow imports\n      for (const importedFile of relationshipGraph[startFile].imports) {\n        connected.push(...this.findConnectedFiles(importedFile, relationshipGraph, visited))\n      }\n      \n      // Follow files that import this one\n      for (const importingFile of relationshipGraph[startFile].importedBy) {\n        connected.push(...this.findConnectedFiles(importingFile, relationshipGraph, visited))\n      }\n    }\n    \n    return [...new Set(connected)]\n  }\n\n  /**\n   * Extract imported names from import statement\n   */\n  extractImportedNames(importNode, content) {\n    const names = []\n    // Simplified implementation - would need more complex parsing\n    const importText = this.getNodeText(importNode, content)\n    const match = importText.match(/import\\s+(?:\\{([^}]+)\\}|(\\w+))/i)\n    if (match) {\n      if (match[1]) {\n        // Named imports\n        names.push(...match[1].split(',').map(n => n.trim()))\n      } else if (match[2]) {\n        // Default import\n        names.push(match[2])\n      }\n    }\n    return names\n  }\n\n  /**\n   * Extract export name from export declaration\n   */\n  extractExportName(declaration, content) {\n    const text = this.getNodeText(declaration, content)\n    const match = text.match(/(?:function|class|const|let|var)\\s+(\\w+)/)\n    return match ? match[1] : 'unnamed'\n  }\n\n  /**\n   * Extract JSX element name\n   */\n  extractJsxElementName(jsxNode, content) {\n    try {\n      const openingElement = jsxNode.namedChild(0)\n      if (openingElement) {\n        const nameNode = openingElement.namedChild(0)\n        return nameNode ? this.getNodeText(nameNode, content) : 'unknown'\n      }\n    } catch (error) {\n      return 'unknown'\n    }\n    return 'unknown'\n  }\n\n  /**\n   * Determine chunk type based on files\n   */\n  determineChunkType(files, analysis) {\n    const semanticTypes = files.map(file => analysis[file].semanticType)\n    const mostCommon = this.getMostCommon(semanticTypes)\n    \n    const typeMapping = {\n      reactComponent: 'ui-components',\n      reactHook: 'custom-hooks',\n      expressRoute: 'api-routes',\n      expressMiddleware: 'middleware',\n      utilityFunction: 'utilities',\n      typeDefinition: 'type-definitions',\n      configModule: 'configuration',\n      cliCommand: 'cli-commands',\n      apiHandler: 'api-handlers'\n    }\n    \n    return typeMapping[mostCommon] || 'mixed-module'\n  }\n\n  /**\n   * Calculate cluster complexity\n   */\n  calculateClusterComplexity(files, analysis) {\n    const complexities = files.map(file => analysis[file].complexity.score)\n    const total = complexities.reduce((sum, c) => sum + c, 0)\n    const average = total / files.length\n    \n    return {\n      total,\n      average,\n      level: average < 5 ? 'low' : average < 15 ? 'medium' : 'high'\n    }\n  }\n\n  /**\n   * Calculate cluster dependencies\n   */\n  calculateClusterDependencies(files, analysis) {\n    const allDeps = {\n      internal: new Set(),\n      external: new Set(),\n      relative: new Set()\n    }\n    \n    for (const file of files) {\n      const deps = analysis[file].dependencies\n      deps.internal.forEach(dep => allDeps.internal.add(dep))\n      deps.external.forEach(dep => allDeps.external.add(dep))\n      deps.relative.forEach(dep => allDeps.relative.add(dep))\n    }\n    \n    return {\n      internal: Array.from(allDeps.internal),\n      external: Array.from(allDeps.external),\n      relative: Array.from(allDeps.relative),\n      totalCount: allDeps.internal.size + allDeps.external.size + allDeps.relative.size\n    }\n  }\n\n  /**\n   * Extract cluster business domains\n   */\n  extractClusterBusinessDomains(files, analysis) {\n    const allDomains = files.flatMap(file => analysis[file].businessDomain)\n    return [...new Set(allDomains)]\n  }\n\n  /**\n   * Extract cluster technical patterns\n   */\n  extractClusterTechnicalPatterns(files, analysis) {\n    const allPatterns = files.flatMap(file => analysis[file].technicalPatterns)\n    return [...new Set(allPatterns)]\n  }\n\n  /**\n   * Determine cluster purpose\n   */\n  determineClusterPurpose(files, analysis) {\n    const semanticTypes = files.map(file => analysis[file].semanticType)\n    const mostCommon = this.getMostCommon(semanticTypes)\n    \n    const purposeMapping = {\n      reactComponent: 'User interface components and React elements',\n      reactHook: 'Custom React hooks for state and logic sharing',\n      expressRoute: 'API routes and endpoint handlers',\n      expressMiddleware: 'Express middleware and request processing',\n      utilityFunction: 'Utility functions and helper libraries',\n      typeDefinition: 'TypeScript type definitions and interfaces',\n      configModule: 'Configuration files and settings',\n      cliCommand: 'Command-line interface and CLI tools',\n      apiHandler: 'API client and data fetching logic'\n    }\n    \n    return purposeMapping[mostCommon] || 'Mixed functionality module'\n  }\n\n  /**\n   * Calculate cluster cohesion\n   */\n  calculateClusterCohesion(files, relationshipGraph) {\n    if (files.length <= 1) return 1.0\n    \n    let connections = 0\n    let totalPossible = files.length * (files.length - 1)\n    \n    for (const fileA of files) {\n      for (const fileB of files) {\n        if (fileA !== fileB && relationshipGraph[fileA]) {\n          if (relationshipGraph[fileA].imports.includes(fileB) ||\n              relationshipGraph[fileA].importedBy.includes(fileB) ||\n              relationshipGraph[fileA].semanticSimilarity[fileB] > 0.5) {\n            connections++\n          }\n        }\n      }\n    }\n    \n    return totalPossible > 0 ? connections / totalPossible : 0\n  }\n\n  /**\n   * Generate cluster recommendations\n   */\n  generateClusterRecommendations(files, analysis) {\n    const recommendations = []\n    \n    const totalSize = files.reduce((sum, file) => sum + analysis[file].size, 0)\n    const avgComplexity = files.reduce((sum, file) => sum + analysis[file].complexity.score, 0) / files.length\n    \n    if (totalSize > 100000) {\n      recommendations.push({\n        type: 'warning',\n        message: 'Large cluster - consider splitting by functionality'\n      })\n    }\n    \n    if (avgComplexity > 20) {\n      recommendations.push({\n        type: 'warning', \n        message: 'High complexity cluster - review for refactoring opportunities'\n      })\n    }\n    \n    if (files.length === 1) {\n      recommendations.push({\n        type: 'info',\n        message: 'Single file cluster - consider grouping with related files'\n      })\n    }\n    \n    return recommendations\n  }\n\n  /**\n   * Extract common words from function names\n   */\n  extractCommonWords(functionNames) {\n    const words = functionNames.flatMap(name => \n      name.split(/(?=[A-Z])|_|-/).filter(word => word.length > 2)\n    )\n    \n    const wordCounts = {}\n    for (const word of words) {\n      wordCounts[word] = (wordCounts[word] || 0) + 1\n    }\n    \n    return Object.entries(wordCounts)\n      .filter(([, count]) => count > 1)\n      .sort(([, a], [, b]) => b - a)\n      .slice(0, 3)\n      .map(([word]) => word)\n  }\n\n  /**\n   * Generate code signature for caching and similarity comparison\n   */\n  generateCodeSignature(rootNode, content) {\n    const functions = this.extractFunctions(rootNode, content)\n    const classes = this.extractClasses(rootNode, content)\n    const imports = this.extractImports(rootNode, content)\n    const exports = this.extractExports(rootNode, content)\n    \n    return {\n      functionCount: functions.length,\n      classCount: classes.length,\n      importCount: imports.length,\n      exportCount: exports.length,\n      exportedFunctions: functions.filter(f => f.isExported).map(f => f.name),\n      importSources: imports.map(i => i.source),\n      hasJsx: this.extractJsxElements(rootNode, content).length > 0,\n      contentHash: this.simpleHash(content)\n    }\n  }\n\n  /**\n   * Simple hash function for content comparison\n   */\n  simpleHash(str) {\n    let hash = 0\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i)\n      hash = ((hash << 5) - hash) + char\n      hash = hash & hash // Convert to 32bit integer\n    }\n    return hash\n  }\n  \n  generateSummary(analysis, chunks) {\n    const files = Object.values(analysis).filter(f => !f.error)\n    \n    return {\n      totalFiles: files.length,\n      totalSize: files.reduce((sum, f) => sum + f.size, 0),\n      totalLines: files.reduce((sum, f) => sum + f.lines, 0),\n      semanticTypes: this.countByProperty(files, 'semanticType'),\n      businessDomains: this.countDomains(files),\n      technicalPatterns: this.countPatterns(files),\n      totalChunks: chunks.length,\n      averageChunkSize: chunks.reduce((sum, c) => sum + c.size, 0) / chunks.length,\n      chunkTypes: this.countByProperty(chunks, 'type')\n    }\n  }\n\n  generateRecommendations(analysis, chunks) {\n    const recommendations = []\n    \n    // Add specific recommendations based on treesitter analysis\n    \n    return recommendations\n  }\n\n  countByProperty(items, property) {\n    const counts = {}\n    for (const item of items) {\n      const value = typeof property === 'function' ? property(item) : item[property]\n      counts[value] = (counts[value] || 0) + 1\n    }\n    return counts\n  }\n\n  countDomains(files) {\n    const allDomains = files.flatMap(f => f.businessDomain)\n    return this.countByProperty(allDomains, d => d)\n  }\n\n  countPatterns(files) {\n    const allPatterns = files.flatMap(f => f.technicalPatterns)\n    return this.countByProperty(allPatterns, p => p)\n  }\n\n  /**\n   * Generate tags for a chunk based on its characteristics\n   */\n  generateTags(files, analysis) {\n    const tags = new Set()\n    \n    // Add semantic type tags\n    const semanticTypes = files.map(file => analysis[file].semanticType)\n    for (const type of semanticTypes) {\n      if (type === 'reactComponent') tags.add('react-component')\n      if (type === 'reactHook') tags.add('react-hook')\n      if (type === 'utilityFunction') tags.add('utility')\n      if (type === 'expressRoute') tags.add('api')\n      if (type === 'configModule') tags.add('config')\n    }\n    \n    // Add directory-based tags\n    const commonPath = this.findCommonPath(files)\n    if (commonPath) {\n      if (commonPath.includes('/components/')) tags.add('component')\n      if (commonPath.includes('/hooks/')) tags.add('hook')\n      if (commonPath.includes('/lib/')) tags.add('library')\n      if (commonPath.includes('/utils/')) tags.add('utility')\n      if (commonPath.includes('/ui/')) tags.add('ui-library')\n    }\n    \n    // Add complexity tags\n    const avgComplexity = files.reduce((sum, file) => sum + analysis[file].complexity.score, 0) / files.length\n    if (avgComplexity > 15) tags.add('complex')\n    if (avgComplexity < 5) tags.add('simple')\n    \n    return Array.from(tags)\n  }\n\n  /**\n   * Find common path prefix for a group of files\n   */\n  findCommonPath(files) {\n    if (files.length === 0) return null\n    if (files.length === 1) return files[0]\n    \n    const pathParts = files.map(file => file.split('/'))\n    const commonParts = []\n    \n    for (let i = 0; i < Math.min(...pathParts.map(p => p.length)); i++) {\n      const part = pathParts[0][i]\n      if (pathParts.every(p => p[i] === part)) {\n        commonParts.push(part)\n      } else {\n        break\n      }\n    }\n    \n    return commonParts.length > 0 ? commonParts.join('/') : null\n  }\n}\n\nexport default TreesitterSemanticChunker]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/vite-env.d.ts\" ext=\".ts\">\n        <cntx:meta size=\"38\" modified=\"2025-06-06T22:55:53.337Z\" lines=\"2\" />\n        <cntx:content><![CDATA[/// <reference types=\"vite/client\" />\n]]></cntx:content>\n      </cntx:file>\n    </cntx:group>\n  </cntx:files>\n</cntx:bundle>",
    "lastGenerated": "2025-06-26T23:06:21.936Z",
    "size": 503696
  },
  "server": {
    "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<cntx:bundle xmlns:cntx=\"https://cntx.dev/schema\" name=\"server\" generated=\"2025-06-26T23:00:14.430Z\">\n  <cntx:project>\n    <cntx:name>cntx-ui</cntx:name>\n    <cntx:version>2.0.12</cntx:version>\n    <cntx:description>File context management tool with web UI and MCP server for AI development workflows - bundle project files for LLM consumption</cntx:description>\n  </cntx:project>\n  <cntx:overview>\n    <cntx:purpose>Main server application and core backend functionality</cntx:purpose>\n    <cntx:file-types>\n      <cntx:type name=\"tests\" count=\"4\" />\n      <cntx:type name=\"other\" count=\"12\" />\n    </cntx:file-types>\n    <cntx:entry-points>\n      <cntx:file>server.js</cntx:file>\n    </cntx:entry-points>\n  </cntx:overview>\n  <cntx:files count=\"16\">\n    <cntx:group type=\"entry-points\" description=\"Main entry files for this bundle\">\n      <cntx:file path=\"server.js\" ext=\".js\" role=\"server-entry\">\n        <cntx:meta size=\"71642\" modified=\"2025-06-26T22:26:54.262Z\" lines=\"2164\" />\n        <cntx:content><![CDATA[import { readFileSync, writeFileSync, existsSync, mkdirSync, watch, readdirSync, statSync } from 'fs';\nimport { join, dirname, relative, extname, basename } from 'path';\nimport { createServer } from 'http';\nimport { WebSocketServer } from 'ws';\nimport { fileURLToPath } from 'url';\nimport path from 'path';\nimport { startMCPTransport } from './lib/mcp-transport.js';\nimport SemanticSplitter from './lib/semantic-splitter.js';\nimport { homedir } from 'os';\n\nconst __dirname = dirname(fileURLToPath(import.meta.url));\n\nfunction getContentType(filePath) {\n  const ext = path.extname(filePath).toLowerCase();\n  const contentTypes = {\n    '.html': 'text/html',\n    '.js': 'application/javascript',\n    '.css': 'text/css',\n    '.json': 'application/json',\n    '.png': 'image/png',\n    '.jpg': 'image/jpeg',\n    '.gif': 'image/gif',\n    '.svg': 'image/svg+xml',\n    '.ico': 'image/x-icon'\n  };\n  return contentTypes[ext] || 'text/plain';\n}\n\nexport class CntxServer {\n  constructor(cwd = process.cwd(), options = {}) {\n    this.CWD = cwd;\n    this.CNTX_DIR = join(cwd, '.cntx');\n    this.isQuietMode = options.quiet || false;\n    this.CONFIG_FILE = join(this.CNTX_DIR, 'config.json');\n    this.BUNDLES_FILE = join(this.CNTX_DIR, 'bundles.json');\n    this.HIDDEN_FILES_CONFIG = join(this.CNTX_DIR, 'hidden-files.json');\n    this.IGNORE_FILE = join(cwd, '.cntxignore');\n    this.CURSOR_RULES_FILE = join(cwd, '.cursorrules');\n    this.CLAUDE_MD_FILE = join(cwd, 'CLAUDE.md');\n\n    this.bundles = new Map();\n    this.ignorePatterns = [];\n    this.watchers = [];\n    this.clients = new Set();\n    this.isScanning = false;\n    this.mcpServer = null;\n    this.mcpServerStarted = false;\n\n    this.hiddenFilesConfig = {\n      globalHidden: [], // Files hidden across all bundles\n      bundleSpecific: {}, // Files hidden per bundle: { bundleName: [filePaths] }\n      userIgnorePatterns: [], // User-added ignore patterns\n      disabledSystemPatterns: [] // System patterns the user disabled\n    };\n\n    // Semantic splitting (parallel to bundle system)\n    this.semanticSplitter = new SemanticSplitter({\n      maxChunkSize: 2000,\n      includeContext: true,\n      groupRelated: true,\n      minFunctionSize: 50\n    });\n    this.semanticCache = null;\n    this.lastSemanticAnalysis = null;\n  }\n\n  init() {\n    if (!existsSync(this.CNTX_DIR)) mkdirSync(this.CNTX_DIR, { recursive: true });\n    this.loadConfig();\n    this.loadHiddenFilesConfig();\n    this.loadIgnorePatterns();\n    this.loadBundleStates();\n    this.startWatching();\n    this.generateAllBundles();\n  }\n\n  loadConfig() {\n    // Clear existing bundles to ensure deleted ones are removed\n    this.bundles.clear();\n\n    if (existsSync(this.CONFIG_FILE)) {\n      const config = JSON.parse(readFileSync(this.CONFIG_FILE, 'utf8'));\n      Object.entries(config.bundles || {}).forEach(([name, patterns]) => {\n        this.bundles.set(name, {\n          patterns: Array.isArray(patterns) ? patterns : [patterns],\n          files: [],\n          content: '',\n          changed: false,\n          lastGenerated: null,\n          size: 0\n        });\n      });\n    }\n\n    if (!this.bundles.has('master')) {\n      this.bundles.set('master', {\n        patterns: ['**/*'],\n        files: [],\n        content: '',\n        changed: false,\n        lastGenerated: null,\n        size: 0\n      });\n    }\n  }\n\n  loadHiddenFilesConfig() {\n    if (existsSync(this.HIDDEN_FILES_CONFIG)) {\n      try {\n        const config = JSON.parse(readFileSync(this.HIDDEN_FILES_CONFIG, 'utf8'));\n        this.hiddenFilesConfig = { ...this.hiddenFilesConfig, ...config };\n      } catch (e) {\n        if (!this.isQuietMode) console.warn('Could not load hidden files config:', e.message);\n      }\n    }\n  }\n\n  saveHiddenFilesConfig() {\n    try {\n      writeFileSync(this.HIDDEN_FILES_CONFIG, JSON.stringify(this.hiddenFilesConfig, null, 2));\n    } catch (e) {\n      if (!this.isQuietMode) console.error('Failed to save hidden files config:', e.message);\n    }\n  }\n\n  isFileHidden(filePath, bundleName = null) {\n    // Check global hidden files\n    if (this.hiddenFilesConfig.globalHidden.includes(filePath)) {\n      return true;\n    }\n\n    // Check bundle-specific hidden files\n    if (bundleName && this.hiddenFilesConfig.bundleSpecific[bundleName]) {\n      return this.hiddenFilesConfig.bundleSpecific[bundleName].includes(filePath);\n    }\n\n    return false;\n  }\n\n  toggleFileVisibility(filePath, bundleName = null, forceHide = null) {\n    if (bundleName) {\n      // Bundle-specific hiding\n      if (!this.hiddenFilesConfig.bundleSpecific[bundleName]) {\n        this.hiddenFilesConfig.bundleSpecific[bundleName] = [];\n      }\n\n      const bundleHidden = this.hiddenFilesConfig.bundleSpecific[bundleName];\n      const isCurrentlyHidden = bundleHidden.includes(filePath);\n\n      if (forceHide === null) {\n        // Toggle current state\n        if (isCurrentlyHidden) {\n          this.hiddenFilesConfig.bundleSpecific[bundleName] = bundleHidden.filter(f => f !== filePath);\n        } else {\n          bundleHidden.push(filePath);\n        }\n      } else {\n        // Force to specific state\n        if (forceHide && !isCurrentlyHidden) {\n          bundleHidden.push(filePath);\n        } else if (!forceHide && isCurrentlyHidden) {\n          this.hiddenFilesConfig.bundleSpecific[bundleName] = bundleHidden.filter(f => f !== filePath);\n        }\n      }\n    } else {\n      // Global hiding\n      const isCurrentlyHidden = this.hiddenFilesConfig.globalHidden.includes(filePath);\n\n      if (forceHide === null) {\n        // Toggle current state\n        if (isCurrentlyHidden) {\n          this.hiddenFilesConfig.globalHidden = this.hiddenFilesConfig.globalHidden.filter(f => f !== filePath);\n        } else {\n          this.hiddenFilesConfig.globalHidden.push(filePath);\n        }\n      } else {\n        // Force to specific state\n        if (forceHide && !isCurrentlyHidden) {\n          this.hiddenFilesConfig.globalHidden.push(filePath);\n        } else if (!forceHide && isCurrentlyHidden) {\n          this.hiddenFilesConfig.globalHidden = this.hiddenFilesConfig.globalHidden.filter(f => f !== filePath);\n        }\n      }\n    }\n\n    this.saveHiddenFilesConfig();\n  }\n\n  bulkToggleFileVisibility(filePaths, bundleName = null, forceHide = null) {\n    filePaths.forEach(filePath => {\n      this.toggleFileVisibility(filePath, bundleName, forceHide);\n    });\n  }\n\n  addUserIgnorePattern(pattern) {\n    if (!this.hiddenFilesConfig.userIgnorePatterns.includes(pattern)) {\n      this.hiddenFilesConfig.userIgnorePatterns.push(pattern);\n      this.saveHiddenFilesConfig();\n      this.loadIgnorePatterns();\n      this.generateAllBundles();\n      return true;\n    }\n    return false;\n  }\n\n  removeUserIgnorePattern(pattern) {\n    const index = this.hiddenFilesConfig.userIgnorePatterns.indexOf(pattern);\n    if (index > -1) {\n      this.hiddenFilesConfig.userIgnorePatterns.splice(index, 1);\n      this.saveHiddenFilesConfig();\n      this.loadIgnorePatterns();\n      this.generateAllBundles();\n      return true;\n    }\n    return false;\n  }\n\n  toggleSystemIgnorePattern(pattern) {\n    const index = this.hiddenFilesConfig.disabledSystemPatterns.indexOf(pattern);\n    if (index > -1) {\n      // Re-enable the pattern\n      this.hiddenFilesConfig.disabledSystemPatterns.splice(index, 1);\n    } else {\n      // Disable the pattern\n      this.hiddenFilesConfig.disabledSystemPatterns.push(pattern);\n    }\n\n    this.saveHiddenFilesConfig();\n    this.loadIgnorePatterns();\n    this.generateAllBundles();\n  }\n\n  loadIgnorePatterns() {\n    const systemPatterns = [\n      // Version control\n      '**/.git/**',\n      '**/.svn/**',\n      '**/.hg/**',\n\n      // Dependencies\n      '**/node_modules/**',\n      '**/vendor/**',\n      '**/.pnp/**',\n\n      // Build outputs\n      '**/dist/**',\n      '**/build/**',\n      '**/out/**',\n      '**/.next/**',\n      '**/.nuxt/**',\n      '**/target/**',\n\n      // Package files\n      '**/*.tgz',\n      '**/*.tar.gz',\n      '**/*.zip',\n      '**/*.rar',\n      '**/*.7z',\n\n      // Logs\n      '**/*.log',\n      '**/logs/**',\n\n      // Cache directories\n      '**/.cache/**',\n      '**/.parcel-cache/**',\n      '**/.nyc_output/**',\n      '**/coverage/**',\n      '**/.pytest_cache/**',\n      '**/__pycache__/**',\n\n      // IDE/Editor files\n      '**/.vscode/**',\n      '**/.idea/**',\n      '**/*.swp',\n      '**/*.swo',\n      '**/*~',\n\n      // OS files\n      '**/.DS_Store',\n      '**/Thumbs.db',\n      '**/desktop.ini',\n\n      // Environment files\n      '**/.env',\n      '**/.env.local',\n      '**/.env.*.local',\n\n      // Lock files\n      '**/package-lock.json',\n      '**/yarn.lock',\n      '**/pnpm-lock.yaml',\n      '**/Cargo.lock',\n\n      // cntx-ui specific\n      '**/.cntx/**'\n    ];\n\n    // Read from .cntxignore file\n    let filePatterns = [];\n    if (existsSync(this.IGNORE_FILE)) {\n      filePatterns = readFileSync(this.IGNORE_FILE, 'utf8')\n        .split('\\n')\n        .map(line => line.trim())\n        .filter(line => line && !line.startsWith('#'));\n    }\n\n    // Combine all patterns\n    this.ignorePatterns = [\n      // System patterns (filtered by disabled list)\n      ...systemPatterns.filter(pattern =>\n        !this.hiddenFilesConfig.disabledSystemPatterns.includes(pattern)\n      ),\n      // File patterns\n      ...filePatterns.filter(pattern =>\n        !systemPatterns.includes(pattern) &&\n        !this.hiddenFilesConfig.userIgnorePatterns.includes(pattern)\n      ),\n      // User-added patterns\n      ...this.hiddenFilesConfig.userIgnorePatterns\n    ];\n\n    // Update .cntxignore file with current patterns\n    const allPatterns = [\n      '# System patterns',\n      ...systemPatterns.map(pattern =>\n        this.hiddenFilesConfig.disabledSystemPatterns.includes(pattern)\n          ? `# ${pattern}`\n          : pattern\n      ),\n      '',\n      '# User patterns',\n      ...this.hiddenFilesConfig.userIgnorePatterns,\n      '',\n      '# File-specific patterns (edit manually)',\n      ...filePatterns.filter(pattern =>\n        !systemPatterns.includes(pattern) &&\n        !this.hiddenFilesConfig.userIgnorePatterns.includes(pattern)\n      )\n    ];\n\n    writeFileSync(this.IGNORE_FILE, allPatterns.join('\\n'));\n  }\n\n  loadBundleStates() {\n    if (existsSync(this.BUNDLES_FILE)) {\n      try {\n        const savedBundles = JSON.parse(readFileSync(this.BUNDLES_FILE, 'utf8'));\n        Object.entries(savedBundles).forEach(([name, data]) => {\n          if (this.bundles.has(name)) {\n            const bundle = this.bundles.get(name);\n            bundle.content = data.content || '';\n            bundle.lastGenerated = data.lastGenerated;\n            bundle.size = data.size || 0;\n          }\n        });\n      } catch (e) {\n        if (!this.isQuietMode) console.warn('Could not load bundle states:', e.message);\n      }\n    }\n  }\n\n  saveBundleStates() {\n    const bundleStates = {};\n    this.bundles.forEach((bundle, name) => {\n      bundleStates[name] = {\n        content: bundle.content,\n        lastGenerated: bundle.lastGenerated,\n        size: bundle.size\n      };\n    });\n    writeFileSync(this.BUNDLES_FILE, JSON.stringify(bundleStates, null, 2));\n  }\n\n  // Cursor Rules Methods\n  loadCursorRules() {\n    if (existsSync(this.CURSOR_RULES_FILE)) {\n      return readFileSync(this.CURSOR_RULES_FILE, 'utf8');\n    }\n    return this.getDefaultCursorRules();\n  }\n\n  getDefaultCursorRules() {\n    // Get project info for context\n    let projectInfo = { name: 'unknown', description: '', type: 'general' };\n    const pkgPath = join(this.CWD, 'package.json');\n\n    if (existsSync(pkgPath)) {\n      try {\n        const pkg = JSON.parse(readFileSync(pkgPath, 'utf8'));\n        projectInfo = {\n          name: pkg.name || 'unknown',\n          description: pkg.description || '',\n          type: this.detectProjectType(pkg)\n        };\n      } catch (e) {\n        // Use defaults\n      }\n    }\n\n    return this.generateCursorRulesTemplate(projectInfo);\n  }\n\n  detectProjectType(pkg) {\n    const deps = { ...pkg.dependencies, ...pkg.devDependencies };\n\n    if (deps.react || deps['@types/react']) return 'react';\n    if (deps.vue || deps['@vue/cli']) return 'vue';\n    if (deps.angular || deps['@angular/core']) return 'angular';\n    if (deps.express || deps.fastify || deps.koa) return 'node';\n    if (deps.next || deps.nuxt || deps.gatsby) return 'fullstack';\n    if (deps.typescript || deps['@types/node']) return 'typescript';\n    if (pkg.type === 'module' || deps.vite || deps.webpack) return 'modern-js';\n\n    return 'general';\n  }\n\n  generateCursorRulesTemplate(projectInfo) {\n    const bundlesList = Array.from(this.bundles.keys()).join(', ');\n\n    const templates = {\n      react: `# ${projectInfo.name} - React Project Rules\n\n## Project Context\n- **Project**: ${projectInfo.name}\n- **Type**: React Application\n- **Description**: ${projectInfo.description}\n\n## Development Guidelines\n\n### Code Style\n- Use TypeScript for all new components\n- Prefer functional components with hooks\n- Use Tailwind CSS for styling\n- Follow React best practices and hooks rules\n\n### File Organization\n- Components in \\`src/components/\\`\n- Custom hooks in \\`src/hooks/\\`\n- Utilities in \\`src/lib/\\`\n- Types in \\`src/types/\\`\n\n### Naming Conventions\n- PascalCase for components\n- camelCase for functions and variables\n- kebab-case for files and folders\n- Use descriptive, meaningful names\n\n### Bundle Context\nThis project uses cntx-ui for file bundling. Current bundles: ${bundlesList}\n- **ui**: React components and styles\n- **api**: API routes and utilities  \n- **config**: Configuration files\n- **docs**: Documentation\n\n### AI Assistant Instructions\n- When suggesting code changes, consider the current bundle structure\n- Prioritize TypeScript and modern React patterns\n- Suggest Tailwind classes for styling\n- Keep components focused and reusable\n- Always include proper TypeScript types\n- Consider bundle organization when suggesting file locations\n\n## Custom Rules\nAdd your specific project rules and preferences below:\n\n### Team Preferences\n- [Add team coding standards]\n- [Add preferred libraries/frameworks]\n- [Add project-specific guidelines]\n\n### Architecture Notes\n- [Document key architectural decisions]\n- [Note important patterns to follow]\n- [List critical dependencies]\n`,\n\n      node: `# ${projectInfo.name} - Node.js Project Rules\n\n## Project Context\n- **Project**: ${projectInfo.name}\n- **Type**: Node.js Backend\n- **Description**: ${projectInfo.description}\n\n## Development Guidelines\n\n### Code Style\n- Use ES modules (import/export)\n- TypeScript preferred for type safety\n- Follow Node.js best practices\n- Use async/await over promises\n\n### File Organization\n- Routes in \\`src/routes/\\`\n- Middleware in \\`src/middleware/\\`\n- Models in \\`src/models/\\`\n- Utilities in \\`src/utils/\\`\n\n### Bundle Context\nThis project uses cntx-ui for file bundling. Current bundles: ${bundlesList}\n- **api**: Core API logic and routes\n- **config**: Environment and configuration\n- **docs**: API documentation\n\n### AI Assistant Instructions\n- Focus on scalable backend architecture\n- Suggest proper error handling\n- Consider security best practices\n- Optimize for performance and maintainability\n- Consider bundle organization when suggesting file locations\n\n## Custom Rules\nAdd your specific project rules and preferences below:\n\n### Team Preferences\n- [Add team coding standards]\n- [Add preferred libraries/frameworks]\n- [Add project-specific guidelines]\n\n### Architecture Notes\n- [Document key architectural decisions]\n- [Note important patterns to follow]\n- [List critical dependencies]\n`,\n\n      general: `# ${projectInfo.name} - Project Rules\n\n## Project Context\n- **Project**: ${projectInfo.name}\n- **Description**: ${projectInfo.description}\n\n## Development Guidelines\n\n### Code Quality\n- Write clean, readable code\n- Follow consistent naming conventions\n- Add comments for complex logic\n- Maintain proper file organization\n\n### Bundle Management\nThis project uses cntx-ui for intelligent file bundling. Current bundles: ${bundlesList}\n- **master**: Complete project overview\n- **config**: Configuration and setup files\n- **docs**: Documentation and README files\n\n### AI Assistant Instructions\n- When helping with code, consider the project structure\n- Suggest improvements for maintainability\n- Follow established patterns in the codebase\n- Help optimize bundle configurations when needed\n- Consider bundle organization when suggesting file locations\n\n## Custom Rules\nAdd your specific project rules and preferences below:\n\n### Team Preferences\n- [Add team coding standards]\n- [Add preferred libraries/frameworks]\n- [Add project-specific guidelines]\n\n### Architecture Notes\n- [Document key architectural decisions]\n- [Note important patterns to follow]\n- [List critical dependencies]\n`\n    };\n\n    return templates[projectInfo.type] || templates.general;\n  }\n\n  saveCursorRules(content) {\n    writeFileSync(this.CURSOR_RULES_FILE, content, 'utf8');\n  }\n\n  loadClaudeMd() {\n    if (existsSync(this.CLAUDE_MD_FILE)) {\n      return readFileSync(this.CLAUDE_MD_FILE, 'utf8');\n    }\n    return this.getDefaultClaudeMd();\n  }\n\n  getDefaultClaudeMd() {\n    // Get project info for context\n    let projectInfo = { name: 'unknown', description: '', type: 'general' };\n    const pkgPath = join(this.CWD, 'package.json');\n\n    if (existsSync(pkgPath)) {\n      try {\n        const pkg = JSON.parse(readFileSync(pkgPath, 'utf8'));\n        projectInfo = {\n          name: pkg.name || 'unknown',\n          description: pkg.description || '',\n          type: this.detectProjectType(pkg)\n        };\n      } catch (e) {\n        // Use defaults if package.json is invalid\n      }\n    }\n\n    return this.generateClaudeMdTemplate(projectInfo);\n  }\n\n  generateClaudeMdTemplate(projectInfo) {\n    const { name, description, type } = projectInfo;\n\n    let template = `# ${name}\n\n${description ? `${description}\\n\\n` : ''}## Project Structure\n\nThis project uses cntx-ui for bundle management and AI context organization.\n\n### Bundles\n\n`;\n\n    // Add bundle information\n    this.bundles.forEach((bundle, bundleName) => {\n      template += `- **${bundleName}**: ${bundle.files.length} files\\n`;\n    });\n\n    template += `\n### Development Guidelines\n\n- Follow the existing code style and patterns\n- Use TypeScript for type safety\n- Write meaningful commit messages\n- Test changes thoroughly\n\n### Key Files\n\n- \\`.cntx/config.json\\` - Bundle configuration\n- \\`.cursorrules\\` - AI assistant rules\n- \\`CLAUDE.md\\` - Project context for Claude\n`;\n\n    if (type === 'react') {\n      template += `\n### React Specific\n\n- Use functional components with hooks\n- Follow React best practices\n- Use TypeScript interfaces for props\n`;\n    } else if (type === 'node') {\n      template += `\n### Node.js Specific\n\n- Use ES modules (import/export)\n- Follow async/await patterns\n- Proper error handling\n`;\n    }\n\n    return template;\n  }\n\n  saveClaudeMd(content) {\n    writeFileSync(this.CLAUDE_MD_FILE, content, 'utf8');\n  }\n\n  shouldIgnoreFile(filePath) {\n    const relativePath = relative(this.CWD, filePath).replace(/\\\\\\\\/g, '/');\n\n    // Hard-coded critical ignores\n    if (relativePath.startsWith('node_modules/')) return true;\n    if (relativePath.startsWith('.git/')) return true;\n    if (relativePath.startsWith('.cntx/')) return true;\n\n    return this.ignorePatterns.some(pattern => this.matchesPattern(relativePath, pattern));\n  }\n\n  matchesPattern(path, pattern) {\n    if (pattern === '**/*') return true;\n    if (pattern === '*') return !path.includes('/');\n    if (pattern === path) return true;\n\n    let regexPattern = pattern\n      .replace(/\\\\/g, '/')\n      .replace(/\\./g, '\\\\.')\n      .replace(/\\?/g, '.');\n\n    regexPattern = regexPattern.replace(/\\*\\*/g, 'DOUBLESTAR');\n    regexPattern = regexPattern.replace(/\\*/g, '[^/]*');\n    regexPattern = regexPattern.replace(/DOUBLESTAR/g, '.*');\n\n    try {\n      const regex = new RegExp('^' + regexPattern + '$');\n      return regex.test(path);\n    } catch (e) {\n      if (!this.isQuietMode) console.log(`Regex error for pattern \"${pattern}\": ${e.message}`);\n      return false;\n    }\n  }\n\n  shouldIgnoreAnything(itemName, fullPath) {\n    // DIRECTORY NAME IGNORES (anywhere in the project)\n    const badDirectories = [\n      'node_modules',\n      '.git',\n      '.svn',\n      '.hg',\n      'vendor',\n      '__pycache__',\n      '.pytest_cache',\n      '.venv',\n      'venv',\n      'env',\n      '.env',\n      'dist',\n      'build',\n      'out',\n      '.next',\n      '.nuxt',\n      'coverage',\n      '.nyc_output',\n      '.cache',\n      '.parcel-cache',\n      '.vercel',\n      '.netlify',\n      'tmp',\n      'temp',\n      '.tmp',\n      '.temp',\n      'logs',\n      '*.egg-info',\n      '.cntx'\n    ];\n\n    if (badDirectories.includes(itemName)) {\n      return true;\n    }\n\n    // FILE EXTENSION IGNORES\n    const badExtensions = [\n      // Logs\n      '.log', '.logs',\n      // OS files\n      '.DS_Store', '.Thumbs.db', 'desktop.ini',\n      // Editor files\n      '.vscode', '.idea', '*.swp', '*.swo', '*~',\n      // Media files (large and useless for AI)\n      '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.webp', '.svg',\n      '.mp4', '.avi', '.mov', '.wmv', '.flv', '.webm', '.mkv',\n      '.mp3', '.wav', '.flac', '.aac', '.ogg', '.wma',\n      '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx',\n      '.zip', '.tar', '.gz', '.rar', '.7z', '.bz2',\n      '.exe', '.dll', '.so', '.dylib', '.app', '.dmg', '.pkg',\n      // Cache/temp files\n      '.cache', '.tmp', '.temp', '.lock',\n      // Compiled files\n      '.pyc', '.pyo', '.class', '.o', '.obj', '.a', '.lib'\n    ];\n\n    const fileExt = extname(itemName).toLowerCase();\n    if (badExtensions.includes(fileExt)) {\n      return true;\n    }\n\n    // FILE NAME PATTERNS\n    const badFilePatterns = [\n      /^\\..*/, // Hidden files starting with .\n      /.*\\.lock$/, // Lock files\n      /.*\\.min\\.js$/, // Minified JS\n      /.*\\.min\\.css$/, // Minified CSS\n      /.*\\.map$/, // Source maps\n      /package-lock\\.json$/,\n      /yarn\\.lock$/,\n      /pnpm-lock\\.yaml$/,\n      /Thumbs\\.db$/,\n      /\\.DS_Store$/\n    ];\n\n    if (badFilePatterns.some(pattern => pattern.test(itemName))) {\n      return true;\n    }\n\n    // PATH-BASED IGNORES (from your .cntxignore)\n    return this.ignorePatterns.some(pattern => this.matchesPattern(fullPath, pattern));\n  }\n\n  getAllFiles(dir = this.CWD, files = []) {\n    try {\n      const items = readdirSync(dir);\n      for (const item of items) {\n        const fullPath = join(dir, item);\n        const relativePath = relative(this.CWD, fullPath).replace(/\\\\\\\\/g, '/');\n\n        // BULLETPROOF IGNORES - check directory/file names directly\n        const shouldIgnore = this.shouldIgnoreAnything(item, relativePath);\n\n        if (shouldIgnore) {\n          continue; // Don't even log it, just skip\n        }\n\n        const stat = statSync(fullPath);\n        if (stat.isDirectory()) {\n          this.getAllFiles(fullPath, files);\n        } else {\n          files.push(relativePath);\n        }\n      }\n    } catch (e) {\n      // Skip directories we can't read\n    }\n\n    return files;\n  }\n\n  startWatching() {\n    const watcher = watch(this.CWD, { recursive: true }, (eventType, filename) => {\n      if (filename && !this.isScanning) {\n        const fullPath = join(this.CWD, filename);\n        if (!this.shouldIgnoreFile(fullPath)) {\n          if (!this.isQuietMode) console.log(`File ${eventType}: ${filename}`);\n          this.markBundlesChanged(filename.replace(/\\\\\\\\/g, '/'));\n          this.invalidateSemanticCache(); // Invalidate semantic cache on file changes\n          this.broadcastUpdate();\n        }\n      }\n    });\n    this.watchers.push(watcher);\n  }\n\n  getFileTree() {\n    const allFiles = this.getAllFiles();\n    const fileData = allFiles.map(file => {\n      const fullPath = join(this.CWD, file);\n      try {\n        const stat = statSync(fullPath);\n        return {\n          path: file,\n          size: stat.size,\n          modified: stat.mtime\n        };\n      } catch (e) {\n        return {\n          path: file,\n          size: 0,\n          modified: new Date()\n        };\n      }\n    });\n    return fileData;\n  }\n\n  markBundlesChanged(filename) {\n    this.bundles.forEach((bundle, name) => {\n      if (bundle.patterns.some(pattern => this.matchesPattern(filename, pattern))) {\n        bundle.changed = true;\n      }\n    });\n  }\n\n  generateAllBundles() {\n    this.isScanning = true;\n    if (!this.isQuietMode) console.log('Scanning files and generating bundles...');\n\n    this.bundles.forEach((bundle, name) => {\n      this.generateBundle(name);\n    });\n\n    this.saveBundleStates();\n    this.isScanning = false;\n    if (!this.isQuietMode) console.log('Bundle generation complete');\n  }\n\n  generateBundle(name) {\n    const bundle = this.bundles.get(name);\n    if (!bundle) return;\n\n    if (!this.isQuietMode) console.log(`Generating bundle: ${name}`);\n    const allFiles = this.getAllFiles();\n\n    // Filter files by bundle patterns\n    let bundleFiles = allFiles.filter(file =>\n      bundle.patterns.some(pattern => this.matchesPattern(file, pattern))\n    );\n\n    // Remove hidden files\n    bundleFiles = bundleFiles.filter(file => !this.isFileHidden(file, name));\n\n    bundle.files = bundleFiles;\n    bundle.content = this.generateBundleXML(name, bundle.files);\n    bundle.changed = false;\n    bundle.lastGenerated = new Date().toISOString();\n    bundle.size = Buffer.byteLength(bundle.content, 'utf8');\n\n    if (!this.isQuietMode) console.log(`Generated bundle '${name}' with ${bundle.files.length} files (${(bundle.size / 1024).toFixed(1)}kb)`);\n  }\n\n  generateBundleXML(bundleName, files) {\n    let xml = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<cntx:bundle xmlns:cntx=\"https://cntx.dev/schema\" name=\"${bundleName}\" generated=\"${new Date().toISOString()}\">\n`;\n\n    // Project information\n    const pkgPath = join(this.CWD, 'package.json');\n    if (existsSync(pkgPath)) {\n      try {\n        const pkg = JSON.parse(readFileSync(pkgPath, 'utf8'));\n        xml += `  <cntx:project>\n    <cntx:name>${this.escapeXml(pkg.name || 'unknown')}</cntx:name>\n    <cntx:version>${pkg.version || '0.0.0'}</cntx:version>\n`;\n        if (pkg.description) xml += `    <cntx:description>${this.escapeXml(pkg.description)}</cntx:description>\n`;\n        xml += `  </cntx:project>\n`;\n      } catch (e) {\n        xml += `  <cntx:project><cntx:error>Could not parse package.json</cntx:error></cntx:project>\n`;\n      }\n    }\n\n    // Bundle overview section\n    const filesByType = this.categorizeFiles(files);\n    const entryPoints = this.identifyEntryPoints(files);\n\n    xml += `  <cntx:overview>\n    <cntx:purpose>${this.escapeXml(this.getBundlePurpose(bundleName))}</cntx:purpose>\n    <cntx:file-types>\n`;\n\n    Object.entries(filesByType).forEach(([type, typeFiles]) => {\n      xml += `      <cntx:type name=\"${type}\" count=\"${typeFiles.length}\" />\n`;\n    });\n\n    xml += `    </cntx:file-types>\n`;\n\n    if (entryPoints.length > 0) {\n      xml += `    <cntx:entry-points>\n`;\n      entryPoints.forEach(file => {\n        xml += `      <cntx:file>${file}</cntx:file>\n`;\n      });\n      xml += `    </cntx:entry-points>\n`;\n    }\n\n    xml += `  </cntx:overview>\n`;\n\n    // Files organized by type\n    xml += `  <cntx:files count=\"${files.length}\">\n`;\n\n    // Entry points first\n    if (entryPoints.length > 0) {\n      xml += `    <cntx:group type=\"entry-points\" description=\"Main entry files for this bundle\">\n`;\n      entryPoints.forEach(file => {\n        xml += this.generateFileXML(file);\n      });\n      xml += `    </cntx:group>\n`;\n    }\n\n    // Then organize by file type\n    Object.entries(filesByType).forEach(([type, typeFiles]) => {\n      if (type === 'entry-points') return; // Already handled above\n\n      const remainingFiles = typeFiles.filter(file => !entryPoints.includes(file));\n      if (remainingFiles.length > 0) {\n        xml += `    <cntx:group type=\"${type}\" description=\"${this.getTypeDescription(type)}\">\n`;\n        remainingFiles.forEach(file => {\n          xml += this.generateFileXML(file);\n        });\n        xml += `    </cntx:group>\n`;\n      }\n    });\n\n    xml += `  </cntx:files>\n</cntx:bundle>`;\n    return xml;\n  }\n\n  categorizeFiles(files) {\n    const categories = {\n      'components': [],\n      'hooks': [],\n      'utilities': [],\n      'configuration': [],\n      'styles': [],\n      'types': [],\n      'tests': [],\n      'documentation': [],\n      'other': []\n    };\n\n    files.forEach(file => {\n      const ext = extname(file).toLowerCase();\n      const basename = file.toLowerCase();\n\n      if (basename.includes('component') || file.includes('/components/') ||\n        ext === '.jsx' || ext === '.tsx' && !basename.includes('test')) {\n        categories.components.push(file);\n      } else if (basename.includes('hook') || file.includes('/hooks/')) {\n        categories.hooks.push(file);\n      } else if (basename.includes('util') || file.includes('/utils/') ||\n        basename.includes('helper') || file.includes('/lib/')) {\n        categories.utilities.push(file);\n      } else if (ext === '.json' || basename.includes('config') ||\n        ext === '.yaml' || ext === '.yml' || ext === '.toml') {\n        categories.configuration.push(file);\n      } else if (ext === '.css' || ext === '.scss' || ext === '.less') {\n        categories.styles.push(file);\n      } else if (basename.includes('type') || ext === '.d.ts' ||\n        file.includes('/types/')) {\n        categories.types.push(file);\n      } else if (basename.includes('test') || basename.includes('spec') ||\n        file.includes('/test/') || file.includes('/__tests__/')) {\n        categories.tests.push(file);\n      } else if (ext === '.md' || basename.includes('readme') ||\n        basename.includes('doc')) {\n        categories.documentation.push(file);\n      } else {\n        categories.other.push(file);\n      }\n    });\n\n    // Remove empty categories\n    Object.keys(categories).forEach(key => {\n      if (categories[key].length === 0) {\n        delete categories[key];\n      }\n    });\n\n    return categories;\n  }\n\n  identifyEntryPoints(files) {\n    const entryPoints = [];\n\n    files.forEach(file => {\n      const basename = file.toLowerCase();\n\n      // Common entry point patterns\n      if (basename.includes('main.') || basename.includes('index.') ||\n        basename.includes('app.') || basename === 'server.js' ||\n        file.endsWith('/App.tsx') || file.endsWith('/App.jsx') ||\n        file.endsWith('/main.tsx') || file.endsWith('/main.js') ||\n        file.endsWith('/index.tsx') || file.endsWith('/index.js')) {\n        entryPoints.push(file);\n      }\n    });\n\n    return entryPoints;\n  }\n\n  getBundlePurpose(bundleName) {\n    const purposes = {\n      'master': 'Complete project overview with all source files',\n      'frontend': 'User interface components, pages, and client-side logic',\n      'backend': 'Server-side logic, APIs, and backend services',\n      'api': 'API endpoints, routes, and server communication logic',\n      'server': 'Main server application and core backend functionality',\n      'components': 'Reusable UI components and interface elements',\n      'ui-components': 'User interface components and design system elements',\n      'config': 'Configuration files, settings, and environment setup',\n      'docs': 'Documentation, README files, and project guides',\n      'utils': 'Utility functions, helpers, and shared libraries',\n      'types': 'TypeScript type definitions and interfaces',\n      'tests': 'Test files, test utilities, and testing configuration'\n    };\n\n    return purposes[bundleName] || `Bundle containing ${bundleName}-related files`;\n  }\n\n  getTypeDescription(type) {\n    const descriptions = {\n      'components': 'React/UI components and interface elements',\n      'hooks': 'Custom React hooks and state management',\n      'utilities': 'Helper functions, utilities, and shared libraries',\n      'configuration': 'Configuration files, settings, and build configs',\n      'styles': 'CSS, SCSS, and styling files',\n      'types': 'TypeScript type definitions and interfaces',\n      'tests': 'Test files and testing utilities',\n      'documentation': 'README files, docs, and guides',\n      'other': 'Additional project files'\n    };\n\n    return descriptions[type] || `Files categorized as ${type}`;\n  }\n\n  generateFileXML(file) {\n    const fullPath = join(this.CWD, file);\n    let fileXml = `      <cntx:file path=\"${file}\" ext=\"${extname(file)}\">\n`;\n\n    try {\n      const stat = statSync(fullPath);\n      const content = readFileSync(fullPath, 'utf8');\n\n      // Add role indicator for certain files\n      const role = this.getFileRole(file);\n      const roleAttr = role ? ` role=\"${role}\"` : '';\n\n      fileXml = `      <cntx:file path=\"${file}\" ext=\"${extname(file)}\"${roleAttr}>\n`;\n      fileXml += `        <cntx:meta size=\"${stat.size}\" modified=\"${stat.mtime.toISOString()}\" lines=\"${content.split('\\n').length}\" />\n        <cntx:content><![CDATA[${content}]]></cntx:content>\n`;\n    } catch (e) {\n      fileXml += `        <cntx:error>Could not read file: ${e.message}</cntx:error>\n`;\n    }\n\n    fileXml += `      </cntx:file>\n`;\n    return fileXml;\n  }\n\n  getFileRole(file) {\n    const basename = file.toLowerCase();\n\n    if (basename.includes('main.') || basename.includes('index.')) return 'entry-point';\n    if (basename.includes('app.')) return 'main-component';\n    if (file === 'server.js') return 'server-entry';\n    if (basename.includes('config')) return 'configuration';\n    if (basename.includes('package.json')) return 'package-config';\n    if (basename.includes('readme')) return 'documentation';\n\n    return null;\n  }\n\n  escapeXml(text) {\n    return String(text)\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&apos;');\n  }\n\n  getFileStats(filePath) {\n    try {\n      const fullPath = join(this.CWD, filePath);\n      const stat = statSync(fullPath);\n      return {\n        size: stat.size,\n        mtime: stat.mtime\n      };\n    } catch (e) {\n      return {\n        size: 0,\n        mtime: new Date()\n      };\n    }\n  }\n\n  getFileListWithVisibility(bundleName = null) {\n    const allFiles = this.getAllFiles();\n\n    return allFiles.map(filePath => {\n      const fileStats = this.getFileStats(filePath);\n      const isGloballyHidden = this.hiddenFilesConfig.globalHidden.includes(filePath);\n      const bundleHidden = bundleName ? this.isFileHidden(filePath, bundleName) : false;\n\n      // Determine which bundles this file appears in\n      const inBundles = [];\n      this.bundles.forEach((bundle, name) => {\n        const matchesPattern = bundle.patterns.some(pattern => this.matchesPattern(filePath, pattern));\n        const notHidden = !this.isFileHidden(filePath, name);\n        if (matchesPattern && notHidden) {\n          inBundles.push(name);\n        }\n      });\n\n      return {\n        path: filePath,\n        size: fileStats.size,\n        modified: fileStats.mtime,\n        visible: !isGloballyHidden && !bundleHidden,\n        globallyHidden: isGloballyHidden,\n        bundleHidden: bundleHidden,\n        inBundles: inBundles,\n        matchesIgnorePattern: this.shouldIgnoreFile(join(this.CWD, filePath))\n      };\n    });\n  }\n\n  startServer(port = 3333) {\n    const server = createServer((req, res) => {\n      const url = new URL(req.url, `http://localhost:${port}`);\n\n      // CORS headers for ALL requests - MUST be first\n      res.setHeader('Access-Control-Allow-Origin', '*');\n      res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');\n      res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n      res.setHeader('Access-Control-Max-Age', '86400');\n\n      // Handle preflight OPTIONS requests\n      if (req.method === 'OPTIONS') {\n        res.writeHead(200);\n        res.end();\n        return;\n      }\n\n      // Serve static files for web interface\n      if (url.pathname === '/' || url.pathname.startsWith('/assets/') || url.pathname.endsWith('.js') || url.pathname.endsWith('.css') || url.pathname.endsWith('.ico')) {\n        const webDistPath = path.join(__dirname, 'web', 'dist');\n\n        if (url.pathname === '/') {\n          // Serve index.html for root\n          const indexPath = path.join(webDistPath, 'index.html');\n          if (existsSync(indexPath)) {\n            try {\n              const content = readFileSync(indexPath, 'utf8');\n              res.writeHead(200, { 'Content-Type': 'text/html' });\n              res.end(content);\n              return;\n            } catch (e) {\n              if (!this.isQuietMode) console.error('Error serving index.html:', e);\n            }\n          }\n\n          // Fallback if no web interface built\n          res.writeHead(200, { 'Content-Type': 'text/html' });\n          res.end(`\n          <!DOCTYPE html>\n          <html>\n            <head>\n              <title>cntx-ui Server</title>\n              <style>\n                body { font-family: system-ui, sans-serif; margin: 40px; }\n                .container { max-width: 600px; }\n                .api-link { background: #f5f5f5; padding: 10px; border-radius: 5px; margin: 10px 0; }\n                code { background: #f0f0f0; padding: 2px 5px; border-radius: 3px; }\n              </style>\n            </head>\n            <body>\n              <div class=\"container\">\n                <h1>🚀 cntx-ui Server Running</h1>\n                <p>Your cntx-ui server is running successfully!</p>\n                \n                <h2>Available APIs:</h2>\n                <div class=\"api-link\">\n                  <strong>Bundles:</strong> <a href=\"/api/bundles\">/api/bundles</a>\n                </div>\n                <div class=\"api-link\">\n                  <strong>Configuration:</strong> <a href=\"/api/config\">/api/config</a>\n                </div>\n                <div class=\"api-link\">\n                  <strong>Files:</strong> <a href=\"/api/files\">/api/files</a>\n                </div>\n                <div class=\"api-link\">\n                  <strong>Status:</strong> <a href=\"/api/status\">/api/status</a>\n                </div>\n                \n                <h2>Web Interface:</h2>\n                <p>The web interface is not available because it wasn't built when this package was published.</p>\n                <p>To enable the web interface, the package maintainer needs to run:</p>\n                <pre><code>cd web && npm install && npm run build</code></pre>\n                \n                <h2>CLI Usage:</h2>\n                <p>You can still use all CLI commands:</p>\n                <ul>\n                  <li><code>cntx-ui status</code> - Check current status</li>\n                  <li><code>cntx-ui bundle master</code> - Generate specific bundle</li>\n                  <li><code>cntx-ui init</code> - Initialize configuration</li>\n                </ul>\n              </div>\n            </body>\n          </html>\n        `);\n          return;\n        } else {\n          // Serve other static assets\n          const filePath = path.join(webDistPath, url.pathname);\n          if (existsSync(filePath)) {\n            try {\n              const content = readFileSync(filePath);\n              const contentType = getContentType(filePath);\n              res.writeHead(200, { 'Content-Type': contentType });\n              res.end(content);\n              return;\n            } catch (e) {\n              if (!this.isQuietMode) console.error('Error serving static file:', e);\n            }\n          }\n        }\n      }\n\n      // API Routes\n      console.log('🔍 Processing API request:', url.pathname);\n\n      if (url.pathname === '/api/bundles') {\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        const bundleData = Array.from(this.bundles.entries()).map(([name, bundle]) => ({\n          name,\n          changed: bundle.changed,\n          fileCount: bundle.files.length,\n          content: bundle.content.substring(0, 5000) + (bundle.content.length > 5000 ? '...' : ''),\n          files: bundle.files,\n          lastGenerated: bundle.lastGenerated,\n          size: bundle.size\n        }));\n        res.end(JSON.stringify(bundleData));\n\n      } else if (url.pathname === '/api/semantic-chunks') {\n        console.log('🔍 Semantic chunks route matched! URL:', url.pathname);\n        this.getSemanticAnalysis()\n          .then(analysis => {\n            console.log('✅ Semantic analysis successful');\n            res.writeHead(200, { 'Content-Type': 'application/json' });\n            res.end(JSON.stringify(analysis));\n          })\n          .catch(error => {\n            console.error('❌ Semantic analysis failed:', error.message);\n            res.writeHead(500, { 'Content-Type': 'application/json' });\n            res.end(JSON.stringify({ error: error.message }));\n          });\n\n      } else if (url.pathname === '/api/semantic-chunks/export') {\n        if (req.method === 'POST') {\n          let body = '';\n          req.on('data', chunk => body += chunk);\n          req.on('end', () => {\n            try {\n              const { chunkName } = JSON.parse(body);\n              this.exportSemanticChunk(chunkName)\n                .then(xmlContent => {\n                  res.writeHead(200, { 'Content-Type': 'application/xml' });\n                  res.end(xmlContent);\n                })\n                .catch(error => {\n                  res.writeHead(500, { 'Content-Type': 'application/json' });\n                  res.end(JSON.stringify({ error: error.message }));\n                });\n            } catch (error) {\n              res.writeHead(500, { 'Content-Type': 'application/json' });\n              res.end(JSON.stringify({ error: error.message }));\n            }\n          });\n        } else {\n          res.writeHead(405);\n          res.end('Method not allowed');\n        }\n\n      } else if (url.pathname === '/api/bundles-from-chunk') {\n        if (req.method === 'POST') {\n          let body = '';\n          req.on('data', chunk => body += chunk);\n          req.on('end', () => {\n            try {\n              const { chunkName, files } = JSON.parse(body);\n              this.createBundleFromChunk(chunkName, files)\n                .then(() => {\n                  res.writeHead(200, { 'Content-Type': 'application/json' });\n                  res.end(JSON.stringify({ success: true }));\n                })\n                .catch(error => {\n                  res.writeHead(500, { 'Content-Type': 'application/json' });\n                  res.end(JSON.stringify({ error: error.message }));\n                });\n            } catch (error) {\n              res.writeHead(500, { 'Content-Type': 'application/json' });\n              res.end(JSON.stringify({ error: error.message }));\n            }\n          });\n        } else {\n          res.writeHead(405);\n          res.end('Method not allowed');\n        }\n\n      } else if (url.pathname.startsWith('/api/bundles/')) {\n        const bundleName = url.pathname.split('/').pop();\n        const bundle = this.bundles.get(bundleName);\n        if (bundle) {\n          res.writeHead(200, { 'Content-Type': 'application/xml' });\n          res.end(bundle.content);\n        } else {\n          res.writeHead(404);\n          res.end('Bundle not found');\n        }\n\n      } else if (url.pathname.startsWith('/api/regenerate/')) {\n        const bundleName = url.pathname.split('/').pop();\n        if (this.bundles.has(bundleName)) {\n          this.generateBundle(bundleName);\n          this.saveBundleStates();\n          this.broadcastUpdate();\n          res.writeHead(200);\n          res.end('OK');\n        } else {\n          res.writeHead(404);\n          res.end('Bundle not found');\n        }\n\n      } else if (url.pathname === '/api/files') {\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        const fileTree = this.getFileTree();\n        res.end(JSON.stringify(fileTree));\n\n      } else if (url.pathname === '/api/config') {\n        if (req.method === 'GET') {\n          res.writeHead(200, { 'Content-Type': 'application/json' });\n          if (existsSync(this.CONFIG_FILE)) {\n            const config = readFileSync(this.CONFIG_FILE, 'utf8');\n            res.end(config);\n          } else {\n            const defaultConfig = {\n              bundles: {\n                master: ['**/*'],\n                api: ['src/api.js'],\n                ui: ['src/component.jsx', 'src/*.jsx'],\n                config: ['package.json', 'package-lock.json', '*.config.*'],\n                docs: ['README.md', '*.md']\n              }\n            };\n            res.end(JSON.stringify(defaultConfig));\n          }\n        } else if (req.method === 'POST') {\n          let body = '';\n          req.on('data', chunk => body += chunk);\n          req.on('end', () => {\n            try {\n              if (!this.isQuietMode) console.log('🔍 Received config save request');\n              const config = JSON.parse(body);\n              if (!this.isQuietMode) console.log('📝 Config to save:', JSON.stringify(config, null, 2));\n\n              // Ensure .cntx directory exists\n              if (!existsSync(this.CNTX_DIR)) {\n                if (!this.isQuietMode) console.log('📁 Creating .cntx directory...');\n                mkdirSync(this.CNTX_DIR, { recursive: true });\n              }\n\n              // Write config file\n              if (!this.isQuietMode) console.log('💾 Writing config to:', this.CONFIG_FILE);\n              writeFileSync(this.CONFIG_FILE, JSON.stringify(config, null, 2));\n              if (!this.isQuietMode) console.log('✅ Config file written successfully');\n\n              // Reload configuration\n              this.loadConfig();\n              this.generateAllBundles();\n              this.broadcastUpdate();\n\n              res.writeHead(200, { 'Content-Type': 'text/plain' });\n              res.end('OK');\n              if (!this.isQuietMode) console.log('✅ Config save response sent');\n\n            } catch (e) {\n              if (!this.isQuietMode) console.error('❌ Config save error:', e);\n              res.writeHead(400, { 'Content-Type': 'text/plain' });\n              res.end(`Error: ${e.message}`);\n            }\n          });\n\n          req.on('error', (err) => {\n            if (!this.isQuietMode) console.error('❌ Request error:', err);\n            if (!res.headersSent) {\n              res.writeHead(500, { 'Content-Type': 'text/plain' });\n              res.end('Internal Server Error');\n            }\n          });\n        }\n\n      } else if (url.pathname === '/api/cursor-rules') {\n        if (req.method === 'GET') {\n          res.writeHead(200, { 'Content-Type': 'text/plain' });\n          const rules = this.loadCursorRules();\n          res.end(rules);\n        } else if (req.method === 'POST') {\n          let body = '';\n          req.on('data', chunk => body += chunk);\n          req.on('end', () => {\n            try {\n              const { content } = JSON.parse(body);\n              this.saveCursorRules(content);\n              res.writeHead(200);\n              res.end('OK');\n            } catch (e) {\n              res.writeHead(400);\n              res.end('Invalid request');\n            }\n          });\n        }\n\n      } else if (url.pathname === '/api/cursor-rules/templates') {\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        const templates = {\n          react: this.generateCursorRulesTemplate({ name: 'My React App', description: 'React application', type: 'react' }),\n          node: this.generateCursorRulesTemplate({ name: 'My Node App', description: 'Node.js backend', type: 'node' }),\n          general: this.generateCursorRulesTemplate({ name: 'My Project', description: 'General project', type: 'general' })\n        };\n        res.end(JSON.stringify(templates));\n\n      } else if (url.pathname === '/api/claude-md') {\n        if (req.method === 'GET') {\n          res.writeHead(200, { 'Content-Type': 'text/plain' });\n          const claudeMd = this.loadClaudeMd();\n          res.end(claudeMd);\n        } else if (req.method === 'POST') {\n          let body = '';\n          req.on('data', chunk => body += chunk);\n          req.on('end', () => {\n            try {\n              const { content } = JSON.parse(body);\n              this.saveClaudeMd(content);\n              res.writeHead(200);\n              res.end('OK');\n            } catch (e) {\n              res.writeHead(400);\n              res.end('Invalid request');\n            }\n          });\n        }\n\n      } else if (url.pathname === '/api/test-pattern') {\n        if (req.method === 'POST') {\n          let body = '';\n          req.on('data', chunk => body += chunk);\n          req.on('end', () => {\n            try {\n              const { pattern } = JSON.parse(body);\n              const allFiles = this.getAllFiles();\n              const matchingFiles = allFiles.filter(file =>\n                this.matchesPattern(file, pattern)\n              );\n\n              res.writeHead(200, { 'Content-Type': 'application/json' });\n              res.end(JSON.stringify(matchingFiles));\n            } catch (e) {\n              res.writeHead(400);\n              res.end('Invalid request');\n            }\n          });\n        } else {\n          res.writeHead(405);\n          res.end('Method not allowed');\n        }\n\n      } else if (url.pathname === '/api/hidden-files') {\n        if (req.method === 'GET') {\n          res.writeHead(200, { 'Content-Type': 'application/json' });\n          const stats = {\n            totalFiles: this.getAllFiles().length,\n            globallyHidden: this.hiddenFilesConfig.globalHidden.length,\n            bundleSpecificHidden: this.hiddenFilesConfig.bundleSpecific,\n            ignorePatterns: {\n              system: [\n                { pattern: '**/.git/**', active: !this.hiddenFilesConfig.disabledSystemPatterns.includes('**/.git/**') },\n                { pattern: '**/node_modules/**', active: !this.hiddenFilesConfig.disabledSystemPatterns.includes('**/node_modules/**') },\n                { pattern: '**/.cntx/**', active: !this.hiddenFilesConfig.disabledSystemPatterns.includes('**/.cntx/**') }\n              ],\n              user: this.hiddenFilesConfig.userIgnorePatterns,\n              disabled: this.hiddenFilesConfig.disabledSystemPatterns\n            }\n          };\n          res.end(JSON.stringify(stats));\n        } else if (req.method === 'POST') {\n          let body = '';\n          req.on('data', chunk => body += chunk);\n          req.on('end', () => {\n            try {\n              const { action, filePath, filePaths, bundleName, forceHide } = JSON.parse(body);\n\n              if (action === 'toggle' && filePath) {\n                this.toggleFileVisibility(filePath, bundleName, forceHide);\n              } else if (action === 'bulk-toggle' && filePaths) {\n                this.bulkToggleFileVisibility(filePaths, bundleName, forceHide);\n              }\n\n              this.generateAllBundles();\n              this.broadcastUpdate();\n\n              res.writeHead(200, { 'Content-Type': 'application/json' });\n              res.end(JSON.stringify({ success: true }));\n            } catch (e) {\n              res.writeHead(400, { 'Content-Type': 'application/json' });\n              res.end(JSON.stringify({ error: e.message }));\n            }\n          });\n        }\n\n      } else if (url.pathname === '/api/files-with-visibility') {\n        const bundleName = url.searchParams.get('bundle');\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        const files = this.getFileListWithVisibility(bundleName);\n        res.end(JSON.stringify(files));\n\n      } else if (url.pathname === '/api/ignore-patterns') {\n        if (req.method === 'GET') {\n          res.writeHead(200, { 'Content-Type': 'application/json' });\n\n          // Read file patterns\n          let filePatterns = [];\n          if (existsSync(this.IGNORE_FILE)) {\n            filePatterns = readFileSync(this.IGNORE_FILE, 'utf8')\n              .split('\\n')\n              .map(line => line.trim())\n              .filter(line => line && !line.startsWith('#'));\n          }\n\n          const systemPatterns = ['**/.git/**', '**/node_modules/**', '**/.cntx/**'];\n\n          const patterns = {\n            system: systemPatterns.map(pattern => ({\n              pattern,\n              active: !this.hiddenFilesConfig.disabledSystemPatterns.includes(pattern)\n            })),\n            user: this.hiddenFilesConfig.userIgnorePatterns.map(pattern => ({ pattern, active: true })),\n            file: filePatterns.filter(pattern =>\n              !systemPatterns.includes(pattern) &&\n              !this.hiddenFilesConfig.userIgnorePatterns.includes(pattern)\n            ).map(pattern => ({ pattern, active: true }))\n          };\n          res.end(JSON.stringify(patterns));\n\n        } else if (req.method === 'POST') {\n          let body = '';\n          req.on('data', chunk => body += chunk);\n          req.on('end', () => {\n            try {\n              const { action, pattern } = JSON.parse(body);\n              let success = false;\n\n              switch (action) {\n                case 'add':\n                  success = this.addUserIgnorePattern(pattern);\n                  break;\n                case 'remove':\n                  success = this.removeUserIgnorePattern(pattern);\n                  break;\n                case 'toggle-system':\n                  this.toggleSystemIgnorePattern(pattern);\n                  success = true;\n                  break;\n              }\n\n              this.broadcastUpdate();\n              res.writeHead(200, { 'Content-Type': 'application/json' });\n              res.end(JSON.stringify({ success }));\n            } catch (e) {\n              res.writeHead(400, { 'Content-Type': 'application/json' });\n              res.end(JSON.stringify({ error: e.message }));\n            }\n          });\n        }\n\n      } else if (url.pathname === '/api/bundle-visibility-stats') {\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        const stats = {};\n\n        this.bundles.forEach((bundle, bundleName) => {\n          const allFiles = this.getAllFiles();\n          const matchingFiles = allFiles.filter(file =>\n            bundle.patterns.some(pattern => this.matchesPattern(file, pattern))\n          );\n\n          const visibleFiles = matchingFiles.filter(file => !this.isFileHidden(file, bundleName));\n          const hiddenFiles = matchingFiles.length - visibleFiles.length;\n\n          stats[bundleName] = {\n            total: matchingFiles.length,\n            visible: visibleFiles.length,\n            hidden: hiddenFiles,\n            patterns: bundle.patterns\n          };\n        });\n\n        res.end(JSON.stringify(stats));\n\n      } else if (url.pathname.startsWith('/api/bundle-categories/')) {\n        const bundleName = url.pathname.split('/').pop();\n        const bundle = this.bundles.get(bundleName);\n\n        if (bundle) {\n          const filesByType = this.categorizeFiles(bundle.files);\n          const entryPoints = this.identifyEntryPoints(bundle.files);\n\n          res.writeHead(200, { 'Content-Type': 'application/json' });\n          res.end(JSON.stringify({\n            purpose: this.getBundlePurpose(bundleName),\n            filesByType,\n            entryPoints,\n            totalFiles: bundle.files.length\n          }));\n        } else {\n          res.writeHead(404);\n          res.end('Bundle not found');\n        }\n\n      } else if (url.pathname === '/api/reset-hidden-files') {\n        if (req.method === 'POST') {\n          let body = '';\n          req.on('data', chunk => body += chunk);\n          req.on('end', () => {\n            try {\n              const { scope, bundleName } = JSON.parse(body);\n\n              if (scope === 'global') {\n                this.hiddenFilesConfig.globalHidden = [];\n              } else if (scope === 'bundle' && bundleName) {\n                delete this.hiddenFilesConfig.bundleSpecific[bundleName];\n              } else if (scope === 'all') {\n                this.hiddenFilesConfig.globalHidden = [];\n                this.hiddenFilesConfig.bundleSpecific = {};\n              }\n\n              this.saveHiddenFilesConfig();\n              this.generateAllBundles();\n              this.broadcastUpdate();\n\n              res.writeHead(200, { 'Content-Type': 'application/json' });\n              res.end(JSON.stringify({ success: true }));\n            } catch (e) {\n              res.writeHead(400, { 'Content-Type': 'application/json' });\n              res.end(JSON.stringify({ error: e.message }));\n            }\n          });\n        }\n\n      } else if (url.pathname === '/api/mcp-status') {\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n\n        // Simple check - MCP is available if we can find package.json\n        let isAccessible = true;\n        let testResult = 'available';\n\n        // Check if package.json exists using existing imports\n        try {\n          const packagePath = join(this.CWD, 'package.json');\n          if (existsSync(packagePath)) {\n            testResult = 'local_package_found';\n          } else {\n            testResult = 'using_global_npx';\n          }\n        } catch (error) {\n          testResult = 'check_failed';\n        }\n\n        const mcpStatus = {\n          running: isAccessible,\n          accessible: isAccessible,\n          testResult: testResult,\n          command: 'npx cntx-ui mcp',\n          workingDirectory: this.CWD,\n          lastChecked: new Date().toISOString(),\n          trackingEnabled: this.mcpServerStarted || false\n        };\n        res.end(JSON.stringify(mcpStatus, null, 2));\n\n      } else if (url.pathname === '/api/status') {\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        const statusInfo = {\n          server: {\n            version: '2.0.8',\n            workingDirectory: this.CWD,\n            startTime: new Date().toISOString(),\n            isScanning: this.isScanning\n          },\n          bundles: {\n            count: this.bundles.size,\n            names: Array.from(this.bundles.keys()),\n            totalFiles: Array.from(this.bundles.values()).reduce((sum, bundle) => sum + bundle.files.length, 0)\n          },\n          mcp: {\n            available: true,\n            serverStarted: this.mcpServerStarted,\n            command: 'npx cntx-ui mcp',\n            setupScript: './examples/claude-mcp-setup.sh'\n          },\n          files: {\n            total: this.getAllFiles().length,\n            hiddenGlobally: this.hiddenFilesConfig.globalHidden.length,\n            ignorePatterns: this.ignorePatterns.length\n          }\n        };\n        res.end(JSON.stringify(statusInfo, null, 2));\n\n      } else {\n        res.writeHead(404);\n        res.end('Not found');\n      }\n    });\n\n    const wss = new WebSocketServer({ server });\n    wss.on('connection', (ws) => {\n      this.clients.add(ws);\n      ws.on('close', () => this.clients.delete(ws));\n      this.sendUpdate(ws);\n    });\n\n    server.listen(port, () => {\n      if (!this.isQuietMode) {\n        console.log(`🚀 cntx-ui API running at http://localhost:${port}`);\n        console.log(`📁 Watching: ${this.CWD}`);\n        console.log(`📦 Bundles: ${Array.from(this.bundles.keys()).join(', ')}`);\n      }\n    });\n\n    return server;\n  }\n\n  broadcastUpdate() {\n    this.clients.forEach(client => this.sendUpdate(client));\n  }\n\n  sendUpdate(client) {\n    if (client.readyState === 1) {\n      const bundleData = Array.from(this.bundles.entries()).map(([name, bundle]) => ({\n        name,\n        changed: bundle.changed,\n        fileCount: bundle.files.length,\n        content: bundle.content.substring(0, 2000) + (bundle.content.length > 2000 ? '...' : ''),\n        files: bundle.files,\n        lastGenerated: bundle.lastGenerated,\n        size: bundle.size\n      }));\n      client.send(JSON.stringify(bundleData));\n    }\n  }\n\n  cleanup() {\n    this.watchers.forEach(watcher => watcher.close());\n    this.saveBundleStates();\n  }\n\n  // Semantic Chunking Methods\n  async getSemanticAnalysis() {\n    // Force refresh always for now (TODO: implement proper cache invalidation)\n    this.semanticCache = null // Clear cache\n    const shouldRefresh = true\n    \n    console.log('🔍 Cache check - shouldRefresh:', shouldRefresh, 'lastAnalysis:', this.lastSemanticAnalysis, 'now:', Date.now());\n\n    if (shouldRefresh) {\n      try {\n        // Auto-discover JavaScript/TypeScript files in the entire project\n        const patterns = ['**/*.{js,jsx,ts,tsx,mjs}'];\n        \n        // Load bundle configuration for chunk grouping\n        let bundleConfig = null;\n        if (existsSync(this.CONFIG_FILE)) {\n          bundleConfig = JSON.parse(readFileSync(this.CONFIG_FILE, 'utf8'));\n        }\n        \n        this.semanticCache = await this.semanticSplitter.extractSemanticChunks(this.CWD, patterns, bundleConfig);\n        this.lastSemanticAnalysis = Date.now();\n        \n        // Debug logging\n        console.log('🔍 Semantic analysis complete. Sample chunk keys:', \n          this.semanticCache.chunks.length > 0 ? Object.keys(this.semanticCache.chunks[0]) : 'No chunks');\n        if (this.semanticCache.chunks.length > 0) {\n          console.log('🔍 Sample chunk businessDomains:', this.semanticCache.chunks[0].businessDomains);\n        }\n      } catch (error) {\n        console.error('Semantic analysis failed:', error.message);\n        throw new Error(`Semantic analysis failed: ${error.message}`);\n      }\n    }\n\n    return this.semanticCache;\n  }\n\n  async exportSemanticChunk(chunkName) {\n    const analysis = await this.getSemanticAnalysis();\n    const chunk = analysis.chunks.find(c => c.name === chunkName);\n\n    if (!chunk) {\n      throw new Error(`Chunk \"${chunkName}\" not found`);\n    }\n\n    // Generate XML content for the chunk files\n    let xmlContent = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n`;\n    xmlContent += `<codebase_context semantic_chunk=\"${chunkName}\">\\n`;\n    xmlContent += `  <chunk_info>\\n`;\n    xmlContent += `    <name>${chunkName}</name>\\n`;\n    xmlContent += `    <purpose>${chunk.purpose || 'No description'}</purpose>\\n`;\n    xmlContent += `    <file_count>${chunk.files.length}</file_count>\\n`;\n    xmlContent += `    <size>${chunk.size} bytes</size>\\n`;\n    xmlContent += `    <complexity>${chunk.complexity?.level || 'unknown'}</complexity>\\n`;\n    xmlContent += `    <tags>${(chunk.tags || []).join(', ')}</tags>\\n`;\n    xmlContent += `  </chunk_info>\\n\\n`;\n\n    // Add each function in the chunk\n    if (chunk.functions) {\n      for (const func of chunk.functions) {\n        xmlContent += `  <function name=\"${func.name}\" file=\"${func.filePath}\">\\n`;\n        xmlContent += `    <signature>${func.signature}</signature>\\n`;\n        xmlContent += `    <type>${func.type}</type>\\n`;\n        xmlContent += `    <lines>${func.startLine}-${func.endLine}</lines>\\n`;\n        \n        if (func.context.imports.length > 0) {\n          xmlContent += `    <imports>${func.context.imports.join(', ')}</imports>\\n`;\n        }\n        \n        xmlContent += `    <code>\\n`;\n        xmlContent += func.code\n          .split('\\n')\n          .map((line, i) => `${(func.startLine + i).toString().padStart(3)}  ${line}`)\n          .join('\\n');\n        xmlContent += `\\n    </code>\\n`;\n        xmlContent += `  </function>\\n\\n`;\n      }\n    } else {\n      // Fallback for file-based chunks\n      for (const filePath of chunk.files || []) {\n        const fullPath = join(this.CWD, filePath);\n        if (existsSync(fullPath)) {\n          try {\n            const content = readFileSync(fullPath, 'utf8');\n            xmlContent += `  <file path=\"${filePath}\">\\n`;\n            xmlContent += content\n              .split('\\n')\n              .map((line, i) => `${(i + 1).toString().padStart(3)}  ${line}`)\n              .join('\\n');\n            xmlContent += `\\n  </file>\\n\\n`;\n          } catch (error) {\n            console.warn(`Could not read file ${filePath}:`, error.message);\n          }\n        }\n      }\n    }\n\n    xmlContent += `</codebase_context>`;\n    return xmlContent;\n  }\n\n  async createBundleFromChunk(chunkName, files) {\n    // Load current config\n    let config = {};\n    if (existsSync(this.CONFIG_FILE)) {\n      config = JSON.parse(readFileSync(this.CONFIG_FILE, 'utf8'));\n    }\n\n    if (!config.bundles) {\n      config.bundles = {};\n    }\n\n    // Create bundle with the chunk name and files\n    const bundleName = chunkName.toLowerCase().replace(/[-\\s]+/g, '-');\n    config.bundles[bundleName] = files;\n\n    // Save config\n    writeFileSync(this.CONFIG_FILE, JSON.stringify(config, null, 2));\n\n    // Reload bundles\n    this.loadConfig();\n    this.generateAllBundles();\n    this.saveBundleStates();\n    this.broadcastUpdate();\n  }\n\n  invalidateSemanticCache() {\n    this.semanticCache = null;\n    this.lastSemanticAnalysis = null;\n  }\n}\n\nexport function startServer(options = {}) {\n  const server = new CntxServer(options.cwd, { quiet: options.quiet });\n  server.init();\n\n  if (options.withMcp) {\n    server.mcpServerStarted = true;\n    if (!server.isQuietMode) {\n      console.log('🔗 MCP server tracking enabled - use /api/status to check MCP configuration');\n    }\n  }\n\n  return server.startServer(options.port);\n}\n\nexport function startMCPServer(options = {}) {\n  const server = new CntxServer(options.cwd, { quiet: true });\n  server.init();\n  startMCPTransport(server);\n  return server;\n}\n\nexport function generateBundle(name = 'master', cwd = process.cwd(), options = {}) {\n  const server = new CntxServer(cwd, { quiet: options.quiet });\n  server.init();\n  server.generateBundle(name);\n  server.saveBundleStates();\n}\n\nexport function initConfig(cwd = process.cwd(), options = {}) {\n  const isQuiet = options.quiet || false;\n  if (!isQuiet) {\n    console.log('🚀 Starting initConfig...');\n    console.log('📂 Working directory:', cwd);\n  }\n\n  const server = new CntxServer(cwd, { quiet: isQuiet });\n  if (!isQuiet) {\n    console.log('📁 CNTX_DIR:', server.CNTX_DIR);\n    console.log('📄 CONFIG_FILE path:', server.CONFIG_FILE);\n  }\n\n  const defaultConfig = {\n    bundles: {\n      master: ['**/*']\n    }\n  };\n\n  try {\n    // Create .cntx directory\n    if (!isQuiet) console.log('🔍 Checking if .cntx directory exists...');\n    if (!existsSync(server.CNTX_DIR)) {\n      if (!isQuiet) console.log('📁 Creating .cntx directory...');\n      mkdirSync(server.CNTX_DIR, { recursive: true });\n      if (!isQuiet) console.log('✅ .cntx directory created');\n    } else {\n      if (!isQuiet) console.log('✅ .cntx directory already exists');\n    }\n\n    // List directory contents before writing config\n    if (!isQuiet) {\n      console.log('📋 Directory contents before writing config:');\n      const beforeFiles = readdirSync(server.CNTX_DIR);\n      console.log('Files:', beforeFiles);\n    }\n\n    // Write config.json\n    if (!isQuiet) {\n      console.log('📝 Writing config.json...');\n      console.log('📄 Config content:', JSON.stringify(defaultConfig, null, 2));\n      console.log('📍 Writing to path:', server.CONFIG_FILE);\n    }\n\n    writeFileSync(server.CONFIG_FILE, JSON.stringify(defaultConfig, null, 2));\n    if (!isQuiet) console.log('✅ writeFileSync completed');\n\n    // Verify file was created\n    if (!isQuiet) {\n      console.log('🔍 Checking if config.json exists...');\n      const configExists = existsSync(server.CONFIG_FILE);\n      console.log('Config exists?', configExists);\n\n      if (configExists) {\n        const configContent = readFileSync(server.CONFIG_FILE, 'utf8');\n        console.log('✅ Config file created successfully');\n        console.log('📖 Config content:', configContent);\n      } else {\n        console.log('❌ Config file was NOT created');\n      }\n\n      // List directory contents after writing config\n      console.log('📋 Directory contents after writing config:');\n      const afterFiles = readdirSync(server.CNTX_DIR);\n      console.log('Files:', afterFiles);\n    }\n\n  } catch (error) {\n    if (!isQuiet) {\n      console.error('❌ Error in initConfig:', error);\n      console.error('Stack trace:', error.stack);\n    }\n    throw error;\n  }\n\n  // Create cursor rules if they don't exist\n  try {\n    if (!existsSync(server.CURSOR_RULES_FILE)) {\n      if (!isQuiet) console.log('📋 Creating cursor rules...');\n      const cursorRules = server.getDefaultCursorRules();\n      server.saveCursorRules(cursorRules);\n      if (!isQuiet) console.log(`📋 Created ${relative(cwd, server.CURSOR_RULES_FILE)} with project-specific rules`);\n    }\n  } catch (error) {\n    if (!isQuiet) console.error('❌ Error creating cursor rules:', error);\n  }\n\n  if (!isQuiet) {\n    console.log('✅ cntx-ui initialized successfully!');\n    console.log('');\n    console.log('🚀 Next step: Start the web interface');\n    console.log('   Run: cntx-ui watch');\n    console.log('');\n    console.log('📱 Then visit: http://localhost:3333');\n    console.log('   Follow the setup guide to create your first bundles');\n    console.log('');\n    console.log('💡 The web interface handles everything - no manual file editing needed!');\n  }\n}\n\nexport function getStatus(cwd = process.cwd(), options = {}) {\n  const server = new CntxServer(cwd, { quiet: options.quiet });\n  server.init();\n\n  if (!options.quiet) {\n    console.log(`📁 Working directory: ${server.CWD}`);\n    console.log(`📦 Bundles configured: ${server.bundles.size}`);\n    server.bundles.forEach((bundle, name) => {\n      const status = bundle.changed ? '🔄 CHANGED' : '✅ SYNCED';\n      console.log(`  ${name}: ${bundle.files.length} files ${status}`);\n    });\n\n    const hasCursorRules = existsSync(server.CURSOR_RULES_FILE);\n    console.log(`🤖 Cursor rules: ${hasCursorRules ? '✅ Configured' : '❌ Not found'}`);\n  }\n}\n\nexport function setupMCP(cwd = process.cwd(), options = {}) {\n  const isQuiet = options.quiet || false;\n  const projectDir = cwd;\n  const projectName = basename(projectDir);\n  const configFile = join(homedir(), 'Library', 'Application Support', 'Claude', 'claude_desktop_config.json');\n\n  if (!isQuiet) {\n    console.log('🔗 Setting up MCP for Claude Desktop...');\n    console.log(`📁 Project: ${projectName} (${projectDir})`);\n  }\n\n  // Create config directory if it doesn't exist\n  const configDir = dirname(configFile);\n  if (!existsSync(configDir)) {\n    mkdirSync(configDir, { recursive: true });\n  }\n\n  // Read existing config or create empty one\n  let config = { mcpServers: {} };\n  if (existsSync(configFile)) {\n    try {\n      const configContent = readFileSync(configFile, 'utf8');\n      config = JSON.parse(configContent);\n      if (!config.mcpServers) config.mcpServers = {};\n    } catch (error) {\n      if (!isQuiet) console.warn('⚠️  Could not parse existing config, creating new one');\n      config = { mcpServers: {} };\n    }\n  }\n\n  // Add this project's MCP server using shell command format that works with Claude Desktop\n  const serverName = `cntx-ui-${projectName}`;\n  config.mcpServers[serverName] = {\n    command: 'sh',\n    args: ['-c', `cd ${projectDir} && npx cntx-ui mcp`],\n    cwd: projectDir\n  };\n\n  // Write updated config\n  try {\n    writeFileSync(configFile, JSON.stringify(config, null, 2));\n\n    if (!isQuiet) {\n      console.log(`✅ Added MCP server: ${serverName}`);\n      console.log('📋 Your Claude Desktop config now includes:');\n\n      Object.keys(config.mcpServers).forEach(name => {\n        if (name.startsWith('cntx-ui-')) {\n          console.log(`  • ${name}: ${config.mcpServers[name].cwd}`);\n        }\n      });\n\n      console.log('🔄 Please restart Claude Desktop to use the updated configuration');\n    }\n  } catch (error) {\n    if (!isQuiet) {\n      console.error('❌ Error writing Claude Desktop config:', error.message);\n      console.error('💡 Make sure Claude Desktop is not running and try again');\n    }\n    throw error;\n  }\n}\n]]></cntx:content>\n      </cntx:file>\n    </cntx:group>\n    <cntx:group type=\"tests\" description=\"Test files and testing utilities\">\n      <cntx:file path=\"temp_treesitter_test.js\" ext=\".js\">\n        <cntx:meta size=\"731\" modified=\"2025-06-26T19:44:21.169Z\" lines=\"24\" />\n        <cntx:content><![CDATA[import Parser from 'tree-sitter';\nimport JavaScript from 'tree-sitter-javascript';\n\nasync function runTest() {\n  const parser = new Parser();\n  parser.setLanguage(JavaScript);\n\n  const sourceCode = 'function add(a, b) { return a + b; }';\n  const tree = parser.parse(sourceCode);\n  const rootNode = tree.rootNode;\n\n  console.log('Root Node Type:', rootNode.type);\n  console.log('Root Node Text:', rootNode.text);\n  console.log('Root Node hasError():', rootNode.hasError());\n\n  // Try to access a child node\n  const functionNode = rootNode.namedChild(0);\n  if (functionNode) {\n    console.log('Function Node Type:', functionNode.type);\n    console.log('Function Node Text:', functionNode.text);\n  }\n}\n\nrunTest().catch(console.error);]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"test-chunker.mjs\" ext=\".mjs\">\n        <cntx:meta size=\"1772\" modified=\"2025-06-26T00:50:45.006Z\" lines=\"46\" />\n        <cntx:content><![CDATA[import SemanticChunker from './lib/semantic-chunker.js';\n\nconst chunker = new SemanticChunker();\n\nconsole.log('🔍 Analyzing web/src directory for semantic chunks...\\n');\n\ntry {\n  const result = await chunker.analyzeProject('.', ['web/src/**/*.{js,jsx,ts,tsx}']);\n  \n  console.log('=== PROJECT ANALYSIS RESULTS ===\\n');\n  \n  // Show summary stats\n  console.log(`📊 Analysis Summary:`);\n  console.log(`- Total files analyzed: ${result.totalFiles}`);\n  console.log(`- File types found: ${Object.keys(result.fileTypes).join(', ')}`);\n  console.log(`- Semantic chunks identified: ${result.chunks.length}`);\n  console.log(`- Total functions found: ${result.totalFunctions}`);\n  console.log(`- Total exports found: ${result.totalExports}\\n`);\n  \n  // Show chunks\n  console.log('📦 Semantic Chunks:');\n  result.chunks.forEach((chunk, i) => {\n    console.log(`\\n${i + 1}. ${chunk.name} (${chunk.files.length} files)`);\n    console.log(`   Purpose: ${chunk.purpose}`);\n    console.log(`   Files: ${chunk.files.slice(0, 3).join(', ')}${chunk.files.length > 3 ? '...' : ''}`);\n  });\n  \n  // Show some interesting files\n  console.log('\\n🎯 Interesting Files:');\n  result.files.slice(0, 5).forEach(file => {\n    console.log(`\\n📄 ${file.path}`);\n    console.log(`   Type: ${file.fileType}`);\n    console.log(`   Functions: ${file.functions.length}`);\n    console.log(`   Exports: ${file.exports.length}`);\n    console.log(`   Lines: ${file.complexity.lines}`);\n    if (file.reactComponents.length > 0) {\n      console.log(`   React Components: ${file.reactComponents.join(', ')}`);\n    }\n    if (file.hooks.length > 0) {\n      console.log(`   Hooks: ${file.hooks.join(', ')}`);\n    }\n  });\n  \n} catch (error) {\n  console.error('❌ Error analyzing project:', error.message);\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"test-complexity.js\" ext=\".js\">\n        <cntx:meta size=\"494\" modified=\"2025-06-26T21:29:03.269Z\" lines=\"12\" />\n        <cntx:content><![CDATA[import SemanticSplitter from './lib/semantic-splitter.js';\n\nconst splitter = new SemanticSplitter();\nconst result = await splitter.extractSemanticChunks('.', ['web/src/App.tsx']);\n\nconsole.log('Sample complexity scores:');\nresult.chunks.slice(0, 5).forEach(chunk => {\n  console.log(`- ${chunk.name}: ${chunk.complexity.score} (${chunk.complexity.level})`);\n  console.log(`  Size: ${chunk.size} chars`);\n  console.log(`  Code preview: ${chunk.code.substring(0, 100)}...`);\n  console.log('');\n});]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"test-treesitter.mjs\" ext=\".mjs\">\n        <cntx:meta size=\"2881\" modified=\"2025-06-26T16:28:57.720Z\" lines=\"67\" />\n        <cntx:content><![CDATA[import TreesitterSemanticChunker from './lib/treesitter-semantic-chunker.js';\n\nconst chunker = new TreesitterSemanticChunker({\n  namingStrategy: 'domain-based'\n});\n\nconsole.log('🚀 TREESITTER SEMANTIC CHUNKING TEST');\nconsole.log('====================================\\n');\n\nconsole.log('🔍 Testing treesitter-based analysis...\\n');\n\ntry {\n  const result = await chunker.analyzeProject('.', ['web/src/**/*.{js,jsx,ts,tsx}']);\n  \n  // Project Overview\n  console.log('📊 PROJECT OVERVIEW');\n  console.log(`📁 Files analyzed: ${result.summary.totalFiles}`);\n  console.log(`📦 Semantic chunks created: ${result.summary.totalChunks}`);\n  console.log(`💾 Total code size: ${Math.round(result.summary.totalSize / 1024)}KB`);\n  console.log(`📏 Total lines of code: ${result.summary.totalLines.toLocaleString()}`);\n  \n  // Semantic Types\n  console.log('\\n🎯 SEMANTIC TYPES');\n  Object.entries(result.summary.semanticTypes).forEach(([type, count]) => {\n    console.log(`   ${type}: ${count} files`);\n  });\n  \n  // Business Domains  \n  console.log('\\n🏢 BUSINESS DOMAINS');\n  Object.entries(result.summary.businessDomains).forEach(([domain, count]) => {\n    console.log(`   ${domain}: ${count} occurrences`);\n  });\n  \n  // Technical Patterns\n  console.log('\\n⚙️ TECHNICAL PATTERNS');\n  Object.entries(result.summary.technicalPatterns).forEach(([pattern, count]) => {\n    console.log(`   ${pattern}: ${count} files`);\n  });\n  \n  // Smart Chunks\n  console.log('\\n🧩 SMART SEMANTIC CHUNKS');\n  console.log('==========================');\n  result.chunks.forEach((chunk, i) => {\n    console.log(`\\n${i + 1}. 📦 ${chunk.name.toUpperCase()}`);\n    console.log(`   📊 ${chunk.files.length} files | ${Math.round(chunk.size / 1024)}KB | ${chunk.purpose}`);\n    console.log(`   🎯 Cohesion: ${chunk.cohesion.toFixed(2)} | Complexity: ${chunk.complexity.level}`);\n    console.log(`   🏢 Domains: ${chunk.businessDomains.join(', ') || 'none'}`);\n    console.log(`   ⚙️ Patterns: ${chunk.technicalPatterns.join(', ') || 'none'}`);\n    console.log(`   📁 Files: ${chunk.files.slice(0, 3).map(f => f.split('/').pop()).join(', ')}${chunk.files.length > 3 ? `... +${chunk.files.length - 3} more` : ''}`);\n    \n    if (chunk.recommendations.length > 0) {\n      console.log(`   💡 ${chunk.recommendations[0].message}`);\n    }\n  });\n  \n  console.log('\\n✨ TREESITTER ANALYSIS COMPLETE!');\n  console.log('=================================');\n  console.log('🚀 Treesitter provides deeper semantic understanding');\n  console.log('🧠 Smart clustering based on AST analysis');\n  console.log('🎯 Business domain extraction from code structure');\n  console.log('📊 Technical pattern recognition');\n  console.log('🔗 Dependency relationship mapping');\n  \n} catch (error) {\n  console.error('❌ Treesitter analysis failed:', error.message);\n  console.error(error.stack);\n}]]></cntx:content>\n      </cntx:file>\n    </cntx:group>\n    <cntx:group type=\"other\" description=\"Additional project files\">\n      <cntx:file path=\"bin/cntx-ui-mcp.sh\" ext=\".sh\">\n        <cntx:meta size=\"106\" modified=\"2025-06-25T02:01:20.530Z\" lines=\"3\" />\n        <cntx:content><![CDATA[#!/bin/bash\n# Wrapper script to run cntx-ui MCP server in current directory\ncd \"$(pwd)\" && npx cntx-ui mcp]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"bin/cntx-ui.js\" ext=\".js\">\n        <cntx:meta size=\"1928\" modified=\"2025-06-25T02:46:24.504Z\" lines=\"74\" />\n        <cntx:content><![CDATA[#!/usr/bin/env node\n\nimport { startServer, startMCPServer, generateBundle, initConfig, getStatus, setupMCP } from '../server.js';\n\nconst args = process.argv.slice(2);\nconst command = args[0] || 'watch';\n\n// Graceful shutdown\nprocess.on('SIGINT', () => {\n  console.log('\\n👋 Shutting down cntx-ui...');\n  process.exit(0);\n});\n\nswitch (command) {\n  case 'watch':\n    const port = parseInt(args[1]) || 3333;\n    const withMcp = args.includes('--with-mcp');\n    startServer({ port, withMcp });\n    break;\n\n  case 'mcp':\n    // MCP server mode - runs on stdio\n    startMCPServer({ cwd: process.cwd() });\n    break;\n\n  case 'bundle':\n    const bundleName = args[1] || 'master';\n    try {\n      generateBundle(bundleName);\n      console.log(`✅ Bundle '${bundleName}' generated`);\n    } catch (e) {\n      console.error(`❌ Bundle '${bundleName}' not found`);\n    }\n    break;\n\n  case 'init':\n    initConfig();\n    break;\n\n  case 'status':\n    getStatus();\n    break;\n\n  case 'setup-mcp':\n    setupMCP();\n    break;\n\n  default:\n    console.log(`cntx-ui v2.0.8\n        \nUsage:\n  cntx-ui init                Initialize configuration\n  cntx-ui watch [port]        Start web server (default port: 3333)\n  cntx-ui watch --with-mcp    Start web server with MCP status tracking\n  cntx-ui mcp                 Start MCP server (stdio transport)\n  cntx-ui setup-mcp           Add this project to Claude Desktop MCP config\n  cntx-ui bundle [name]       Generate specific bundle (default: master)\n  cntx-ui status              Show current status\n  \nExamples:\n  cntx-ui init\n  cntx-ui watch 8080\n  cntx-ui watch --with-mcp\n  cntx-ui setup-mcp\n  cntx-ui mcp\n  cntx-ui bundle api\n\nMCP Usage:\n  The MCP server provides AI-accessible bundle management:\n  - Resources: Access bundles and files via cntx:// URIs\n  - Tools: List bundles, generate bundles, get project status\n  - Integration: Use with Claude Desktop, Cursor, or other MCP clients`);\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"debug-chunker-fields.mjs\" ext=\".mjs\">\n        <cntx:meta size=\"1032\" modified=\"2025-06-26T16:44:44.392Z\" lines=\"29\" />\n        <cntx:content><![CDATA[import TreesitterSemanticChunker from './lib/treesitter-semantic-chunker.js';\n\nconst chunker = new TreesitterSemanticChunker();\n\nconsole.log('🔍 Debugging treesitter chunker fields...');\n\ntry {\n  const result = await chunker.analyzeProject('.', ['web/src/App.tsx']);\n  \n  console.log('\\n📄 File Analysis Sample:');\n  const firstFile = Object.values(result.files)[0];\n  console.log('businessDomain:', firstFile.businessDomain);\n  console.log('technicalPatterns:', firstFile.technicalPatterns);\n  console.log('semanticType:', firstFile.semanticType);\n  \n  if (result.chunks.length > 0) {\n    console.log('\\n📦 First Chunk:');\n    const chunk = result.chunks[0];\n    console.log('name:', chunk.name);\n    console.log('businessDomains:', chunk.businessDomains);\n    console.log('technicalPatterns:', chunk.technicalPatterns);\n    console.log('cohesion:', chunk.cohesion);\n    console.log('All chunk keys:', Object.keys(chunk));\n  }\n  \n} catch (error) {\n  console.error('❌ Error:', error.message);\n  console.error(error.stack);\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"debug-chunker.mjs\" ext=\".mjs\">\n        <cntx:meta size=\"1141\" modified=\"2025-06-26T00:53:06.601Z\" lines=\"38\" />\n        <cntx:content><![CDATA[import SemanticChunker from './lib/semantic-chunker.js';\n\nconst chunker = new SemanticChunker();\n\nconsole.log('🔍 Running full analysis...\\n');\n\ntry {\n  // Run the full analysis\n  const result = await chunker.analyzeProject('.', ['web/src/**/*.{js,jsx,ts,tsx}']);\n  \n  console.log('✅ Full analysis completed!');\n  console.log('Result keys:', Object.keys(result));\n  \n  if (result.summary) {\n    console.log('\\n📊 Summary:', {\n      totalFiles: result.summary.totalFiles,\n      totalChunks: result.summary.totalChunks,\n      totalSize: result.summary.totalSize\n    });\n  }\n  \n  if (result.chunks && result.chunks.length > 0) {\n    console.log('\\n📦 First few chunks:');\n    result.chunks.slice(0, 3).forEach((chunk, i) => {\n      console.log(`${i + 1}. ${chunk.name} (${chunk.files?.length || 0} files)`);\n    });\n  }\n  \n  if (result.files) {\n    const fileKeys = Object.keys(result.files);\n    console.log(`\\n📄 Analyzed ${fileKeys.length} files`);\n    console.log('First few files:', fileKeys.slice(0, 3));\n  }\n  \n} catch (error) {\n  console.error('❌ Error during full analysis:', error.message);\n  console.error(error.stack);\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"debug-server-call.mjs\" ext=\".mjs\">\n        <cntx:meta size=\"1023\" modified=\"2025-06-26T16:45:06.782Z\" lines=\"31\" />\n        <cntx:content><![CDATA[import TreesitterSemanticChunker from './lib/treesitter-semantic-chunker.js';\n\nconst chunker = new TreesitterSemanticChunker({\n  namingStrategy: 'domain-based',\n  includeImports: true,\n  includeExports: true,\n  detectComponentTypes: true,\n  groupRelatedFiles: true\n});\n\nconsole.log('🔍 Debugging server-style call...');\n\ntry {\n  // Use same patterns as server\n  const patterns = ['web/src/**/*.{js,jsx,ts,tsx}', 'src/**/*.{js,jsx,ts,tsx}'];\n  const result = await chunker.analyzeProject(process.cwd(), patterns);\n  \n  console.log('\\n📦 Chunks from server-style call:');\n  result.chunks.slice(0, 2).forEach((chunk, i) => {\n    console.log(`${i + 1}. ${chunk.name}`);\n    console.log('   businessDomains:', chunk.businessDomains);\n    console.log('   technicalPatterns:', chunk.technicalPatterns);\n    console.log('   cohesion:', chunk.cohesion);\n    console.log('   keys:', Object.keys(chunk));\n    console.log('');\n  });\n  \n} catch (error) {\n  console.error('❌ Error:', error.message);\n  console.error(error.stack);\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"lib/function-level-chunker.js\" ext=\".js\">\n        <cntx:meta size=\"11627\" modified=\"2025-06-26T20:39:43.807Z\" lines=\"406\" />\n        <cntx:content><![CDATA[/**\n * Function-Level Semantic Chunker\n * Extracts individual functions/methods/components as discrete chunks\n * with intelligent context inclusion\n */\n\nimport { readFileSync, existsSync } from 'fs'\nimport { extname, basename, dirname, join } from 'path'\nimport glob from 'glob'\n\nexport default class FunctionLevelChunker {\n  constructor(options = {}) {\n    this.options = {\n      includeContext: true,\n      maxContextLines: 50,\n      groupRelated: true,\n      ...options\n    }\n  }\n\n  /**\n   * Extract function-level chunks from project\n   */\n  async extractFunctionChunks(projectPath, patterns = ['**/*.{js,jsx,ts,tsx,mjs}']) {\n    console.log('🔍 Starting function-level extraction...')\n    \n    const files = this.findFiles(projectPath, patterns)\n    console.log(`📁 Found ${files.length} files to analyze`)\n    \n    const allFunctions = []\n    let processedFiles = 0\n    \n    for (const filePath of files) {\n      try {\n        const functions = this.extractFunctionsFromFile(filePath, projectPath)\n        allFunctions.push(...functions)\n        processedFiles++\n      } catch (error) {\n        console.warn(`Failed to extract from ${filePath}: ${error.message}`)\n      }\n    }\n    \n    console.log(`✅ Extracted ${allFunctions.length} functions from ${processedFiles} files`)\n    \n    // Create semantic chunks from functions\n    const chunks = this.createFunctionChunks(allFunctions)\n    console.log(`📦 Created ${chunks.length} function-level chunks`)\n    \n    return {\n      summary: {\n        totalFiles: processedFiles,\n        totalFunctions: allFunctions.length,\n        totalChunks: chunks.length\n      },\n      functions: allFunctions,\n      chunks: chunks\n    }\n  }\n\n  /**\n   * Find files to analyze\n   */\n  findFiles(projectPath, patterns) {\n    const files = []\n    \n    for (const pattern of patterns) {\n      const matches = glob.sync(pattern, {\n        cwd: projectPath,\n        ignore: [\n          'node_modules/**', 'dist/**', 'build/**', '.git/**',\n          '*.test.*', '*.spec.*', '**/test/**', '**/tests/**',\n          '**/*.min.js', '**/*.bundle.js'\n        ]\n      })\n      \n      files.push(...matches.filter(file => \n        !file.includes('node_modules') && \n        !file.includes('dist/') &&\n        !file.includes('.min.')\n      ))\n    }\n    \n    return [...new Set(files)]\n  }\n\n  /**\n   * Extract all functions from a single file\n   */\n  extractFunctionsFromFile(relativePath, projectPath) {\n    const fullPath = join(projectPath, relativePath)\n    if (!existsSync(fullPath)) return []\n    \n    const content = readFileSync(fullPath, 'utf8')\n    const lines = content.split('\\n')\n    \n    const functions = []\n    \n    // Try tree-sitter first, fallback to regex\n    try {\n      const treeSitterFunctions = this.extractWithTreeSitter(content, relativePath)\n      functions.push(...treeSitterFunctions)\n    } catch (error) {\n      // Fallback to regex extraction\n      const regexFunctions = this.extractWithRegex(content, lines, relativePath)\n      functions.push(...regexFunctions)\n    }\n    \n    return functions\n  }\n\n  /**\n   * Extract functions using regex patterns (robust fallback)\n   */\n  extractWithRegex(content, lines, filePath) {\n    const functions = []\n    \n    // Patterns for different function types\n    const patterns = [\n      // Function declarations: function name() {}\n      {\n        pattern: /^[\\s]*(?:export\\s+)?(?:async\\s+)?function\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*\\(/gm,\n        type: 'function'\n      },\n      // Arrow functions: const name = () => {}\n      {\n        pattern: /^[\\s]*(?:export\\s+)?const\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?:async\\s+)?\\([^)]*\\)\\s*=>/gm,\n        type: 'arrow_function'\n      },\n      // Class methods: methodName() {}\n      {\n        pattern: /^[\\s]*(?:async\\s+)?([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*\\([^)]*\\)\\s*\\{/gm,\n        type: 'method'\n      },\n      // React components: export function ComponentName() {}\n      {\n        pattern: /^[\\s]*export\\s+(?:default\\s+)?function\\s+([A-Z][a-zA-Z0-9_$]*)\\s*\\(/gm,\n        type: 'react_component'\n      }\n    ]\n    \n    for (const { pattern, type } of patterns) {\n      let match\n      while ((match = pattern.exec(content)) !== null) {\n        const functionName = match[1]\n        const startIndex = match.index\n        \n        // Find the line number\n        const lineNumber = content.substring(0, startIndex).split('\\n').length\n        \n        // Extract function body\n        const functionInfo = this.extractFunctionBody(content, startIndex, lines, lineNumber)\n        \n        if (functionInfo && functionInfo.code.length > 10) { // Only include substantial functions\n          functions.push({\n            name: functionName,\n            type: type,\n            filePath: filePath,\n            startLine: lineNumber,\n            endLine: functionInfo.endLine,\n            code: functionInfo.code,\n            context: this.extractContext(content, functionInfo, filePath),\n            signature: match[0].trim()\n          })\n        }\n      }\n    }\n    \n    return functions\n  }\n\n  /**\n   * Extract function body by finding matching braces\n   */\n  extractFunctionBody(content, startIndex, lines, startLine) {\n    // Find opening brace\n    let braceIndex = content.indexOf('{', startIndex)\n    if (braceIndex === -1) {\n      // Handle arrow functions without braces: const fn = () => expression\n      const lineEnd = content.indexOf('\\n', startIndex)\n      if (lineEnd !== -1) {\n        const functionCode = content.substring(startIndex, lineEnd)\n        return {\n          code: functionCode,\n          endLine: startLine\n        }\n      }\n      return null\n    }\n    \n    // Count braces to find matching closing brace\n    let braceCount = 1\n    let currentIndex = braceIndex + 1\n    let inString = false\n    let stringChar = null\n    \n    while (currentIndex < content.length && braceCount > 0) {\n      const char = content[currentIndex]\n      const prevChar = content[currentIndex - 1]\n      \n      // Handle string literals to avoid counting braces inside strings\n      if ((char === '\"' || char === \"'\" || char === '`') && prevChar !== '\\\\') {\n        if (!inString) {\n          inString = true\n          stringChar = char\n        } else if (char === stringChar) {\n          inString = false\n          stringChar = null\n        }\n      }\n      \n      if (!inString) {\n        if (char === '{') braceCount++\n        else if (char === '}') braceCount--\n      }\n      \n      currentIndex++\n    }\n    \n    if (braceCount !== 0) return null // Unmatched braces\n    \n    // Extract the function code\n    const functionCode = content.substring(startIndex, currentIndex)\n    const endLine = startLine + functionCode.split('\\n').length - 1\n    \n    return {\n      code: functionCode.trim(),\n      endLine: endLine\n    }\n  }\n\n  /**\n   * Extract relevant context for a function\n   */\n  extractContext(content, functionInfo, filePath) {\n    const context = {\n      imports: this.extractImports(content),\n      types: this.extractTypes(content),\n      dependencies: [],\n      calledFunctions: this.extractCalledFunctions(functionInfo.code)\n    }\n    \n    return context\n  }\n\n  /**\n   * Extract import statements\n   */\n  extractImports(content) {\n    const imports = []\n    const importPattern = /import\\s+(?:{[^}]+}|\\*\\s+as\\s+\\w+|\\w+)\\s+from\\s+['\"`]([^'\"`]+)['\"`]/g\n    \n    let match\n    while ((match = importPattern.exec(content)) !== null) {\n      imports.push(match[1])\n    }\n    \n    return imports\n  }\n\n  /**\n   * Extract type definitions\n   */\n  extractTypes(content) {\n    const types = []\n    const typePattern = /(?:type|interface)\\s+([A-Z][a-zA-Z0-9]*)/g\n    \n    let match\n    while ((match = typePattern.exec(content)) !== null) {\n      types.push(match[1])\n    }\n    \n    return types\n  }\n\n  /**\n   * Extract function calls within code\n   */\n  extractCalledFunctions(code) {\n    const calls = []\n    const callPattern = /([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*\\(/g\n    \n    let match\n    while ((match = callPattern.exec(code)) !== null) {\n      const funcName = match[1]\n      // Filter out common keywords and built-ins\n      if (!['if', 'for', 'while', 'switch', 'catch', 'console', 'Object', 'Array'].includes(funcName)) {\n        calls.push(funcName)\n      }\n    }\n    \n    return [...new Set(calls)] // Remove duplicates\n  }\n\n  /**\n   * Create semantic chunks from extracted functions\n   */\n  createFunctionChunks(functions) {\n    const chunks = []\n    \n    // Group functions by file and related functionality\n    const fileGroups = this.groupFunctionsByFile(functions)\n    \n    for (const [filePath, fileFunctions] of Object.entries(fileGroups)) {\n      // Create individual function chunks\n      for (const func of fileFunctions) {\n        chunks.push({\n          name: `${func.name}`,\n          type: 'function',\n          subtype: func.type,\n          filePath: func.filePath,\n          functions: [func],\n          size: func.code.length,\n          complexity: this.calculateComplexity(func.code),\n          context: func.context,\n          purpose: this.determinePurpose(func),\n          tags: this.generateTags(func)\n        })\n      }\n    }\n    \n    return chunks\n  }\n\n  /**\n   * Group functions by file\n   */\n  groupFunctionsByFile(functions) {\n    const groups = {}\n    \n    for (const func of functions) {\n      if (!groups[func.filePath]) {\n        groups[func.filePath] = []\n      }\n      groups[func.filePath].push(func)\n    }\n    \n    return groups\n  }\n\n  /**\n   * Calculate function complexity\n   */\n  calculateComplexity(code) {\n    const complexityIndicators = [\n      'if', 'else', 'for', 'while', 'switch', 'case', 'try', 'catch',\n      '&&', '||', '?', ':', 'async', 'await'\n    ]\n    \n    let complexity = 1 // Base complexity\n    \n    for (const indicator of complexityIndicators) {\n      const count = (code.match(new RegExp(`\\\\b${indicator}\\\\b`, 'g')) || []).length\n      complexity += count\n    }\n    \n    return {\n      score: complexity,\n      level: complexity < 5 ? 'low' : complexity < 15 ? 'medium' : 'high'\n    }\n  }\n\n  /**\n   * Determine function purpose\n   */\n  determinePurpose(func) {\n    const name = func.name.toLowerCase()\n    const code = func.code.toLowerCase()\n    \n    if (func.type === 'react_component') return 'React component'\n    if (name.startsWith('use') && func.type === 'function') return 'React hook'\n    if (name.includes('test') || name.includes('spec')) return 'Test function'\n    if (name.includes('get') || name.includes('fetch')) return 'Data retrieval'\n    if (name.includes('create') || name.includes('add')) return 'Data creation'\n    if (name.includes('update') || name.includes('edit')) return 'Data modification'\n    if (name.includes('delete') || name.includes('remove')) return 'Data deletion'\n    if (name.includes('validate') || name.includes('check')) return 'Validation'\n    if (code.includes('express') || code.includes('router')) return 'API endpoint'\n    \n    return 'Utility function'\n  }\n\n  /**\n   * Generate tags for function\n   */\n  generateTags(func) {\n    const tags = []\n    \n    tags.push(func.type)\n    if (func.context.imports.length > 0) tags.push('has-imports')\n    if (func.context.calledFunctions.length > 3) tags.push('complex-logic')\n    if (func.code.includes('async')) tags.push('async')\n    if (func.code.includes('export')) tags.push('exported')\n    if (func.name.match(/^[A-Z]/)) tags.push('component-style')\n    \n    return tags\n  }\n\n  /**\n   * Fallback tree-sitter extraction (if available)\n   */\n  extractWithTreeSitter(content, filePath) {\n    // TODO: Implement tree-sitter extraction for functions\n    // For now, return empty to force regex fallback\n    return []\n  }\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"lib/mcp-server.js\" ext=\".js\">\n        <cntx:meta size=\"10553\" modified=\"2025-06-25T01:52:30.294Z\" lines=\"391\" />\n        <cntx:content><![CDATA[import { readFileSync } from 'fs';\nimport { join, relative } from 'path';\n\nexport class MCPServer {\n  constructor(cntxServer) {\n    this.cntxServer = cntxServer;\n    this.clientCapabilities = null;\n    this.serverInfo = {\n      name: 'cntx-ui',\n      version: '2.0.8'\n    };\n  }\n\n  // JSON-RPC 2.0 message handler\n  async handleMessage(message) {\n    try {\n      const request = typeof message === 'string' ? JSON.parse(message) : message;\n      \n      // Handle JSON-RPC 2.0 format\n      if (!request.jsonrpc || request.jsonrpc !== '2.0') {\n        return this.createErrorResponse(null, -32600, 'Invalid Request');\n      }\n\n      const response = await this.routeRequest(request);\n      return response;\n    } catch (error) {\n      return this.createErrorResponse(null, -32700, 'Parse error');\n    }\n  }\n\n  async routeRequest(request) {\n    const { method, params, id } = request;\n\n    try {\n      switch (method) {\n        case 'initialize':\n          return this.handleInitialize(params, id);\n        \n        case 'initialized':\n        case 'notifications/initialized':\n          return null; // No response needed for notification\n        \n        case 'resources/list':\n          return this.handleListResources(id);\n        \n        case 'resources/read':\n          return this.handleReadResource(params, id);\n        \n        case 'tools/list':\n          return this.handleListTools(id);\n        \n        case 'tools/call':\n          return this.handleCallTool(params, id);\n        \n        case 'prompts/list':\n          return this.createErrorResponse(id, -32601, 'Method not found');\n        \n        default:\n          return this.createErrorResponse(id, -32601, 'Method not found');\n      }\n    } catch (error) {\n      return this.createErrorResponse(id, -32603, 'Internal error', error.message);\n    }\n  }\n\n  // Initialize MCP session\n  handleInitialize(params, id) {\n    this.clientCapabilities = params?.capabilities || {};\n    \n    return this.createSuccessResponse(id, {\n      protocolVersion: '2024-11-05',\n      capabilities: {\n        resources: {\n          subscribe: true,\n          listChanged: true\n        },\n        tools: {}\n      },\n      serverInfo: this.serverInfo\n    });\n  }\n\n  // List available resources (bundles)\n  handleListResources(id) {\n    const resources = [];\n    \n    this.cntxServer.bundles.forEach((bundle, name) => {\n      resources.push({\n        uri: `cntx://bundle/${name}`,\n        name: `Bundle: ${name}`,\n        description: `File bundle containing ${bundle.files.length} files`,\n        mimeType: 'application/xml'\n      });\n    });\n\n    // Add individual file resources\n    const allFiles = this.cntxServer.getAllFiles();\n    allFiles.slice(0, 100).forEach((filePath) => { // Limit to first 100 files\n      resources.push({\n        uri: `cntx://file/${filePath}`,\n        name: `File: ${filePath}`,\n        description: `Individual file: ${filePath}`,\n        mimeType: this.getMimeType(filePath)\n      });\n    });\n\n    return this.createSuccessResponse(id, {\n      resources\n    });\n  }\n\n  // Read a specific resource\n  handleReadResource(params, id) {\n    const { uri } = params;\n    \n    if (!uri || !uri.startsWith('cntx://')) {\n      return this.createErrorResponse(id, -32602, 'Invalid URI');\n    }\n\n    try {\n      if (uri.startsWith('cntx://bundle/')) {\n        const bundleName = uri.replace('cntx://bundle/', '');\n        const bundle = this.cntxServer.bundles.get(bundleName);\n        \n        if (!bundle) {\n          return this.createErrorResponse(id, -32602, 'Bundle not found');\n        }\n\n        return this.createSuccessResponse(id, {\n          contents: [{\n            uri,\n            mimeType: 'application/xml',\n            text: bundle.content\n          }]\n        });\n      } else if (uri.startsWith('cntx://file/')) {\n        const filePath = uri.replace('cntx://file/', '');\n        const fullPath = join(this.cntxServer.CWD, filePath);\n        \n        try {\n          const content = readFileSync(fullPath, 'utf8');\n          return this.createSuccessResponse(id, {\n            contents: [{\n              uri,\n              mimeType: this.getMimeType(filePath),\n              text: content\n            }]\n          });\n        } catch (error) {\n          return this.createErrorResponse(id, -32602, 'File not found');\n        }\n      }\n\n      return this.createErrorResponse(id, -32602, 'Invalid resource URI');\n    } catch (error) {\n      return this.createErrorResponse(id, -32603, 'Internal error reading resource');\n    }\n  }\n\n  // List available tools\n  handleListTools(id) {\n    const tools = [\n      {\n        name: 'list_bundles',\n        description: 'List all available file bundles',\n        inputSchema: {\n          type: 'object',\n          properties: {},\n          required: []\n        }\n      },\n      {\n        name: 'get_bundle',\n        description: 'Get the content of a specific bundle',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            name: {\n              type: 'string',\n              description: 'Name of the bundle to retrieve'\n            }\n          },\n          required: ['name']\n        }\n      },\n      {\n        name: 'generate_bundle',\n        description: 'Regenerate a specific bundle',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            name: {\n              type: 'string',\n              description: 'Name of the bundle to regenerate'\n            }\n          },\n          required: ['name']\n        }\n      },\n      {\n        name: 'get_file_tree',\n        description: 'Get the project file tree',\n        inputSchema: {\n          type: 'object',\n          properties: {},\n          required: []\n        }\n      },\n      {\n        name: 'get_project_status',\n        description: 'Get current project status and bundle information',\n        inputSchema: {\n          type: 'object',\n          properties: {},\n          required: []\n        }\n      }\n    ];\n\n    return this.createSuccessResponse(id, { tools });\n  }\n\n  // Handle tool execution\n  async handleCallTool(params, id) {\n    const { name, arguments: args = {} } = params;\n\n    try {\n      switch (name) {\n        case 'list_bundles':\n          return this.toolListBundles(id);\n        \n        case 'get_bundle':\n          return this.toolGetBundle(args, id);\n        \n        case 'generate_bundle':\n          return this.toolGenerateBundle(args, id);\n        \n        case 'get_file_tree':\n          return this.toolGetFileTree(id);\n        \n        case 'get_project_status':\n          return this.toolGetProjectStatus(id);\n        \n        default:\n          return this.createErrorResponse(id, -32602, 'Unknown tool');\n      }\n    } catch (error) {\n      return this.createErrorResponse(id, -32603, 'Tool execution failed', error.message);\n    }\n  }\n\n  // Tool implementations\n  toolListBundles(id) {\n    const bundles = [];\n    this.cntxServer.bundles.forEach((bundle, name) => {\n      bundles.push({\n        name,\n        fileCount: bundle.files.length,\n        size: bundle.size,\n        lastGenerated: bundle.lastGenerated,\n        changed: bundle.changed,\n        patterns: bundle.patterns\n      });\n    });\n\n    return this.createSuccessResponse(id, {\n      content: [{\n        type: 'text',\n        text: `Available bundles:\\n${bundles.map(b => \n          `• ${b.name}: ${b.fileCount} files (${(b.size / 1024).toFixed(1)}KB) ${b.changed ? '[CHANGED]' : '[SYNCED]'}`\n        ).join('\\n')}`\n      }]\n    });\n  }\n\n  toolGetBundle(args, id) {\n    const { name } = args;\n    const bundle = this.cntxServer.bundles.get(name);\n    \n    if (!bundle) {\n      return this.createErrorResponse(id, -32602, `Bundle '${name}' not found`);\n    }\n\n    return this.createSuccessResponse(id, {\n      content: [{\n        type: 'text',\n        text: bundle.content\n      }]\n    });\n  }\n\n  toolGenerateBundle(args, id) {\n    const { name } = args;\n    \n    if (!this.cntxServer.bundles.has(name)) {\n      return this.createErrorResponse(id, -32602, `Bundle '${name}' not found`);\n    }\n\n    this.cntxServer.generateBundle(name);\n    this.cntxServer.saveBundleStates();\n    \n    const bundle = this.cntxServer.bundles.get(name);\n    \n    return this.createSuccessResponse(id, {\n      content: [{\n        type: 'text',\n        text: `Bundle '${name}' regenerated successfully. Contains ${bundle.files.length} files (${(bundle.size / 1024).toFixed(1)}KB).`\n      }]\n    });\n  }\n\n  toolGetFileTree(id) {\n    const fileTree = this.cntxServer.getFileTree();\n    const treeText = fileTree.map(file => \n      `${file.path} (${(file.size / 1024).toFixed(1)}KB)`\n    ).join('\\n');\n\n    return this.createSuccessResponse(id, {\n      content: [{\n        type: 'text',\n        text: `Project file tree:\\n${treeText}`\n      }]\n    });\n  }\n\n  toolGetProjectStatus(id) {\n    const bundleCount = this.cntxServer.bundles.size;\n    const changedBundles = Array.from(this.cntxServer.bundles.entries())\n      .filter(([_, bundle]) => bundle.changed)\n      .map(([name, _]) => name);\n\n    const statusText = `Project Status:\nWorking Directory: ${relative(process.cwd(), this.cntxServer.CWD)}\nTotal Bundles: ${bundleCount}\nChanged Bundles: ${changedBundles.length > 0 ? changedBundles.join(', ') : 'None'}\n\nBundle Details:\n${Array.from(this.cntxServer.bundles.entries()).map(([name, bundle]) => \n  `• ${name}: ${bundle.files.length} files, ${(bundle.size / 1024).toFixed(1)}KB ${bundle.changed ? '[CHANGED]' : '[SYNCED]'}`\n).join('\\n')}`;\n\n    return this.createSuccessResponse(id, {\n      content: [{\n        type: 'text',\n        text: statusText\n      }]\n    });\n  }\n\n  // Helper methods\n  getMimeType(filePath) {\n    const ext = filePath.split('.').pop()?.toLowerCase();\n    const mimeTypes = {\n      'js': 'application/javascript',\n      'jsx': 'application/javascript',\n      'ts': 'application/typescript',\n      'tsx': 'application/typescript',\n      'json': 'application/json',\n      'xml': 'application/xml',\n      'html': 'text/html',\n      'css': 'text/css',\n      'md': 'text/markdown',\n      'txt': 'text/plain',\n      'py': 'text/x-python',\n      'java': 'text/x-java',\n      'c': 'text/x-c',\n      'cpp': 'text/x-c++',\n      'php': 'text/x-php'\n    };\n    return mimeTypes[ext] || 'text/plain';\n  }\n\n  createSuccessResponse(id, result) {\n    return {\n      jsonrpc: '2.0',\n      id,\n      result\n    };\n  }\n\n  createErrorResponse(id, code, message, data = null) {\n    const error = { code, message };\n    if (data) error.data = data;\n    \n    return {\n      jsonrpc: '2.0',\n      id,\n      error\n    };\n  }\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"lib/mcp-transport.js\" ext=\".js\">\n        <cntx:meta size=\"2604\" modified=\"2025-06-25T01:58:02.449Z\" lines=\"97\" />\n        <cntx:content><![CDATA[import { MCPServer } from './mcp-server.js';\n\nexport class MCPTransport {\n  constructor(cntxServer) {\n    this.mcpServer = new MCPServer(cntxServer);\n    this.buffer = '';\n  }\n\n  // Start stdio transport\n  start() {\n    console.error('🚀 MCP server starting on stdio transport');\n    \n    // Handle incoming messages from stdin\n    process.stdin.on('data', (data) => {\n      this.handleIncomingData(data.toString());\n    });\n\n    // Handle process cleanup\n    process.on('SIGINT', () => {\n      console.error('📡 MCP server shutting down');\n      process.exit(0);\n    });\n\n    process.on('SIGTERM', () => {\n      console.error('📡 MCP server shutting down');\n      process.exit(0);\n    });\n\n    // Set stdin to raw mode for proper JSON-RPC communication\n    process.stdin.setEncoding('utf8');\n    \n    console.error('✅ MCP server ready for JSON-RPC messages');\n  }\n\n  // Handle incoming data and parse JSON-RPC messages\n  async handleIncomingData(data) {\n    this.buffer += data;\n    \n    // Split by newlines to handle multiple messages\n    const lines = this.buffer.split('\\n');\n    this.buffer = lines.pop() || ''; // Keep incomplete line in buffer\n\n    for (const line of lines) {\n      if (line.trim()) {\n        try {\n          const message = JSON.parse(line.trim());\n          await this.processMessage(message);\n        } catch (error) {\n          console.error('❌ Failed to parse JSON-RPC message:', error.message);\n          this.sendError(null, -32700, 'Parse error');\n        }\n      }\n    }\n  }\n\n  // Process a single JSON-RPC message\n  async processMessage(message) {\n    try {\n      const response = await this.mcpServer.handleMessage(message);\n      \n      // Only send response if not null (notifications don't need responses)\n      if (response !== null) {\n        this.sendMessage(response);\n      }\n    } catch (error) {\n      console.error('❌ Error processing message:', error.message);\n      this.sendError(message.id || null, -32603, 'Internal error');\n    }\n  }\n\n  // Send a message via stdout\n  sendMessage(message) {\n    const messageStr = JSON.stringify(message);\n    process.stdout.write(messageStr + '\\n');\n  }\n\n  // Send an error response\n  sendError(id, code, message, data = null) {\n    const error = { code, message };\n    if (data) error.data = data;\n    \n    const response = {\n      jsonrpc: '2.0',\n      id,\n      error\n    };\n    \n    this.sendMessage(response);\n  }\n}\n\n// Factory function to start MCP transport\nexport function startMCPTransport(cntxServer) {\n  const transport = new MCPTransport(cntxServer);\n  transport.start();\n  return transport;\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"lib/semantic-integration.js\" ext=\".js\">\n        <cntx:meta size=\"13532\" modified=\"2025-06-26T00:47:15.738Z\" lines=\"441\" />\n        <cntx:content><![CDATA[/**\n * Semantic Chunking Integration for cntx-ui Server\n * Extends the existing server with semantic analysis capabilities\n */\n\nimport SemanticChunker from './semantic-chunker.js'\nimport { readFileSync, writeFileSync } from 'fs'\nimport { join } from 'path'\n\nclass SemanticIntegration {\n  constructor(projectPath = process.cwd()) {\n    this.projectPath = projectPath\n    this.chunker = new SemanticChunker({\n      includeImports: true,\n      includeExports: true,\n      detectComponentTypes: true,\n      groupRelatedFiles: true,\n      minChunkSize: 100,\n      maxChunkSize: 10000\n    })\n  }\n\n  /**\n   * Analyze project and generate semantic bundle suggestions\n   */\n  async generateSemanticBundles() {\n    try {\n      console.log('🔍 Analyzing project for semantic chunking...')\n      \n      // Analyze different file types separately\n      const analyses = await Promise.all([\n        this.chunker.analyzeProject(this.projectPath, ['web/src/components/**/*.{tsx,ts}']),\n        this.chunker.analyzeProject(this.projectPath, ['web/src/hooks/**/*.{tsx,ts}']),\n        this.chunker.analyzeProject(this.projectPath, ['web/src/lib/**/*.{tsx,ts}']),\n        this.chunker.analyzeProject(this.projectPath, ['web/src/utils/**/*.{tsx,ts}']),\n        this.chunker.analyzeProject(this.projectPath, ['lib/**/*.js']),\n      ])\n\n      const [componentsAnalysis, hooksAnalysis, libAnalysis, utilsAnalysis, serverAnalysis] = analyses\n\n      // Generate bundle suggestions\n      const suggestions = this.generateBundleSuggestions([\n        { name: 'components', analysis: componentsAnalysis },\n        { name: 'hooks', analysis: hooksAnalysis },\n        { name: 'lib', analysis: libAnalysis },\n        { name: 'utils', analysis: utilsAnalysis },\n        { name: 'server', analysis: serverAnalysis }\n      ])\n\n      console.log('✅ Semantic analysis complete!')\n      \n      return {\n        timestamp: new Date().toISOString(),\n        projectPath: this.projectPath,\n        suggestions,\n        analyses: {\n          components: this.chunker.formatResults(componentsAnalysis),\n          hooks: this.chunker.formatResults(hooksAnalysis),\n          lib: this.chunker.formatResults(libAnalysis),\n          utils: this.chunker.formatResults(utilsAnalysis),\n          server: this.chunker.formatResults(serverAnalysis)\n        },\n        summary: this.generateOverallSummary(analyses)\n      }\n    } catch (error) {\n      console.error('❌ Semantic analysis failed:', error.message)\n      throw error\n    }\n  }\n\n  /**\n   * Generate bundle configuration suggestions based on semantic analysis\n   */\n  generateBundleSuggestions(namedAnalyses) {\n    const suggestions = {\n      recommended: {},\n      alternative: {},\n      notes: []\n    }\n\n    for (const { name, analysis } of namedAnalyses) {\n      if (analysis.chunks.length === 0) continue\n\n      // Recommended: Group by semantic purpose\n      const purposeGroups = this.groupChunksByPurpose(analysis.chunks)\n      \n      for (const [purpose, chunks] of Object.entries(purposeGroups)) {\n        const bundleName = `${name}-${purpose}`\n        const patterns = this.generatePatternsForChunks(chunks)\n        \n        suggestions.recommended[bundleName] = patterns\n      }\n\n      // Alternative: Group by directory structure\n      const dirGroups = this.groupChunksByDirectory(analysis.chunks)\n      \n      for (const [dir, chunks] of Object.entries(dirGroups)) {\n        const bundleName = `${name}-${dir}`\n        const patterns = this.generatePatternsForChunks(chunks)\n        \n        suggestions.alternative[bundleName] = patterns\n      }\n    }\n\n    // Add specialized bundles\n    this.addSpecializedBundles(suggestions, namedAnalyses)\n\n    // Add optimization notes\n    this.addOptimizationNotes(suggestions, namedAnalyses)\n\n    return suggestions\n  }\n\n  /**\n   * Group chunks by their primary purpose\n   */\n  groupChunksByPurpose(chunks) {\n    const groups = {}\n    \n    for (const chunk of chunks) {\n      const purpose = chunk.purpose || 'misc'\n      if (!groups[purpose]) {\n        groups[purpose] = []\n      }\n      groups[purpose].push(chunk)\n    }\n    \n    return groups\n  }\n\n  /**\n   * Group chunks by directory structure\n   */\n  groupChunksByDirectory(chunks) {\n    const groups = {}\n    \n    for (const chunk of chunks) {\n      // Extract directory from chunk name or files\n      const dir = chunk.name.split('-')[0] || 'misc'\n      if (!groups[dir]) {\n        groups[dir] = []\n      }\n      groups[dir].push(chunk)\n    }\n    \n    return groups\n  }\n\n  /**\n   * Generate glob patterns for chunks\n   */\n  generatePatternsForChunks(chunks) {\n    const patterns = new Set()\n    \n    for (const chunk of chunks) {\n      for (const file of chunk.files) {\n        // Convert file paths to glob patterns\n        const pattern = this.fileToGlobPattern(file)\n        patterns.add(pattern)\n      }\n    }\n    \n    return Array.from(patterns)\n  }\n\n  /**\n   * Convert file path to glob pattern\n   */\n  fileToGlobPattern(filePath) {\n    // Extract directory and create pattern\n    const parts = filePath.split('/')\n    const dir = parts.slice(0, -1).join('/')\n    const ext = parts[parts.length - 1].split('.').pop()\n    \n    return `${dir}/**/*.${ext}`\n  }\n\n  /**\n   * Add specialized bundle suggestions\n   */\n  addSpecializedBundles(suggestions, namedAnalyses) {\n    // UI Components bundle\n    const componentsAnalysis = namedAnalyses.find(a => a.name === 'components')?.analysis\n    if (componentsAnalysis?.chunks.length > 0) {\n      const uiComponents = componentsAnalysis.chunks.filter(c => \n        c.name.includes('ui') || c.tags.includes('has-components')\n      )\n      \n      if (uiComponents.length > 0) {\n        suggestions.recommended['ui-system'] = [\n          'web/src/components/ui/**/*.tsx',\n          'web/src/components/theme-*.tsx'\n        ]\n      }\n    }\n\n    // Test files bundle\n    suggestions.recommended['tests'] = [\n      '**/*.test.{js,jsx,ts,tsx}',\n      '**/*.spec.{js,jsx,ts,tsx}',\n      '**/__tests__/**/*'\n    ]\n\n    // Configuration bundle\n    suggestions.recommended['config'] = [\n      '*.config.{js,ts}',\n      '*.json',\n      'package.json',\n      'tsconfig*.json',\n      '.env*'\n    ]\n\n    // Documentation bundle\n    suggestions.recommended['docs'] = [\n      '**/*.md',\n      'docs/**/*',\n      'README*'\n    ]\n  }\n\n  /**\n   * Add optimization notes and recommendations\n   */\n  addOptimizationNotes(suggestions, namedAnalyses) {\n    suggestions.notes = []\n\n    // Analyze bundle sizes\n    const totalFiles = namedAnalyses.reduce((sum, a) => sum + a.analysis.summary.totalFiles, 0)\n    const totalChunks = namedAnalyses.reduce((sum, a) => sum + a.analysis.summary.totalChunks, 0)\n    \n    suggestions.notes.push({\n      type: 'info',\n      message: `Project has ${totalFiles} files organized into ${totalChunks} semantic chunks`\n    })\n\n    // Check for large files\n    const largeFiles = []\n    for (const { analysis } of namedAnalyses) {\n      for (const [path, file] of Object.entries(analysis.files)) {\n        if (file.lines > 300) {\n          largeFiles.push({ path, lines: file.lines })\n        }\n      }\n    }\n\n    if (largeFiles.length > 0) {\n      suggestions.notes.push({\n        type: 'warning',\n        message: `${largeFiles.length} files exceed 300 lines and may benefit from splitting`,\n        details: largeFiles.slice(0, 3).map(f => `${f.path} (${f.lines} lines)`)\n      })\n    }\n\n    // Check for high complexity\n    const complexFiles = []\n    for (const { analysis } of namedAnalyses) {\n      for (const [path, file] of Object.entries(analysis.files)) {\n        if (file.complexity?.level === 'high') {\n          complexFiles.push({ path, score: file.complexity.score })\n        }\n      }\n    }\n\n    if (complexFiles.length > 0) {\n      suggestions.notes.push({\n        type: 'optimization',\n        message: `${complexFiles.length} files have high complexity and may need refactoring`,\n        details: complexFiles.slice(0, 3).map(f => `${f.path} (score: ${f.score})`)\n      })\n    }\n\n    // Suggest bundle patterns\n    suggestions.notes.push({\n      type: 'suggestion',\n      message: 'Consider using semantic bundles for better AI context understanding',\n      details: [\n        'UI components grouped by functionality',\n        'Hooks grouped by domain logic',\n        'Utilities grouped by purpose',\n        'Tests separated for focused debugging'\n      ]\n    })\n  }\n\n  /**\n   * Generate overall project summary\n   */\n  generateOverallSummary(analyses) {\n    const totalFiles = analyses.reduce((sum, a) => sum + a.summary.totalFiles, 0)\n    const totalSize = analyses.reduce((sum, a) => sum + a.summary.totalSize, 0)\n    const totalLines = analyses.reduce((sum, a) => sum + a.summary.totalLines, 0)\n    const totalChunks = analyses.reduce((sum, a) => sum + a.summary.totalChunks, 0)\n\n    const fileTypes = {}\n    const filePurposes = {}\n    const complexityDistribution = {}\n\n    for (const analysis of analyses) {\n      // Merge file types\n      for (const [type, count] of Object.entries(analysis.summary.fileTypes)) {\n        fileTypes[type] = (fileTypes[type] || 0) + count\n      }\n      \n      // Merge purposes\n      for (const [purpose, count] of Object.entries(analysis.summary.filePurposes)) {\n        filePurposes[purpose] = (filePurposes[purpose] || 0) + count\n      }\n      \n      // Merge complexity\n      for (const [level, count] of Object.entries(analysis.summary.complexityDistribution)) {\n        complexityDistribution[level] = (complexityDistribution[level] || 0) + count\n      }\n    }\n\n    return {\n      totalFiles,\n      totalSize,\n      totalLines,\n      totalChunks,\n      fileTypes,\n      filePurposes,\n      complexityDistribution,\n      averageFileSize: Math.round(totalSize / totalFiles),\n      averageLinesPerFile: Math.round(totalLines / totalFiles),\n      formattedSize: this.formatBytes(totalSize)\n    }\n  }\n\n  /**\n   * Convert semantic suggestions to cntx-ui bundle format\n   */\n  convertToConfigFormat(suggestions) {\n    return {\n      bundles: {\n        // Keep existing master bundle\n        master: ['**/*'],\n        \n        // Add recommended semantic bundles\n        ...suggestions.recommended,\n        \n        // Add alternative bundles as commented examples\n        // ...suggestions.alternative (uncomment to use directory-based grouping)\n      }\n    }\n  }\n\n  /**\n   * Save analysis results to file\n   */\n  async saveAnalysisResults(results, outputPath = 'semantic-analysis.json') {\n    try {\n      const fullPath = join(this.projectPath, outputPath)\n      writeFileSync(fullPath, JSON.stringify(results, null, 2))\n      console.log(`📁 Analysis saved to ${fullPath}`)\n      return fullPath\n    } catch (error) {\n      console.error('❌ Failed to save analysis:', error.message)\n      throw error\n    }\n  }\n\n  /**\n   * Generate bundle config suggestions file\n   */\n  async generateBundleConfigSuggestions(results, outputPath = 'semantic-bundle-suggestions.json') {\n    try {\n      const config = this.convertToConfigFormat(results.suggestions)\n      const fullPath = join(this.projectPath, outputPath)\n      \n      const output = {\n        timestamp: results.timestamp,\n        description: 'Semantic chunking suggestions for cntx-ui bundles',\n        usage: 'Copy the bundles object to your .cntx/bundles.json file',\n        ...config,\n        notes: results.suggestions.notes,\n        summary: results.summary\n      }\n      \n      writeFileSync(fullPath, JSON.stringify(output, null, 2))\n      console.log(`📦 Bundle suggestions saved to ${fullPath}`)\n      return fullPath\n    } catch (error) {\n      console.error('❌ Failed to save bundle suggestions:', error.message)\n      throw error\n    }\n  }\n\n  /**\n   * Format bytes to human readable\n   */\n  formatBytes(bytes) {\n    if (bytes === 0) return '0 Bytes'\n    const k = 1024\n    const sizes = ['Bytes', 'KB', 'MB', 'GB']\n    const i = Math.floor(Math.log(bytes) / Math.log(k))\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]\n  }\n}\n\nexport default SemanticIntegration\n\n// CLI usage\nif (import.meta.url === `file://${process.argv[1]}`) {\n  const integration = new SemanticIntegration()\n  \n  console.log('🚀 Starting semantic analysis integration...')\n  \n  try {\n    const results = await integration.generateSemanticBundles()\n    \n    // Save full analysis\n    await integration.saveAnalysisResults(results)\n    \n    // Save bundle suggestions\n    await integration.generateBundleConfigSuggestions(results)\n    \n    console.log('\\n📊 Project Summary:')\n    console.log(`📁 ${results.summary.totalFiles} files analyzed`)\n    console.log(`💾 ${results.summary.formattedSize} total size`)\n    console.log(`📦 ${results.summary.totalChunks} semantic chunks created`)\n    console.log(`🎯 ${Object.keys(results.suggestions.recommended).length} recommended bundles`)\n    \n    console.log('\\n🎯 Recommended Bundles:')\n    for (const [name, patterns] of Object.entries(results.suggestions.recommended)) {\n      console.log(`  • ${name}: ${patterns.length} patterns`)\n    }\n    \n    console.log('\\n💡 Notes:')\n    results.suggestions.notes.forEach(note => {\n      const emoji = note.type === 'warning' ? '⚠️' : note.type === 'optimization' ? '🔧' : '💡'\n      console.log(`  ${emoji} ${note.message}`)\n    })\n    \n    console.log('\\n✅ Semantic integration complete!')\n    console.log('📄 Check semantic-bundle-suggestions.json for ready-to-use bundle configurations')\n    \n  } catch (error) {\n    console.error('❌ Integration failed:', error.message)\n    process.exit(1)\n  }\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"lib/semantic-splitter.js\" ext=\".js\">\n        <cntx:meta size=\"18236\" modified=\"2025-06-26T22:26:39.401Z\" lines=\"595\" />\n        <cntx:content><![CDATA[/**\n * True Semantic Splitting - Function-level code chunks with context\n * Creates surgical, self-contained chunks for AI consumption\n * Operates parallel to file-level bundle system\n */\n\nimport { readFileSync, existsSync } from 'fs'\nimport { extname, basename, dirname, join } from 'path'\nimport glob from 'glob'\n\nexport default class SemanticSplitter {\n  constructor(options = {}) {\n    this.options = {\n      maxChunkSize: 2000,       // Max chars per chunk\n      includeContext: true,     // Include imports/types needed\n      groupRelated: true,       // Group related functions\n      minFunctionSize: 50,      // Skip tiny functions\n      ...options\n    }\n  }\n\n  /**\n   * Extract semantic chunks from project\n   */\n  async extractSemanticChunks(projectPath, patterns = ['**/*.{js,jsx,ts,tsx,mjs}'], bundleConfig = null) {\n    console.log('🔪 Starting semantic splitting...')\n    \n    const files = this.findFiles(projectPath, patterns)\n    console.log(`📁 Found ${files.length} files to split`)\n    \n    // Load bundle configuration if provided\n    this.bundleConfig = bundleConfig\n    \n    const allFunctions = []\n    const allTypes = []\n    const allImports = []\n    \n    // Extract all code elements\n    for (const filePath of files) {\n      try {\n        const elements = this.extractCodeElements(filePath, projectPath)\n        allFunctions.push(...elements.functions)\n        allTypes.push(...elements.types)\n        allImports.push(...elements.imports)\n      } catch (error) {\n        console.warn(`Failed to extract from ${filePath}: ${error.message}`)\n      }\n    }\n    \n    console.log(`⚡ Extracted ${allFunctions.length} functions, ${allTypes.length} types`)\n    \n    // Create semantic chunks\n    const chunks = this.createSemanticChunks(allFunctions, allTypes, allImports)\n    console.log(`🧩 Created ${chunks.length} semantic chunks`)\n    \n    return {\n      summary: {\n        totalFiles: files.length,\n        totalFunctions: allFunctions.length,\n        totalChunks: chunks.length,\n        averageChunkSize: chunks.reduce((sum, c) => sum + c.code.length, 0) / chunks.length\n      },\n      chunks: chunks\n    }\n  }\n\n  /**\n   * Find files to analyze (same logic as bundles)\n   */\n  findFiles(projectPath, patterns) {\n    const files = []\n    \n    for (const pattern of patterns) {\n      const matches = glob.sync(pattern, {\n        cwd: projectPath,\n        ignore: [\n          'node_modules/**', 'dist/**', 'build/**', '.git/**',\n          '*.test.*', '*.spec.*', '**/test/**', '**/tests/**',\n          '**/*.min.js', '**/*.bundle.js'\n        ]\n      })\n      \n      files.push(...matches.filter(file => \n        !file.includes('node_modules') && \n        !file.includes('dist/') &&\n        !file.includes('.min.')\n      ))\n    }\n    \n    return [...new Set(files)]\n  }\n\n  /**\n   * Extract functions, types, and imports from a file\n   */\n  extractCodeElements(relativePath, projectPath) {\n    const fullPath = join(projectPath, relativePath)\n    if (!existsSync(fullPath)) return { functions: [], types: [], imports: [] }\n    \n    const content = readFileSync(fullPath, 'utf8')\n    const lines = content.split('\\n')\n    \n    return {\n      functions: this.extractFunctions(content, lines, relativePath),\n      types: this.extractTypes(content, lines, relativePath),\n      imports: this.extractImports(content, relativePath)\n    }\n  }\n\n  /**\n   * Extract functions with robust regex patterns\n   */\n  extractFunctions(content, lines, filePath) {\n    const functions = []\n    \n    // Pattern 1: Regular function declarations\n    const functionRegex = /^(\\s*)(?:export\\s+)?(?:async\\s+)?function\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*\\([^)]*\\)\\s*\\{/gm\n    \n    // Pattern 2: Arrow functions assigned to const/let\n    const arrowRegex = /^(\\s*)(?:export\\s+)?const\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?:async\\s+)?\\([^)]*\\)\\s*=>\\s*[\\{]/gm\n    \n    // Pattern 3: Class methods\n    const methodRegex = /^(\\s+)(?:async\\s+)?([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*\\([^)]*\\)\\s*\\{/gm\n    \n    // Pattern 4: React components (function components)\n    const componentRegex = /^(\\s*)(?:export\\s+(?:default\\s+)?)?function\\s+([A-Z][a-zA-Z0-9_$]*)\\s*\\([^)]*\\)\\s*\\{/gm\n    \n    const patterns = [\n      { regex: functionRegex, type: 'function' },\n      { regex: arrowRegex, type: 'arrow_function' },\n      { regex: methodRegex, type: 'method' },\n      { regex: componentRegex, type: 'react_component' }\n    ]\n    \n    for (const { regex, type } of patterns) {\n      let match\n      while ((match = regex.exec(content)) !== null) {\n        const functionName = match[2]\n        const indentation = match[1]\n        const startIndex = match.index\n        \n        // Skip if it's a keyword or common false positive\n        if (['if', 'for', 'while', 'switch', 'catch'].includes(functionName)) {\n          continue\n        }\n        \n        const startLine = content.substring(0, startIndex).split('\\n').length\n        const functionBody = this.extractFunctionBody(content, startIndex)\n        \n        if (functionBody && functionBody.length > this.options.minFunctionSize) {\n          functions.push({\n            name: functionName,\n            type: type,\n            filePath: filePath,\n            startLine: startLine,\n            code: functionBody,\n            indentation: indentation.length,\n            isExported: match[0].includes('export'),\n            isAsync: match[0].includes('async'),\n            size: functionBody.length\n          })\n        }\n      }\n    }\n    \n    return functions\n  }\n\n  /**\n   * Extract function body using brace matching\n   */\n  extractFunctionBody(content, startIndex) {\n    const openBraceIndex = content.indexOf('{', startIndex)\n    if (openBraceIndex === -1) return null\n    \n    let braceCount = 0\n    let currentIndex = openBraceIndex\n    let inString = false\n    let stringChar = null\n    \n    while (currentIndex < content.length) {\n      const char = content[currentIndex]\n      const prevChar = content[currentIndex - 1] || ''\n      \n      // Handle string literals\n      if ((char === '\"' || char === \"'\" || char === '`') && prevChar !== '\\\\') {\n        if (!inString) {\n          inString = true\n          stringChar = char\n        } else if (char === stringChar) {\n          inString = false\n          stringChar = null\n        }\n      }\n      \n      // Count braces outside strings\n      if (!inString) {\n        if (char === '{') braceCount++\n        else if (char === '}') braceCount--\n        \n        if (braceCount === 0) {\n          // Found the closing brace\n          return content.substring(startIndex, currentIndex + 1).trim()\n        }\n      }\n      \n      currentIndex++\n    }\n    \n    return null // Unmatched braces\n  }\n\n  /**\n   * Extract type definitions and interfaces\n   */\n  extractTypes(content, lines, filePath) {\n    const types = []\n    \n    // TypeScript interfaces\n    const interfaceRegex = /^(\\s*)(?:export\\s+)?interface\\s+([A-Z][a-zA-Z0-9_$]*)\\s*\\{/gm\n    \n    // Type aliases\n    const typeRegex = /^(\\s*)(?:export\\s+)?type\\s+([A-Z][a-zA-Z0-9_$]*)\\s*=/gm\n    \n    const patterns = [\n      { regex: interfaceRegex, type: 'interface' },\n      { regex: typeRegex, type: 'type_alias' }\n    ]\n    \n    for (const { regex, type } of patterns) {\n      let match\n      while ((match = regex.exec(content)) !== null) {\n        const typeName = match[2]\n        const startIndex = match.index\n        const startLine = content.substring(0, startIndex).split('\\n').length\n        \n        let typeBody\n        if (type === 'interface') {\n          typeBody = this.extractTypeBody(content, startIndex)\n        } else {\n          // For type aliases, extract until semicolon or newline\n          const endIndex = content.indexOf(';', startIndex)\n          typeBody = content.substring(startIndex, endIndex + 1).trim()\n        }\n        \n        if (typeBody) {\n          types.push({\n            name: typeName,\n            type: type,\n            filePath: filePath,\n            startLine: startLine,\n            code: typeBody,\n            isExported: match[0].includes('export')\n          })\n        }\n      }\n    }\n    \n    return types\n  }\n\n  /**\n   * Extract type body (similar to function body)\n   */\n  extractTypeBody(content, startIndex) {\n    const openBraceIndex = content.indexOf('{', startIndex)\n    if (openBraceIndex === -1) return null\n    \n    let braceCount = 0\n    let currentIndex = openBraceIndex\n    \n    while (currentIndex < content.length) {\n      const char = content[currentIndex]\n      \n      if (char === '{') braceCount++\n      else if (char === '}') braceCount--\n      \n      if (braceCount === 0) {\n        return content.substring(startIndex, currentIndex + 1).trim()\n      }\n      \n      currentIndex++\n    }\n    \n    return null\n  }\n\n  /**\n   * Extract import statements\n   */\n  extractImports(content, filePath) {\n    const imports = []\n    const importRegex = /^(\\s*)import\\s+(.+?)\\s+from\\s+['\"`]([^'\"`]+)['\"`]/gm\n    \n    let match\n    while ((match = importRegex.exec(content)) !== null) {\n      const importStatement = match[0].trim()\n      const importPath = match[3]\n      \n      imports.push({\n        statement: importStatement,\n        path: importPath,\n        filePath: filePath,\n        isRelative: importPath.startsWith('.'),\n        isExternal: !importPath.startsWith('.')\n      })\n    }\n    \n    return imports\n  }\n\n  /**\n   * Create semantic chunks from extracted elements\n   */\n  createSemanticChunks(functions, types, imports) {\n    const chunks = []\n    \n    // Create function-level chunks\n    for (const func of functions) {\n      const chunk = this.createFunctionChunk(func, types, imports)\n      if (chunk) {\n        chunks.push(chunk)\n      }\n    }\n    \n    // Create type-only chunks for standalone types\n    for (const type of types) {\n      if (!this.isTypeUsedInFunctions(type, functions)) {\n        chunks.push(this.createTypeChunk(type, imports))\n      }\n    }\n    \n    return chunks\n  }\n\n  /**\n   * Create a semantic chunk for a function with its context\n   */\n  createFunctionChunk(func, allTypes, allImports) {\n    let chunkCode = ''\n    const includedImports = new Set()\n    const includedTypes = new Set()\n    \n    // Find relevant imports for this function\n    const fileImports = allImports.filter(imp => imp.filePath === func.filePath)\n    \n    // Find types referenced in the function\n    const referencedTypes = this.findReferencedTypes(func.code, allTypes)\n    \n    // Add necessary imports\n    for (const imp of fileImports) {\n      if (this.isImportRelevant(imp, func.code)) {\n        chunkCode += imp.statement + '\\n'\n        includedImports.add(imp.path)\n      }\n    }\n    \n    // Add referenced types\n    for (const type of referencedTypes) {\n      chunkCode += '\\n' + type.code + '\\n'\n      includedTypes.add(type.name)\n    }\n    \n    // Add the function itself\n    chunkCode += '\\n' + func.code\n    \n    // Create chunk with adaptive sizing - never lose functions\n    let finalCode = chunkCode.trim()\n    let contextLevel = 'full'\n    \n    // If too large, try with reduced context\n    if (chunkCode.length > this.options.maxChunkSize) {\n      // Fallback 1: Function + essential imports only (no types)\n      finalCode = ''\n      for (const imp of fileImports.slice(0, 3)) { // Limit to 3 imports\n        if (this.isImportRelevant(imp, func.code)) {\n          finalCode += imp.statement + '\\n'\n        }\n      }\n      finalCode += '\\n' + func.code\n      contextLevel = 'reduced'\n    }\n    \n    // If still too large, function only\n    if (finalCode.length > this.options.maxChunkSize) {\n      finalCode = func.code\n      contextLevel = 'minimal'\n    }\n    \n    // Always create a chunk - never lose functions\n    return {\n      name: func.name,\n      type: 'function_chunk',\n      subtype: func.type,\n      code: finalCode,\n      size: finalCode.length,\n      filePath: func.filePath,\n      startLine: func.startLine,\n      isExported: func.isExported,\n      isAsync: func.isAsync,\n      complexity: this.calculateComplexity(func.code),\n      includes: {\n        imports: contextLevel === 'minimal' ? [] : Array.from(includedImports),\n        types: contextLevel === 'full' ? Array.from(includedTypes) : []\n      },\n      purpose: this.determinePurpose(func),\n      tags: [...this.generateTags(func), contextLevel === 'full' ? 'full-context' : contextLevel === 'reduced' ? 'reduced-context' : 'minimal-context'],\n      bundles: this.getFileBundles(func.filePath)\n    }\n  }\n\n  /**\n   * Create a chunk for standalone types\n   */\n  createTypeChunk(type, allImports) {\n    let chunkCode = ''\n    \n    // Add relevant imports if any\n    const fileImports = allImports.filter(imp => imp.filePath === type.filePath)\n    for (const imp of fileImports.slice(0, 3)) { // Limit imports\n      chunkCode += imp.statement + '\\n'\n    }\n    \n    chunkCode += '\\n' + type.code\n    \n    return {\n      name: type.name,\n      type: 'type_chunk',\n      subtype: type.type,\n      code: chunkCode.trim(),\n      size: chunkCode.length,\n      filePath: type.filePath,\n      startLine: type.startLine,\n      isExported: type.isExported,\n      purpose: 'Type definition',\n      tags: ['type', type.type],\n      bundles: this.getFileBundles(type.filePath)\n    }\n  }\n\n  /**\n   * Find types referenced in function code\n   */\n  findReferencedTypes(functionCode, allTypes) {\n    const referenced = []\n    \n    for (const type of allTypes) {\n      // Check if type name appears in function code\n      const typeRegex = new RegExp(`\\\\b${type.name}\\\\b`, 'g')\n      if (typeRegex.test(functionCode)) {\n        referenced.push(type)\n      }\n    }\n    \n    return referenced\n  }\n\n  /**\n   * Check if import is relevant to function\n   */\n  isImportRelevant(importStatement, functionCode) {\n    // Simple heuristic: check if any imported identifiers appear in function\n    const importMatch = importStatement.statement.match(/import\\s+(.+?)\\s+from/)\n    if (!importMatch) return false\n    \n    const imported = importMatch[1]\n    \n    // Handle different import styles\n    if (imported.includes('{')) {\n      // Named imports: import { foo, bar } from 'module'\n      const namedImports = imported.match(/\\{([^}]+)\\}/)?.[1]\n      if (namedImports) {\n        const names = namedImports.split(',').map(name => name.trim())\n        return names.some(name => functionCode.includes(name))\n      }\n    } else {\n      // Default import: import foo from 'module'\n      const defaultImport = imported.trim()\n      return functionCode.includes(defaultImport)\n    }\n    \n    return false\n  }\n\n  /**\n   * Check if type is used in any function\n   */\n  isTypeUsedInFunctions(type, functions) {\n    const typeRegex = new RegExp(`\\\\b${type.name}\\\\b`, 'g')\n    return functions.some(func => typeRegex.test(func.code))\n  }\n\n  /**\n   * Calculate function complexity (cyclomatic complexity)\n   */\n  calculateComplexity(code) {\n    let complexity = 1 // Base complexity\n    \n    // Simple complexity indicators - just count control flow structures\n    const indicators = {\n      'if': (code.match(/\\bif\\s*\\(/g) || []).length,\n      'else if': (code.match(/\\belse\\s+if\\b/g) || []).length,\n      'for': (code.match(/\\bfor\\s*\\(/g) || []).length,\n      'while': (code.match(/\\bwhile\\s*\\(/g) || []).length,\n      'switch': (code.match(/\\bswitch\\s*\\(/g) || []).length,\n      'case': (code.match(/\\bcase\\s+/g) || []).length,\n      'catch': (code.match(/\\bcatch\\s*\\(/g) || []).length,\n      'ternary': (code.match(/\\?\\s*[^?\\.\\s]/g) || []).length,\n      'logical_and': (code.match(/&&\\s*[^&=]/g) || []).length,\n      'logical_or': (code.match(/\\|\\|\\s*[^|=]/g) || []).length\n    }\n    \n    // Sum all complexity indicators\n    for (const count of Object.values(indicators)) {\n      complexity += count\n    }\n    \n    // Return complexity with reasonable thresholds\n    return {\n      score: complexity,\n      level: complexity <= 3 ? 'low' : complexity <= 8 ? 'medium' : 'high'\n    }\n  }\n\n  /**\n   * Determine function purpose\n   */\n  determinePurpose(func) {\n    const name = func.name.toLowerCase()\n    \n    if (func.type === 'react_component') return 'React component'\n    if (name.startsWith('use') && func.type === 'function') return 'React hook'\n    if (name.includes('api') || name.includes('endpoint')) return 'API handler'\n    if (name.includes('get') || name.includes('fetch')) return 'Data retrieval'\n    if (name.includes('create') || name.includes('add')) return 'Data creation'\n    if (name.includes('update') || name.includes('edit')) return 'Data modification'\n    if (name.includes('delete') || name.includes('remove')) return 'Data deletion'\n    if (name.includes('validate') || name.includes('check')) return 'Validation'\n    if (name.includes('parse') || name.includes('format')) return 'Data processing'\n    \n    return 'Utility function'\n  }\n\n  /**\n   * Generate tags for function\n   */\n  generateTags(func) {\n    const tags = [func.type]\n    \n    if (func.isExported) tags.push('exported')\n    if (func.isAsync) tags.push('async')\n    if (func.size > 1000) tags.push('large')\n    if (func.code.includes('console.log')) tags.push('has-logging')\n    if (func.code.includes('throw')) tags.push('can-throw')\n    if (func.code.includes('return')) tags.push('returns-value')\n    \n    return tags\n  }\n\n  /**\n   * Determine which bundles a file belongs to\n   */\n  getFileBundles(filePath) {\n    if (!this.bundleConfig?.bundles) return []\n    \n    const bundles = []\n    for (const [bundleName, patterns] of Object.entries(this.bundleConfig.bundles)) {\n      // Skip master bundle as requested\n      if (bundleName === 'master') continue\n      \n      // Check if file matches any pattern in this bundle\n      for (const pattern of patterns) {\n        if (this.matchesPattern(filePath, pattern)) {\n          bundles.push(bundleName)\n          break // Don't add the same bundle multiple times\n        }\n      }\n    }\n    \n    return bundles\n  }\n\n  /**\n   * Simple pattern matching (basic glob support)\n   */\n  matchesPattern(filePath, pattern) {\n    // Convert glob pattern to regex\n    const regex = pattern\n      .replace(/\\*\\*/g, '.*')  // ** matches any directories\n      .replace(/\\*/g, '[^/]*') // * matches any characters except /\n      .replace(/\\./g, '\\\\.')   // Escape dots\n    \n    return new RegExp(`^${regex}$`).test(filePath)\n  }\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"lib/treesitter-semantic-chunker.js\" ext=\".js\">\n        <cntx:meta size=\"47971\" modified=\"2025-06-26T20:26:54.461Z\" lines=\"1485\" />\n        <cntx:content><![CDATA[/**\n * Treesitter-based Semantic Chunker for JavaScript/TypeScript Files\n * Uses tree-sitter for true AST-based code analysis and semantic chunking\n * Supports JS/TS/JSX/TSX with equal treatment\n * Node ecosystem focus: React components, Express APIs, CLI tools, utilities\n */\n\nimport { readFileSync, existsSync } from 'fs'\nimport { extname, basename, dirname, relative, join } from 'path'\nimport glob from 'glob'\nimport { promisify } from 'util'\nimport Parser from 'tree-sitter'\nimport JavaScript from 'tree-sitter-javascript'\nimport TypeScript from 'tree-sitter-typescript'\n\nconst globAsync = promisify(glob)\n\nclass TreesitterSemanticChunker {\n  constructor(options = {}) {\n    this.options = {\n      includeImports: true,\n      includeExports: true,\n      detectComponentTypes: true,\n      groupRelatedFiles: true,\n      minChunkSize: 100,\n      maxChunkSize: 50000,\n      namingStrategy: 'domain-based', // domain-based, pattern-based, graph-based\n      ...options\n    }\n    \n    // Initialize parsers for different languages\n    this.parsers = {}\n    this.initializeParsers()\n    \n    // Semantic patterns for Node ecosystem\n    this.semanticPatterns = {\n      reactComponent: this.isReactComponent.bind(this),\n      reactHook: this.isReactHook.bind(this),\n      expressRoute: this.isExpressRoute.bind(this),\n      expressMiddleware: this.isExpressMiddleware.bind(this),\n      cliCommand: this.isCliCommand.bind(this),\n      utilityFunction: this.isUtilityFunction.bind(this),\n      apiHandler: this.isApiHandler.bind(this),\n      typeDefinition: this.isTypeDefinition.bind(this),\n      configModule: this.isConfigModule.bind(this)\n    }\n  }\n\n  /**\n   * Initialize tree-sitter parsers for different languages\n   */\n  initializeParsers() {\n    // JavaScript parser\n    this.parsers.javascript = new Parser()\n    this.parsers.javascript.setLanguage(JavaScript)\n    \n    // TypeScript parser  \n    this.parsers.typescript = new Parser()\n    this.parsers.typescript.setLanguage(TypeScript.typescript)\n    \n    // TSX parser\n    this.parsers.tsx = new Parser()\n    this.parsers.tsx.setLanguage(TypeScript.tsx)\n  }\n\n  /**\n   * Get appropriate parser for file extension\n   */\n  getParser(filePath) {\n    const ext = extname(filePath)\n    switch (ext) {\n      case '.ts': return this.parsers.typescript\n      case '.tsx': return this.parsers.tsx\n      case '.js':\n      case '.jsx':\n      default: return this.parsers.javascript\n    }\n  }\n\n  /**\n   * Main entry point - analyze files and create semantic chunks\n   */\n  async analyzeProject(projectPath, patterns = ['**/*.{js,jsx,ts,tsx}']) {\n    console.log('🔍 Starting treesitter-based semantic analysis...')\n    \n    const files = await this.findFiles(projectPath, patterns)\n    console.log(`📁 Found ${files.length} files to analyze`)\n    \n    const analysis = await this.analyzeFiles(files, projectPath)\n    const successfulFiles = Object.keys(analysis).filter(f => !analysis[f].error)\n    console.log(`✅ Analyzed ${Object.keys(analysis).length} files (${successfulFiles.length} successful)`)\n    if (successfulFiles.length > 0) {\n      console.log('📝 Sample successful files:', successfulFiles.slice(0, 5))\n    }\n    \n    const relationshipGraph = this.buildRelationshipGraph(analysis)\n    console.log(`🔗 Built relationship graph with ${Object.keys(relationshipGraph).length} nodes`)\n    \n    const chunks = await this.createSmartChunks(analysis, relationshipGraph)\n    console.log(`📦 Created ${chunks.length} semantic chunks`)\n    \n    return {\n      summary: this.generateSummary(analysis, chunks),\n      files: analysis,\n      chunks: chunks,\n      relationshipGraph,\n      recommendations: this.generateRecommendations(analysis, chunks)\n    }\n  }\n\n  /**\n   * Find files matching patterns\n   */\n  async findFiles(projectPath, patterns) {\n    const files = []\n    \n    for (const pattern of patterns) {\n      const matches = await globAsync(pattern, { \n        cwd: projectPath,\n        ignore: [\n          'node_modules/**', 'dist/**', 'build/**', '.git/**', \n          '*.test.*', '*.spec.*', '**/test/**', '**/tests/**',\n          '**/*.min.js', '**/*.bundle.js', '**/coverage/**',\n          '**/.next/**', '**/.cache/**', '**/tmp/**', '**/temp/**'\n        ]\n      })\n      \n      // Extra filter to ensure no node_modules files get through\n      const filteredMatches = matches.filter(file => \n        !file.includes('node_modules') && \n        !file.includes('dist/') &&\n        !file.includes('.min.') &&\n        !file.includes('.bundle.')\n      )\n      \n      files.push(...filteredMatches)\n    }\n    \n    return [...new Set(files)] // Remove duplicates\n  }\n\n  /**\n   * Analyze all files using treesitter\n   */\n  async analyzeFiles(filePaths, projectPath) {\n    const analysis = {}\n    \n    for (const relativePath of filePaths) {\n      // Bulletproof check to skip node_modules\n      if (relativePath.includes('node_modules')) {\n        console.log(`Skipping node_modules file: ${relativePath}`);\n        continue;\n      }\n\n      const fullPath = join(projectPath, relativePath)\n      if (!existsSync(fullPath)) continue\n      \n      try {\n        const content = readFileSync(fullPath, 'utf8')\n        const fileAnalysis = await this.analyzeFile(fullPath, content)\n        fileAnalysis.path = relativePath // Store relative path\n        analysis[relativePath] = fileAnalysis\n      } catch (error) {\n        // Silently skip files that can't be parsed - they won't be included in semantic analysis\n        // This is normal for complex files or unsupported syntax patterns\n        analysis[relativePath] = { error: error.message, path: relativePath }\n      }\n    }\n    \n    return analysis\n  }\n\n  /**\n   * Analyze a single file using treesitter AST\n   */\n  async analyzeFile(filePath, content) {\n    const parser = this.getParser(filePath)\n    \n    // Skip files that are too large or have syntax errors\n    if (content.length > 500000) { // Skip files > 500KB\n      throw new Error('File too large')\n    }\n    \n    let tree, rootNode\n    try {\n      // Use simple string parsing (confirmed working in tests)\n      tree = parser.parse(content)\n      rootNode = tree.rootNode\n      \n      // Check for parse errors\n      if (rootNode.hasError) {\n        throw new Error('Parse error in file')\n      }\n    } catch (error) {\n      throw new Error(`Tree-sitter parse failed: ${error.message}`)\n    }\n    \n    const analysis = {\n      path: filePath,\n      fileName: basename(filePath),\n      dirName: basename(dirname(filePath)),\n      extension: extname(filePath),\n      size: content.length,\n      lines: content.split('\\n').length,\n      \n      // AST-based analysis\n      ast: {\n        functions: this.extractFunctions(rootNode, content),\n        classes: this.extractClasses(rootNode, content),\n        imports: this.extractImports(rootNode, content),\n        exports: this.extractExports(rootNode, content),\n        variables: this.extractVariables(rootNode, content),\n        jsxElements: this.extractJsxElements(rootNode, content),\n        typeDefinitions: this.extractTypeDefinitions(rootNode, content)\n      },\n      \n      // Semantic classification\n      semanticType: this.classifyFileSemantics(rootNode, content, filePath),\n      businessDomain: this.extractBusinessDomain(rootNode, content, filePath),\n      technicalPatterns: this.identifyTechnicalPatterns(rootNode, content),\n      \n      // Relationships\n      dependencies: this.analyzeDependencies(rootNode, content),\n      complexity: this.calculateAstComplexity(rootNode),\n      \n      // Metadata\n      codeSignature: this.generateCodeSignature(rootNode, content)\n    }\n    \n    // Generate semantic tags based on AST analysis\n    analysis.semanticTags = this.generateSemanticTags(analysis)\n    \n    return analysis\n  }\n\n  /**\n   * Extract function declarations from AST\n   */\n  extractFunctions(rootNode, content) {\n    const functions = []\n    \n    // Function declarations\n    const functionDeclarations = this.queryNode(rootNode, '(function_declaration name: (identifier) @name)')\n    functions.push(...functionDeclarations.map(capture => ({\n      name: this.getNodeText(capture.node, content),\n      type: 'function_declaration',\n      startPosition: capture.node.startPosition,\n      endPosition: capture.node.endPosition,\n      isExported: this.isNodeExported(capture.node)\n    })))\n    \n    // Arrow functions\n    const arrowFunctions = this.queryNode(rootNode, '(variable_declarator name: (identifier) @name value: (arrow_function))')\n    functions.push(...arrowFunctions.map(capture => ({\n      name: this.getNodeText(capture.node, content),\n      type: 'arrow_function',\n      startPosition: capture.node.startPosition,\n      endPosition: capture.node.endPosition,\n      isExported: this.isNodeExported(capture.node.parent.parent)\n    })))\n    \n    // Method definitions\n    const methods = this.queryNode(rootNode, '(method_definition name: (property_name) @name)')\n    functions.push(...methods.map(capture => ({\n      name: this.getNodeText(capture.node, content),\n      type: 'method',\n      startPosition: capture.node.startPosition,\n      endPosition: capture.node.endPosition,\n      isExported: false // methods are part of classes\n    })))\n    \n    return functions\n  }\n\n  /**\n   * Extract class declarations from AST\n   */\n  extractClasses(rootNode, content) {\n    const classes = []\n    \n    const classDeclarations = this.queryNode(rootNode, '(class_declaration name: (identifier) @name)')\n    classes.push(...classDeclarations.map(capture => ({\n      name: this.getNodeText(capture.node, content),\n      type: 'class',\n      startPosition: capture.node.startPosition,\n      endPosition: capture.node.endPosition,\n      isExported: this.isNodeExported(capture.node.parent),\n      methods: this.extractClassMethods(capture.node.parent, content)\n    })))\n    \n    return classes\n  }\n\n  /**\n   * Extract class methods\n   */\n  extractClassMethods(classNode, content) {\n    const methods = []\n    \n    try {\n      const methodNodes = this.queryNode(classNode, '(method_definition)')\n      methods.push(...methodNodes.map(capture => ({\n        name: this.getNodeText(capture.node, content),\n        type: 'method',\n        startPosition: capture.node.startPosition,\n        endPosition: capture.node.endPosition\n      })))\n    } catch (error) {\n      // Handle case where method extraction fails\n    }\n    \n    return methods\n  }\n\n  /**\n   * Extract import statements from AST\n   */\n  extractImports(rootNode, content) {\n    const imports = []\n    \n    const importStatements = this.queryNode(rootNode, '(import_statement source: (string) @source)')\n    imports.push(...importStatements.map(capture => {\n      const source = this.getNodeText(capture.node, content).replace(/['\"]/g, '')\n      return {\n        source,\n        statement: this.getNodeText(capture.node.parent, content),\n        isRelative: source.startsWith('.'),\n        isExternal: !source.startsWith('.') && !source.startsWith('/'),\n        importedNames: this.extractImportedNames(capture.node.parent, content)\n      }\n    }))\n    \n    return imports\n  }\n\n  /**\n   * Extract export statements from AST  \n   */\n  extractExports(rootNode, content) {\n    const exports = []\n    \n    // Export declarations\n    const exportDeclarations = this.queryNode(rootNode, '(export_statement)')\n    exports.push(...exportDeclarations.map(capture => {\n      const exportNode = capture.node\n      const declaration = exportNode.namedChild(0)\n      \n      if (declaration) {\n        return {\n          type: declaration.type === 'export_clause' ? 'named' : 'declaration',\n          name: this.extractExportName(declaration, content),\n          statement: this.getNodeText(exportNode, content),\n          isDefault: this.getNodeText(exportNode, content).includes('default')\n        }\n      }\n      return null\n    }).filter(Boolean))\n    \n    return exports\n  }\n\n  /**\n   * Extract variable declarations from AST\n   */\n  extractVariables(rootNode, content) {\n    const variables = []\n    \n    const variableDeclarations = this.queryNode(rootNode, '(variable_declarator name: (identifier) @name)')\n    variables.push(...variableDeclarations.map(capture => ({\n      name: this.getNodeText(capture.node, content),\n      type: 'variable',\n      startPosition: capture.node.startPosition,\n      endPosition: capture.node.endPosition,\n      isExported: this.isNodeExported(capture.node.parent.parent),\n      declarationType: capture.node.parent.parent.type // const, let, var\n    })))\n    \n    return variables\n  }\n\n  /**\n   * Extract JSX elements from AST (for React components)\n   */\n  extractJsxElements(rootNode, content) {\n    const jsxElements = []\n    \n    try {\n      const jsxNodes = this.queryNode(rootNode, '(jsx_element)')\n      jsxElements.push(...jsxNodes.map(capture => ({\n        elementName: this.extractJsxElementName(capture.node, content),\n        startPosition: capture.node.startPosition,\n        endPosition: capture.node.endPosition\n      })))\n    } catch (error) {\n      // JSX might not be available in JavaScript parser\n    }\n    \n    return jsxElements\n  }\n\n  /**\n   * Extract TypeScript type definitions from AST\n   */\n  extractTypeDefinitions(rootNode, content) {\n    const types = []\n    \n    try {\n      // Interface declarations\n      const interfaces = this.queryNode(rootNode, '(interface_declaration name: (type_identifier) @name)')\n      types.push(...interfaces.map(capture => ({\n        name: this.getNodeText(capture.node, content),\n        type: 'interface',\n        startPosition: capture.node.startPosition,\n        endPosition: capture.node.endPosition,\n        isExported: this.isNodeExported(capture.node.parent)\n      })))\n      \n      // Type alias declarations  \n      const typeAliases = this.queryNode(rootNode, '(type_alias_declaration name: (type_identifier) @name)')\n      types.push(...typeAliases.map(capture => ({\n        name: this.getNodeText(capture.node, content),\n        type: 'type_alias',\n        startPosition: capture.node.startPosition,\n        endPosition: capture.node.endPosition,\n        isExported: this.isNodeExported(capture.node.parent)\n      })))\n    } catch (error) {\n      // TypeScript types might not be available in JavaScript parser\n    }\n    \n    return types\n  }\n\n  /**\n   * Classify file semantics based on AST patterns\n   */\n  classifyFileSemantics(rootNode, content, filePath) {\n    const classifications = []\n    \n    // Test each semantic pattern\n    for (const [patternName, patternFn] of Object.entries(this.semanticPatterns)) {\n      if (patternFn(rootNode, content, filePath)) {\n        classifications.push(patternName)\n      }\n    }\n    \n    // Return primary classification (most specific first)\n    const priority = ['reactComponent', 'reactHook', 'expressRoute', 'expressMiddleware', \n                     'cliCommand', 'apiHandler', 'typeDefinition', 'configModule', 'utilityFunction']\n    \n    for (const pattern of priority) {\n      if (classifications.includes(pattern)) {\n        return pattern\n      }\n    }\n    \n    return 'module'\n  }\n\n  /**\n   * Semantic pattern: React Component\n   */\n  isReactComponent(rootNode, content, filePath) {\n    // Check for JSX elements\n    const hasJsx = this.queryNode(rootNode, '(jsx_element)').length > 0\n    \n    // Check for React imports\n    const hasReactImport = content.includes(\"import React\") || content.includes(\"from 'react'\")\n    \n    // Check for component naming pattern\n    const fileName = basename(filePath, extname(filePath))\n    const hasComponentName = fileName[0] === fileName[0].toUpperCase()\n    \n    // Check for function that returns JSX\n    const functions = this.extractFunctions(rootNode, content)\n    const hasComponentFunction = functions.some(fn => \n      fn.isExported && fn.name[0] === fn.name[0].toUpperCase()\n    )\n    \n    return (hasJsx && (hasReactImport || hasComponentName)) || \n           (hasComponentFunction && hasReactImport)\n  }\n\n  /**\n   * Semantic pattern: React Hook\n   */\n  isReactHook(rootNode, content, filePath) {\n    const fileName = basename(filePath, extname(filePath))\n    const hasHookName = fileName.startsWith('use') && fileName[3] === fileName[3].toUpperCase()\n    \n    const functions = this.extractFunctions(rootNode, content)\n    const hasHookFunction = functions.some(fn => \n      fn.name.startsWith('use') && fn.name[3] === fn.name[3].toUpperCase() && fn.isExported\n    )\n    \n    const hasReactHookImports = content.includes(\"from 'react'\") && \n                                (content.includes('useState') || content.includes('useEffect'))\n    \n    return hasHookName || (hasHookFunction && hasReactHookImports)\n  }\n\n  /**\n   * Semantic pattern: Express Route\n   */\n  isExpressRoute(rootNode, content, filePath) {\n    const hasExpressImport = content.includes(\"from 'express'\") || content.includes(\"require('express')\")\n    const hasRouterMethods = /\\.(get|post|put|delete|patch)\\s*\\(/.test(content)\n    const hasRoutePattern = /['\"`]\\/[^'\"`]*['\"`]/.test(content)\n    \n    return hasExpressImport && hasRouterMethods && hasRoutePattern\n  }\n\n  /**\n   * Semantic pattern: Express Middleware\n   */\n  isExpressMiddleware(rootNode, content, filePath) {\n    const hasMiddlewarePattern = /\\(req,\\s*res,\\s*next\\)|function\\s*\\([^)]*req[^)]*res[^)]*next/.test(content)\n    const hasExpressImport = content.includes(\"from 'express'\") || content.includes(\"require('express')\")\n    const fileName = basename(filePath).toLowerCase()\n    \n    return (hasMiddlewarePattern && hasExpressImport) || fileName.includes('middleware')\n  }\n\n  /**\n   * Semantic pattern: CLI Command\n   */\n  isCliCommand(rootNode, content, filePath) {\n    const hasCommanderImport = content.includes('commander') || content.includes('yargs')\n    const hasProcessArgv = content.includes('process.argv')\n    const hasCliPatterns = content.includes('.command(') || content.includes('.option(')\n    const fileName = basename(filePath).toLowerCase()\n    \n    return hasCommanderImport || (hasProcessArgv && hasCliPatterns) || fileName.includes('cli')\n  }\n\n  /**\n   * Semantic pattern: Utility Function\n   */\n  isUtilityFunction(rootNode, content, filePath) {\n    const functions = this.extractFunctions(rootNode, content)\n    const hasMultipleExportedFunctions = functions.filter(fn => fn.isExported).length > 1\n    \n    const fileName = basename(filePath).toLowerCase()\n    const hasUtilityName = fileName.includes('util') || fileName.includes('helper') || fileName.includes('lib')\n    \n    const hasNoDomSpecificImports = !content.includes('react') && !content.includes('express')\n    \n    return hasUtilityName || (hasMultipleExportedFunctions && hasNoDomSpecificImports)\n  }\n\n  /**\n   * Semantic pattern: API Handler\n   */\n  isApiHandler(rootNode, content, filePath) {\n    const hasApiPattern = /api|handler|controller/i.test(filePath)\n    const hasFetchPattern = content.includes('fetch(') || content.includes('axios')\n    const hasHttpMethods = /\\b(GET|POST|PUT|DELETE|PATCH)\\b/.test(content)\n    \n    return hasApiPattern || (hasFetchPattern && hasHttpMethods)\n  }\n\n  /**\n   * Semantic pattern: Type Definition\n   */\n  isTypeDefinition(rootNode, content, filePath) {\n    const types = this.extractTypeDefinitions(rootNode, content)\n    const hasTypeDefinitions = types.length > 0\n    \n    const fileName = basename(filePath).toLowerCase()\n    const hasTypeFileName = fileName.includes('type') || fileName.includes('.d.ts')\n    \n    const hasOnlyTypes = hasTypeDefinitions && \n                        this.extractFunctions(rootNode, content).length === 0 &&\n                        this.extractClasses(rootNode, content).length === 0\n    \n    return hasTypeFileName || hasOnlyTypes\n  }\n\n  /**\n   * Semantic pattern: Config Module\n   */\n  isConfigModule(rootNode, content, filePath) {\n    const fileName = basename(filePath).toLowerCase()\n    const hasConfigName = fileName.includes('config') || fileName.includes('setting')\n    \n    const hasConfigPatterns = content.includes('module.exports') || content.includes('export default')\n    const hasConfigObject = /\\{[\\s\\S]*\\}/.test(content) && !/function|class/.test(content)\n    \n    return hasConfigName && (hasConfigPatterns || hasConfigObject)\n  }\n\n  /**\n   * Extract business domain terms from code\n   */\n  extractBusinessDomain(rootNode, content, filePath) {\n    const domains = []\n    \n    // Focus on meaningful path segments instead of generic business terms\n    const pathSegments = filePath.split('/').filter(s => s && s !== 'src' && s !== 'lib' && s !== 'components')\n    const fileName = basename(filePath, extname(filePath))\n    \n    // Extract domain from directory structure (more reliable than keywords)\n    if (pathSegments.length > 0) {\n      const relevantSegments = pathSegments.slice(-2) // Last 2 directories\n      domains.push(...relevantSegments.map(s => s.toLowerCase()))\n    }\n    \n    // Add meaningful file-based domains\n    if (fileName.toLowerCase().includes('config')) domains.push('configuration')\n    if (fileName.toLowerCase().includes('test')) domains.push('testing')\n    if (fileName.toLowerCase().includes('util')) domains.push('utilities')\n    if (fileName.toLowerCase().includes('api')) domains.push('api')\n    if (fileName.toLowerCase().includes('ui') || fileName.toLowerCase().includes('component')) {\n      domains.push('user-interface')\n    }\n    \n    // Only return meaningful, non-generic domains\n    return [...new Set(domains)].filter(domain => \n      domain.length > 2 && !['web', 'src', 'ts', 'js', 'tsx', 'jsx'].includes(domain)\n    )\n  }\n\n  /**\n   * Identify technical patterns in the code\n   */\n  identifyTechnicalPatterns(rootNode, content) {\n    const patterns = []\n    \n    // Framework patterns\n    if (content.includes('react')) patterns.push('react')\n    if (content.includes('express')) patterns.push('express')\n    if (content.includes('typescript')) patterns.push('typescript')\n    \n    // Architecture patterns\n    if (content.includes('async') && content.includes('await')) patterns.push('async-await')\n    if (content.includes('Promise')) patterns.push('promises')\n    if (content.includes('class') && content.includes('extends')) patterns.push('inheritance')\n    \n    // Design patterns\n    const functions = this.extractFunctions(rootNode, content)\n    if (functions.some(f => f.name.includes('Factory'))) patterns.push('factory-pattern')\n    if (functions.some(f => f.name.includes('Observer'))) patterns.push('observer-pattern')\n    \n    return patterns\n  }\n\n  /**\n   * Build relationship graph between files\n   */\n  buildRelationshipGraph(analysis) {\n    const graph = {}\n    \n    for (const [filePath, fileAnalysis] of Object.entries(analysis)) {\n      if (fileAnalysis.error) continue\n      \n      graph[filePath] = {\n        imports: [],\n        importedBy: [],\n        semanticSimilarity: {},\n        businessDomainOverlap: {},\n        technicalPatternOverlap: {}\n      }\n    }\n    \n    // Build import relationships\n    for (const [filePath, fileAnalysis] of Object.entries(analysis)) {\n      if (fileAnalysis.error) continue\n      \n      for (const imp of fileAnalysis.ast.imports) {\n        if (imp.isRelative) {\n          // Resolve relative import to actual file path\n          const importPath = this.resolveImportPath(filePath, imp.source)\n          if (graph[importPath]) {\n            graph[filePath].imports.push(importPath)\n            graph[importPath].importedBy.push(filePath)\n          }\n        }\n      }\n    }\n    \n    // Calculate semantic similarities\n    for (const [fileA, analysisA] of Object.entries(analysis)) {\n      if (analysisA.error) continue\n      \n      for (const [fileB, analysisB] of Object.entries(analysis)) {\n        if (analysisB.error || fileA === fileB) continue\n        \n        // Semantic type similarity\n        const semanticSimilarity = analysisA.semanticType === analysisB.semanticType ? 1.0 : 0.0\n        \n        // Business domain overlap\n        const domainOverlap = this.calculateOverlap(analysisA.businessDomain, analysisB.businessDomain)\n        \n        // Technical pattern overlap\n        const patternOverlap = this.calculateOverlap(analysisA.technicalPatterns, analysisB.technicalPatterns)\n        \n        if (semanticSimilarity > 0 || domainOverlap > 0 || patternOverlap > 0) {\n          graph[fileA].semanticSimilarity[fileB] = semanticSimilarity\n          graph[fileA].businessDomainOverlap[fileB] = domainOverlap\n          graph[fileA].technicalPatternOverlap[fileB] = patternOverlap\n        }\n      }\n    }\n    \n    return graph\n  }\n\n  /**\n   * Create smart chunks using clustering algorithms\n   */\n  async createSmartChunks(analysis, relationshipGraph) {\n    \n    // Start with individual files as nodes\n    const nodes = Object.keys(analysis).filter(path => !analysis[path].error)\n    console.log(`🧩 Starting with ${nodes.length} nodes for clustering`)\n    \n    // Apply different clustering strategies\n    const strategies = [\n      this.clusterBySemanticType.bind(this),\n      this.clusterByBusinessDomain.bind(this),\n      this.clusterByDependencyGraph.bind(this),\n      this.clusterByDirectoryStructure.bind(this)\n    ]\n    \n    let clusters = nodes.map(node => [node]) // Start with individual nodes\n    \n    // Apply clustering strategies\n    for (const strategy of strategies) {\n      clusters = strategy(clusters, analysis, relationshipGraph)\n      console.log(`📦 After ${strategy.name}: ${clusters.length} clusters`)\n    }\n    \n    // Convert clusters to named chunks\n    const chunks = []\n    const usedNames = new Set()\n    \n    for (const cluster of clusters) {\n      if (cluster.length === 0) continue\n      \n      let chunkName = await this.generateChunkName(cluster, analysis)\n      \n      // Ensure unique names\n      let uniqueName = chunkName\n      let counter = 1\n      while (usedNames.has(uniqueName)) {\n        uniqueName = `${chunkName}-${counter}`\n        counter++\n      }\n      usedNames.add(uniqueName)\n      \n      const chunk = {\n        name: uniqueName,\n        type: this.determineChunkType(cluster, analysis),\n        files: cluster,\n        size: cluster.reduce((sum, file) => sum + analysis[file].size, 0),\n        complexity: this.calculateClusterComplexity(cluster, analysis),\n        dependencies: this.calculateClusterDependencies(cluster, analysis),\n        businessDomains: this.extractClusterBusinessDomains(cluster, analysis),\n        technicalPatterns: this.extractClusterTechnicalPatterns(cluster, analysis),\n        purpose: this.determineClusterPurpose(cluster, analysis),\n        cohesion: this.calculateClusterCohesion(cluster, relationshipGraph),\n        recommendations: this.generateClusterRecommendations(cluster, analysis),\n        tags: this.generateTags(cluster, analysis)\n      }\n      \n      chunks.push(chunk)\n    }\n    \n    return chunks.sort((a, b) => b.cohesion - a.cohesion) // Sort by cohesion (best chunks first)\n  }\n\n  /**\n   * Cluster files by semantic type\n   */\n  clusterBySemanticType(clusters, analysis, relationshipGraph) {\n    const semanticGroups = {}\n    \n    for (const cluster of clusters) {\n      for (const file of cluster) {\n        const semanticType = analysis[file].semanticType\n        if (!semanticGroups[semanticType]) {\n          semanticGroups[semanticType] = []\n        }\n        semanticGroups[semanticType].push(file)\n      }\n    }\n    \n    return Object.values(semanticGroups).filter(group => group.length > 0)\n  }\n\n  /**\n   * Cluster files by business domain\n   */\n  clusterByBusinessDomain(clusters, analysis, relationshipGraph) {\n    const domainGroups = {}\n    \n    for (const cluster of clusters) {\n      for (const file of cluster) {\n        const domains = analysis[file].businessDomain\n        \n        if (domains.length === 0) {\n          // Files with no clear domain go to 'general' group\n          if (!domainGroups.general) domainGroups.general = []\n          domainGroups.general.push(file)\n        } else {\n          // Files go to their primary domain group\n          const primaryDomain = domains[0]\n          if (!domainGroups[primaryDomain]) domainGroups[primaryDomain] = []\n          domainGroups[primaryDomain].push(file)\n        }\n      }\n    }\n    \n    return Object.values(domainGroups).filter(group => group.length > 0)\n  }\n\n  /**\n   * Cluster files by dependency relationships\n   */\n  clusterByDependencyGraph(clusters, analysis, relationshipGraph) {\n    const dependencyGroups = []\n    const visited = new Set()\n    \n    for (const cluster of clusters) {\n      for (const file of cluster) {\n        if (visited.has(file)) continue\n        \n        // Find all files connected to this file through imports\n        const connected = this.findConnectedFiles(file, relationshipGraph, new Set())\n        \n        // Filter to only files in current clusters\n        const relevantConnected = connected.filter(f => \n          clusters.some(cluster => cluster.includes(f))\n        )\n        \n        if (relevantConnected.length > 1) {\n          dependencyGroups.push(relevantConnected)\n          relevantConnected.forEach(f => visited.add(f))\n        } else {\n          // Isolated file becomes its own group\n          dependencyGroups.push([file])\n          visited.add(file)\n        }\n      }\n    }\n    \n    return dependencyGroups.filter(group => group.length > 0)\n  }\n\n  /**\n   * Cluster files by directory structure\n   */\n  clusterByDirectoryStructure(clusters, analysis, relationshipGraph) {\n    const directoryGroups = {}\n    \n    for (const cluster of clusters) {\n      for (const file of cluster) {\n        const dir = dirname(file)\n        if (!directoryGroups[dir]) {\n          directoryGroups[dir] = []\n        }\n        directoryGroups[dir].push(file)\n      }\n    }\n    \n    return Object.values(directoryGroups).filter(group => group.length > 0)\n  }\n\n  /**\n   * Generate intelligent chunk name\n   */\n  async generateChunkName(files, analysis) {\n    const namingStrategies = {\n      domainBased: this.generateDomainBasedName.bind(this),\n      patternBased: this.generatePatternBasedName.bind(this),\n      functionalityBased: this.generateFunctionalityBasedName.bind(this)\n    }\n    \n    const names = {}\n    \n    for (const [strategy, generator] of Object.entries(namingStrategies)) {\n      try {\n        names[strategy] = generator(files, analysis)\n      } catch (error) {\n        names[strategy] = 'unnamed-chunk'\n      }\n    }\n    \n    // Choose best name based on strategy preference - prefer pattern-based for better names\n    const strategy = 'patternBased' // Force pattern-based naming\n    return names[strategy] || names.patternBased || names.functionalityBased || names.domainBased || 'unknown-chunk'\n  }\n\n  /**\n   * Generate domain-based chunk name\n   */\n  generateDomainBasedName(files, analysis) {\n    // Always fallback to pattern-based naming since domain extraction is unreliable\n    return this.generatePatternBasedName(files, analysis)\n  }\n\n  /**\n   * Generate pattern-based chunk name\n   */\n  generatePatternBasedName(files, analysis) {\n    const semanticTypes = files.map(file => analysis[file].semanticType)\n    const mostCommon = this.getMostCommon(semanticTypes)\n    \n    // Look at actual file names and directories for context\n    const commonPath = this.findCommonPath(files)\n    const dirName = commonPath ? basename(dirname(commonPath)) : null\n    \n    const typeNames = {\n      reactComponent: 'ui-components',\n      reactHook: 'react-hooks', \n      expressRoute: 'server-routes',\n      expressMiddleware: 'server-middleware',\n      utilityFunction: 'utility-functions',\n      typeDefinition: 'type-definitions',\n      configModule: 'configuration',\n      cliCommand: 'cli-tools',\n      apiHandler: 'api-endpoints',\n      module: 'shared-modules'\n    }\n    \n    let baseName = typeNames[mostCommon] || 'mixed-files'\n    \n    // Add more specific context based on file paths\n    if (commonPath) {\n      if (commonPath.includes('/components/ui/')) {\n        baseName = 'ui-library-components'\n      } else if (commonPath.includes('/components/')) {\n        baseName = 'application-components'\n      } else if (commonPath.includes('/hooks/')) {\n        baseName = 'custom-hooks'\n      } else if (commonPath.includes('/lib/')) {\n        baseName = 'core-utilities'\n      } else if (commonPath.includes('/utils/')) {\n        baseName = 'helper-utilities'\n      } else if (dirName && dirName !== 'src' && dirName !== 'components' && dirName !== 'lib') {\n        baseName = `${dirName}-${baseName}`\n      }\n    }\n    \n    return baseName\n  }\n\n  /**\n   * Generate functionality-based chunk name\n   */\n  generateFunctionalityBasedName(files, analysis) {\n    // Extract function names and find common themes\n    const allFunctions = files.flatMap(file => \n      analysis[file].ast.functions.map(fn => fn.name.toLowerCase())\n    )\n    \n    const commonWords = this.extractCommonWords(allFunctions)\n    \n    if (commonWords.length > 0) {\n      return commonWords.slice(0, 2).join('-') + '-logic'\n    }\n    \n    // Fallback to directory-based naming\n    const dirs = files.map(file => basename(dirname(file)))\n    const commonDir = this.getMostCommon(dirs)\n    \n    return commonDir + '-module'\n  }\n\n  /**\n   * Helper methods for AST analysis\n   */\n\n  queryNode(node, query) {\n    // Simplified query implementation\n    // In a full implementation, you'd use tree-sitter's query language\n    const results = []\n    \n    const traverse = (currentNode) => {\n      // Match based on node type for now\n      if (query.includes(currentNode.type)) {\n        results.push({ node: currentNode })\n      }\n      \n      for (let i = 0; i < currentNode.namedChildCount; i++) {\n        traverse(currentNode.namedChild(i))\n      }\n    }\n    \n    traverse(node)\n    return results\n  }\n\n  getNodeText(node, content) {\n    return content.slice(node.startIndex, node.endIndex)\n  }\n\n  isNodeExported(node) {\n    // Check if node is part of an export statement\n    let parent = node.parent\n    while (parent) {\n      if (parent.type === 'export_statement') {\n        return true\n      }\n      parent = parent.parent\n    }\n    return false\n  }\n\n  calculateOverlap(arrayA, arrayB) {\n    const setA = new Set(arrayA)\n    const setB = new Set(arrayB)\n    const intersection = new Set([...setA].filter(x => setB.has(x)))\n    const union = new Set([...setA, ...setB])\n    \n    return union.size === 0 ? 0 : intersection.size / union.size\n  }\n\n  getMostCommon(arr) {\n    const counts = {}\n    for (const item of arr) {\n      counts[item] = (counts[item] || 0) + 1\n    }\n    \n    return Object.entries(counts)\n      .sort(([,a], [,b]) => b - a)[0]?.[0] || 'unknown'\n  }\n\n  generateSemanticTags(analysis) {\n    const tags = []\n    \n    tags.push(analysis.semanticType)\n    tags.push(...analysis.businessDomain)\n    tags.push(...analysis.technicalPatterns)\n    \n    if (analysis.complexity.level) {\n      tags.push(`complexity-${analysis.complexity.level}`)\n    }\n    \n    if (analysis.lines < 50) tags.push('small')\n    else if (analysis.lines < 200) tags.push('medium')  \n    else tags.push('large')\n    \n    return [...new Set(tags)]\n  }\n\n  calculateAstComplexity(rootNode) {\n    let complexity = 1\n    \n    const complexityNodes = ['if_statement', 'while_statement', 'for_statement', \n                            'switch_statement', 'try_statement', 'catch_clause']\n    \n    const traverse = (node) => {\n      if (complexityNodes.includes(node.type)) {\n        complexity++\n      }\n      \n      for (let i = 0; i < node.namedChildCount; i++) {\n        traverse(node.namedChild(i))\n      }\n    }\n    \n    traverse(rootNode)\n    \n    return {\n      score: complexity,\n      level: complexity < 5 ? 'low' : complexity < 15 ? 'medium' : 'high'\n    }\n  }\n\n  /**\n   * Analyze dependencies from AST\n   */\n  analyzeDependencies(rootNode, content) {\n    const dependencies = {\n      internal: [],\n      external: [],\n      relative: []\n    }\n    \n    const imports = this.extractImports(rootNode, content)\n    \n    for (const imp of imports) {\n      if (imp.isRelative) {\n        dependencies.relative.push(imp.source)\n      } else if (imp.isExternal) {\n        dependencies.external.push(imp.source)\n      } else {\n        dependencies.internal.push(imp.source)\n      }\n    }\n    \n    return dependencies\n  }\n\n  /**\n   * Resolve relative import path to absolute path\n   */\n  resolveImportPath(fromFile, importPath) {\n    // Simplified path resolution\n    const dir = dirname(fromFile)\n    return join(dir, importPath)\n  }\n\n  /**\n   * Find all files connected through imports\n   */\n  findConnectedFiles(startFile, relationshipGraph, visited = new Set()) {\n    if (visited.has(startFile)) return []\n    \n    visited.add(startFile)\n    const connected = [startFile]\n    \n    if (relationshipGraph[startFile]) {\n      // Follow imports\n      for (const importedFile of relationshipGraph[startFile].imports) {\n        connected.push(...this.findConnectedFiles(importedFile, relationshipGraph, visited))\n      }\n      \n      // Follow files that import this one\n      for (const importingFile of relationshipGraph[startFile].importedBy) {\n        connected.push(...this.findConnectedFiles(importingFile, relationshipGraph, visited))\n      }\n    }\n    \n    return [...new Set(connected)]\n  }\n\n  /**\n   * Extract imported names from import statement\n   */\n  extractImportedNames(importNode, content) {\n    const names = []\n    // Simplified implementation - would need more complex parsing\n    const importText = this.getNodeText(importNode, content)\n    const match = importText.match(/import\\s+(?:\\{([^}]+)\\}|(\\w+))/i)\n    if (match) {\n      if (match[1]) {\n        // Named imports\n        names.push(...match[1].split(',').map(n => n.trim()))\n      } else if (match[2]) {\n        // Default import\n        names.push(match[2])\n      }\n    }\n    return names\n  }\n\n  /**\n   * Extract export name from export declaration\n   */\n  extractExportName(declaration, content) {\n    const text = this.getNodeText(declaration, content)\n    const match = text.match(/(?:function|class|const|let|var)\\s+(\\w+)/)\n    return match ? match[1] : 'unnamed'\n  }\n\n  /**\n   * Extract JSX element name\n   */\n  extractJsxElementName(jsxNode, content) {\n    try {\n      const openingElement = jsxNode.namedChild(0)\n      if (openingElement) {\n        const nameNode = openingElement.namedChild(0)\n        return nameNode ? this.getNodeText(nameNode, content) : 'unknown'\n      }\n    } catch (error) {\n      return 'unknown'\n    }\n    return 'unknown'\n  }\n\n  /**\n   * Determine chunk type based on files\n   */\n  determineChunkType(files, analysis) {\n    const semanticTypes = files.map(file => analysis[file].semanticType)\n    const mostCommon = this.getMostCommon(semanticTypes)\n    \n    const typeMapping = {\n      reactComponent: 'ui-components',\n      reactHook: 'custom-hooks',\n      expressRoute: 'api-routes',\n      expressMiddleware: 'middleware',\n      utilityFunction: 'utilities',\n      typeDefinition: 'type-definitions',\n      configModule: 'configuration',\n      cliCommand: 'cli-commands',\n      apiHandler: 'api-handlers'\n    }\n    \n    return typeMapping[mostCommon] || 'mixed-module'\n  }\n\n  /**\n   * Calculate cluster complexity\n   */\n  calculateClusterComplexity(files, analysis) {\n    const complexities = files.map(file => analysis[file].complexity.score)\n    const total = complexities.reduce((sum, c) => sum + c, 0)\n    const average = total / files.length\n    \n    return {\n      total,\n      average,\n      level: average < 5 ? 'low' : average < 15 ? 'medium' : 'high'\n    }\n  }\n\n  /**\n   * Calculate cluster dependencies\n   */\n  calculateClusterDependencies(files, analysis) {\n    const allDeps = {\n      internal: new Set(),\n      external: new Set(),\n      relative: new Set()\n    }\n    \n    for (const file of files) {\n      const deps = analysis[file].dependencies\n      deps.internal.forEach(dep => allDeps.internal.add(dep))\n      deps.external.forEach(dep => allDeps.external.add(dep))\n      deps.relative.forEach(dep => allDeps.relative.add(dep))\n    }\n    \n    return {\n      internal: Array.from(allDeps.internal),\n      external: Array.from(allDeps.external),\n      relative: Array.from(allDeps.relative),\n      totalCount: allDeps.internal.size + allDeps.external.size + allDeps.relative.size\n    }\n  }\n\n  /**\n   * Extract cluster business domains\n   */\n  extractClusterBusinessDomains(files, analysis) {\n    const allDomains = files.flatMap(file => analysis[file].businessDomain)\n    return [...new Set(allDomains)]\n  }\n\n  /**\n   * Extract cluster technical patterns\n   */\n  extractClusterTechnicalPatterns(files, analysis) {\n    const allPatterns = files.flatMap(file => analysis[file].technicalPatterns)\n    return [...new Set(allPatterns)]\n  }\n\n  /**\n   * Determine cluster purpose\n   */\n  determineClusterPurpose(files, analysis) {\n    const semanticTypes = files.map(file => analysis[file].semanticType)\n    const mostCommon = this.getMostCommon(semanticTypes)\n    \n    const purposeMapping = {\n      reactComponent: 'User interface components and React elements',\n      reactHook: 'Custom React hooks for state and logic sharing',\n      expressRoute: 'API routes and endpoint handlers',\n      expressMiddleware: 'Express middleware and request processing',\n      utilityFunction: 'Utility functions and helper libraries',\n      typeDefinition: 'TypeScript type definitions and interfaces',\n      configModule: 'Configuration files and settings',\n      cliCommand: 'Command-line interface and CLI tools',\n      apiHandler: 'API client and data fetching logic'\n    }\n    \n    return purposeMapping[mostCommon] || 'Mixed functionality module'\n  }\n\n  /**\n   * Calculate cluster cohesion\n   */\n  calculateClusterCohesion(files, relationshipGraph) {\n    if (files.length <= 1) return 1.0\n    \n    let connections = 0\n    let totalPossible = files.length * (files.length - 1)\n    \n    for (const fileA of files) {\n      for (const fileB of files) {\n        if (fileA !== fileB && relationshipGraph[fileA]) {\n          if (relationshipGraph[fileA].imports.includes(fileB) ||\n              relationshipGraph[fileA].importedBy.includes(fileB) ||\n              relationshipGraph[fileA].semanticSimilarity[fileB] > 0.5) {\n            connections++\n          }\n        }\n      }\n    }\n    \n    return totalPossible > 0 ? connections / totalPossible : 0\n  }\n\n  /**\n   * Generate cluster recommendations\n   */\n  generateClusterRecommendations(files, analysis) {\n    const recommendations = []\n    \n    const totalSize = files.reduce((sum, file) => sum + analysis[file].size, 0)\n    const avgComplexity = files.reduce((sum, file) => sum + analysis[file].complexity.score, 0) / files.length\n    \n    if (totalSize > 100000) {\n      recommendations.push({\n        type: 'warning',\n        message: 'Large cluster - consider splitting by functionality'\n      })\n    }\n    \n    if (avgComplexity > 20) {\n      recommendations.push({\n        type: 'warning', \n        message: 'High complexity cluster - review for refactoring opportunities'\n      })\n    }\n    \n    if (files.length === 1) {\n      recommendations.push({\n        type: 'info',\n        message: 'Single file cluster - consider grouping with related files'\n      })\n    }\n    \n    return recommendations\n  }\n\n  /**\n   * Extract common words from function names\n   */\n  extractCommonWords(functionNames) {\n    const words = functionNames.flatMap(name => \n      name.split(/(?=[A-Z])|_|-/).filter(word => word.length > 2)\n    )\n    \n    const wordCounts = {}\n    for (const word of words) {\n      wordCounts[word] = (wordCounts[word] || 0) + 1\n    }\n    \n    return Object.entries(wordCounts)\n      .filter(([, count]) => count > 1)\n      .sort(([, a], [, b]) => b - a)\n      .slice(0, 3)\n      .map(([word]) => word)\n  }\n\n  /**\n   * Generate code signature for caching and similarity comparison\n   */\n  generateCodeSignature(rootNode, content) {\n    const functions = this.extractFunctions(rootNode, content)\n    const classes = this.extractClasses(rootNode, content)\n    const imports = this.extractImports(rootNode, content)\n    const exports = this.extractExports(rootNode, content)\n    \n    return {\n      functionCount: functions.length,\n      classCount: classes.length,\n      importCount: imports.length,\n      exportCount: exports.length,\n      exportedFunctions: functions.filter(f => f.isExported).map(f => f.name),\n      importSources: imports.map(i => i.source),\n      hasJsx: this.extractJsxElements(rootNode, content).length > 0,\n      contentHash: this.simpleHash(content)\n    }\n  }\n\n  /**\n   * Simple hash function for content comparison\n   */\n  simpleHash(str) {\n    let hash = 0\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i)\n      hash = ((hash << 5) - hash) + char\n      hash = hash & hash // Convert to 32bit integer\n    }\n    return hash\n  }\n  \n  generateSummary(analysis, chunks) {\n    const files = Object.values(analysis).filter(f => !f.error)\n    \n    return {\n      totalFiles: files.length,\n      totalSize: files.reduce((sum, f) => sum + f.size, 0),\n      totalLines: files.reduce((sum, f) => sum + f.lines, 0),\n      semanticTypes: this.countByProperty(files, 'semanticType'),\n      businessDomains: this.countDomains(files),\n      technicalPatterns: this.countPatterns(files),\n      totalChunks: chunks.length,\n      averageChunkSize: chunks.reduce((sum, c) => sum + c.size, 0) / chunks.length,\n      chunkTypes: this.countByProperty(chunks, 'type')\n    }\n  }\n\n  generateRecommendations(analysis, chunks) {\n    const recommendations = []\n    \n    // Add specific recommendations based on treesitter analysis\n    \n    return recommendations\n  }\n\n  countByProperty(items, property) {\n    const counts = {}\n    for (const item of items) {\n      const value = typeof property === 'function' ? property(item) : item[property]\n      counts[value] = (counts[value] || 0) + 1\n    }\n    return counts\n  }\n\n  countDomains(files) {\n    const allDomains = files.flatMap(f => f.businessDomain)\n    return this.countByProperty(allDomains, d => d)\n  }\n\n  countPatterns(files) {\n    const allPatterns = files.flatMap(f => f.technicalPatterns)\n    return this.countByProperty(allPatterns, p => p)\n  }\n\n  /**\n   * Generate tags for a chunk based on its characteristics\n   */\n  generateTags(files, analysis) {\n    const tags = new Set()\n    \n    // Add semantic type tags\n    const semanticTypes = files.map(file => analysis[file].semanticType)\n    for (const type of semanticTypes) {\n      if (type === 'reactComponent') tags.add('react-component')\n      if (type === 'reactHook') tags.add('react-hook')\n      if (type === 'utilityFunction') tags.add('utility')\n      if (type === 'expressRoute') tags.add('api')\n      if (type === 'configModule') tags.add('config')\n    }\n    \n    // Add directory-based tags\n    const commonPath = this.findCommonPath(files)\n    if (commonPath) {\n      if (commonPath.includes('/components/')) tags.add('component')\n      if (commonPath.includes('/hooks/')) tags.add('hook')\n      if (commonPath.includes('/lib/')) tags.add('library')\n      if (commonPath.includes('/utils/')) tags.add('utility')\n      if (commonPath.includes('/ui/')) tags.add('ui-library')\n    }\n    \n    // Add complexity tags\n    const avgComplexity = files.reduce((sum, file) => sum + analysis[file].complexity.score, 0) / files.length\n    if (avgComplexity > 15) tags.add('complex')\n    if (avgComplexity < 5) tags.add('simple')\n    \n    return Array.from(tags)\n  }\n\n  /**\n   * Find common path prefix for a group of files\n   */\n  findCommonPath(files) {\n    if (files.length === 0) return null\n    if (files.length === 1) return files[0]\n    \n    const pathParts = files.map(file => file.split('/'))\n    const commonParts = []\n    \n    for (let i = 0; i < Math.min(...pathParts.map(p => p.length)); i++) {\n      const part = pathParts[0][i]\n      if (pathParts.every(p => p[i] === part)) {\n        commonParts.push(part)\n      } else {\n        break\n      }\n    }\n    \n    return commonParts.length > 0 ? commonParts.join('/') : null\n  }\n}\n\nexport default TreesitterSemanticChunker]]></cntx:content>\n      </cntx:file>\n    </cntx:group>\n  </cntx:files>\n</cntx:bundle>",
    "lastGenerated": "2025-06-26T23:00:14.433Z",
    "size": 191719
  },
  "frontend": {
    "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<cntx:bundle xmlns:cntx=\"https://cntx.dev/schema\" name=\"frontend\" generated=\"2025-06-26T23:06:23.728Z\">\n  <cntx:project>\n    <cntx:name>cntx-ui</cntx:name>\n    <cntx:version>2.0.12</cntx:version>\n    <cntx:description>File context management tool with web UI and MCP server for AI development workflows - bundle project files for LLM consumption</cntx:description>\n  </cntx:project>\n  <cntx:overview>\n    <cntx:purpose>User interface components, pages, and client-side logic</cntx:purpose>\n    <cntx:file-types>\n      <cntx:type name=\"components\" count=\"28\" />\n      <cntx:type name=\"hooks\" count=\"2\" />\n      <cntx:type name=\"utilities\" count=\"2\" />\n      <cntx:type name=\"styles\" count=\"2\" />\n      <cntx:type name=\"other\" count=\"2\" />\n    </cntx:file-types>\n    <cntx:entry-points>\n      <cntx:file>web/index.html</cntx:file>\n      <cntx:file>web/src/App.css</cntx:file>\n      <cntx:file>web/src/App.tsx</cntx:file>\n      <cntx:file>web/src/index.css</cntx:file>\n      <cntx:file>web/src/main.tsx</cntx:file>\n    </cntx:entry-points>\n  </cntx:overview>\n  <cntx:files count=\"36\">\n    <cntx:group type=\"entry-points\" description=\"Main entry files for this bundle\">\n      <cntx:file path=\"web/index.html\" ext=\".html\" role=\"entry-point\">\n        <cntx:meta size=\"629\" modified=\"2025-06-19T17:10:17.425Z\" lines=\"17\" />\n        <cntx:content><![CDATA[<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/vite.svg\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>cntx-ui</title>\n    <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n    <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n    <link href=\"https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap\" rel=\"stylesheet\">\n  </head>\n  <body>\n    <div id=\"root\"></div>\n    <script type=\"module\" src=\"/src/main.tsx\"></script>\n  </body>\n</html>\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/App.css\" ext=\".css\" role=\"main-component\">\n        <cntx:meta size=\"652\" modified=\"2025-06-25T06:22:37.442Z\" lines=\"43\" />\n        <cntx:content><![CDATA[#root {\n  max-width: 1280px;\n  margin: 0 auto;\n  padding: 2rem;\n  text-align: center;\n}\n\n.logo {\n  height: 6em;\n  padding: 1.5em;\n  will-change: filter;\n  transition: filter 300ms;\n}\n.logo:hover {\n  filter: drop-shadow(0 0 2em var(--color-primary));\n}\n.logo.react:hover {\n  filter: drop-shadow(0 0 2em var(--color-accent));\n}\n\n@keyframes logo-spin {\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n}\n\n@media (prefers-reduced-motion: no-preference) {\n  a:nth-of-type(2) .logo {\n    animation: logo-spin infinite 20s linear;\n  }\n}\n\n.card {\n  padding: 2em;\n}\n\n.read-the-docs {\n  color: var(--color-muted-foreground);\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/App.tsx\" ext=\".tsx\" role=\"main-component\">\n        <cntx:meta size=\"9520\" modified=\"2025-06-26T01:00:24.620Z\" lines=\"290\" />\n        <cntx:content><![CDATA[// web/src/App.tsx - Sidebar Navigation with shadcn/ui\nimport { useEffect, useState } from 'react'\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query'\nimport { BundleList } from './components/BundleList'\nimport { FileTree } from './components/FileTree'\nimport { EnhancedBundleConfig } from './components/EnhancedBundleConfig'\nimport { AIRulesManager } from './components/AIRulesManager'\nimport { HiddenFilesManager } from './components/HiddenFilesManager'\nimport { SemanticChunks } from './components/SemanticChunks'\nimport { SetupChecklist, UsageGuidance, WorkflowInstructions, QuickCliReference } from './components/SetupComponents'\nimport SetupScreen from './components/SetupScreen'\nimport { Card, CardHeader, CardTitle, CardContent } from './components/ui/card'\nimport { Button } from './components/ui/button'\nimport {\n  Layers,\n  Sparkles,\n  CheckCircle,\n  HelpCircle,\n  Rocket,\n  EyeOff\n} from 'lucide-react'\nimport { ThemeToggle } from './components/theme-toggle'\n\nconst queryClient = new QueryClient()\n\nconst navigationItems = [\n  {\n    id: 'bundles',\n    label: 'Bundles & Files',\n    icon: Layers\n  },\n  {\n    id: 'semantic',\n    label: 'Semantic Chunks',\n    icon: Sparkles\n  },\n  {\n    id: 'settings',\n    label: 'Settings',\n    icon: EyeOff\n  },\n  {\n    id: 'ai-rules',\n    label: 'AI Rules',\n    icon: Sparkles\n  },\n  {\n    id: 'setup',\n    label: 'Setup Status',\n    icon: CheckCircle\n  },\n  {\n    id: 'help',\n    label: 'Help',\n    icon: HelpCircle\n  },\n  {\n    id: 'setup-guide',\n    label: 'Setup Guide',\n    icon: Rocket\n  }\n]\n\nfunction App() {\n  const [webStatus, setWebStatus] = useState<'connecting' | 'connected' | 'disconnected'>('connecting')\n  const [mcpStatus, setMcpStatus] = useState<'unknown' | 'running' | 'stopped'>('unknown')\n  const [activeSection, setActiveSection] = useState('bundles')\n  const [showFullSetupGuide, setShowFullSetupGuide] = useState(false)\n\n  useEffect(() => {\n    // Web server status via WebSocket\n    const ws = new WebSocket('ws://localhost:3333')\n    ws.onopen = () => setWebStatus('connected')\n    ws.onclose = () => setWebStatus('disconnected')\n\n    // Check MCP server status\n    const checkMcpStatus = async () => {\n      try {\n        const response = await fetch('/api/mcp-status')\n        if (response.ok) {\n          const { running } = await response.json()\n          setMcpStatus(running ? 'running' : 'stopped')\n        } else {\n          setMcpStatus('stopped')\n        }\n      } catch {\n        setMcpStatus('stopped')\n      }\n    }\n\n    checkMcpStatus()\n    const mcpInterval = setInterval(checkMcpStatus, 10000) // Check every 10s\n\n    return () => {\n      ws.close()\n      clearInterval(mcpInterval)\n    }\n  }, [])\n\n  if (showFullSetupGuide) {\n    return (\n      <QueryClientProvider client={queryClient}>\n        <div className=\"relative\">\n          <Button\n            variant=\"ghost\"\n            onClick={() => setShowFullSetupGuide(false)}\n            className=\"absolute top-4 right-4 z-10\"\n          >\n            ← Back to Dashboard\n          </Button>\n          <SetupScreen />\n        </div>\n      </QueryClientProvider>\n    )\n  }\n\n  const renderContent = () => {\n    switch (activeSection) {\n      case 'bundles':\n        return (\n          <div className=\"space-y-6\">\n            <div>\n              <h1 className=\"text-lg font-medium tracking-tight\">Bundles & Files</h1>\n              <p className=\"text-xs text-muted-foreground font-normal\">Manage your file bundles and project structure</p>\n            </div>\n            <BundleList />\n            <Card>\n              <CardHeader>\n                <CardTitle>Project Files</CardTitle>\n              </CardHeader>\n              <CardContent>\n                <FileTree />\n              </CardContent>\n            </Card>\n          </div>\n        )\n      case 'semantic':\n        return (\n          <div className=\"space-y-6\">\n            <div>\n              <h1 className=\"text-lg font-medium tracking-tight\">Semantic Chunks</h1>\n              <p className=\"text-xs text-muted-foreground font-normal\">AI-powered code organization and intelligent bundles</p>\n            </div>\n            <SemanticChunks />\n          </div>\n        )\n      case 'settings':\n        return (\n          <div className=\"space-y-6\">\n            <div>\n              <h1 className=\"text-lg font-medium tracking-tight\">Settings</h1>\n              <p className=\"text-xs text-muted-foreground font-normal\">Configure file visibility and bundle patterns</p>\n            </div>\n            <HiddenFilesManager />\n            <EnhancedBundleConfig />\n          </div>\n        )\n      case 'ai-rules':\n        return (\n          <div className=\"space-y-6\">\n            <div>\n              <h1 className=\"text-lg font-medium tracking-tight\">AI Rules</h1>\n              <p className=\"text-xs text-muted-foreground font-normal\">Configure AI context and project guidelines</p>\n            </div>\n            <AIRulesManager />\n          </div>\n        )\n      case 'setup':\n        return (\n          <div className=\"space-y-6\">\n            <div>\n              <h1 className=\"text-lg font-medium tracking-tight\">Setup Status</h1>\n              <p className=\"text-xs text-muted-foreground font-normal\">Project configuration checklist</p>\n            </div>\n            <SetupChecklist onOpenFullSetup={() => setShowFullSetupGuide(true)} />\n          </div>\n        )\n      case 'help':\n        return (\n          <div className=\"space-y-6\">\n            <div>\n              <h1 className=\"text-lg font-medium tracking-tight\">Help & Documentation</h1>\n              <p className=\"text-xs text-muted-foreground font-normal\">Usage guides and workflow instructions</p>\n            </div>\n            <UsageGuidance />\n            <WorkflowInstructions />\n            <QuickCliReference />\n          </div>\n        )\n      default:\n        return null\n    }\n  }\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <div className=\"h-screen bg-background overflow-hidden\">\n        <div className=\"flex h-full\">\n          {/* Sidebar */}\n          <div className=\"w-64 border-r bg-muted/10 flex flex-col h-full\">\n            {/* Header */}\n            <div className=\"p-4 border-b flex-shrink-0\">\n              <div className=\"flex items-center gap-2\">\n                <div className=\"w-6 h-6 rounded-md bg-primary flex items-center justify-center\">\n                  <Layers className=\"w-3 h-3 text-primary-foreground\" />\n                </div>\n                <div>\n                  <h2 className=\"text-sm font-medium\">cntx-ui</h2>\n                  <p className=\"text-xs text-muted-foreground font-normal\">Context Manager</p>\n                </div>\n              </div>\n            </div>\n\n            {/* Navigation */}\n            <nav className=\"p-4 space-y-1 flex-1 overflow-y-auto\">\n              {navigationItems.map((item) => {\n                const Icon = item.icon\n                const isActive = activeSection === item.id\n\n                return (\n                  <Button\n                    key={item.id}\n                    variant={isActive ? \"secondary\" : \"ghost\"}\n                    className=\"w-full justify-start h-8 text-xs font-normal\"\n                    onClick={() => {\n                      if (item.id === 'setup-guide') {\n                        setShowFullSetupGuide(true)\n                      } else {\n                        setActiveSection(item.id)\n                      }\n                    }}\n                  >\n                    <Icon className=\"w-3 h-3 mr-2\" />\n                    {item.label}\n                  </Button>\n                )\n              })}\n            </nav>\n\n          </div>\n\n          {/* Main Content */}\n          <div className=\"flex-1 overflow-y-auto pb-12\">\n            <main className=\"p-6 max-w-6xl\">\n              {renderContent()}\n            </main>\n          </div>\n        </div>\n\n        {/* Full-width Status Bar */}\n        <div className=\"fixed bottom-0 left-0 right-0 h-10 bg-card border-t border-border px-4 flex items-center justify-between z-40\">\n          <div className=\"flex items-center gap-6\">\n            {/* Web Server Status */}\n            <div className=\"flex items-center gap-2\">\n              <div className={`w-2 h-2 rounded-full ${webStatus === 'connected' ? 'bg-[color:var(--color-success)]' :\n                  webStatus === 'connecting' ? 'bg-[color:var(--color-warning)]' : 'bg-destructive'\n                }`} />\n              <span className=\"text-xs font-normal\">\n                Web: {webStatus === 'connected' ? 'Live' :\n                  webStatus === 'connecting' ? 'Connecting' : 'Offline'}\n              </span>\n            </div>\n\n            {/* MCP Server Status */}\n            <div className=\"flex items-center gap-2\">\n              <div className={`w-2 h-2 rounded-full ${mcpStatus === 'running' ? 'bg-[color:var(--color-success)]' :\n                  mcpStatus === 'stopped' ? 'bg-destructive' : 'bg-muted-foreground'\n                }`} />\n              <span className=\"text-xs font-normal\">\n                MCP: {mcpStatus === 'running' ? 'Running' :\n                  mcpStatus === 'stopped' ? 'Stopped' : 'Unknown'}\n              </span>\n            </div>\n          </div>\n\n          <div className=\"flex items-center gap-4\">\n            <div className=\"text-xs text-muted-foreground\">\n              cntx-ui v2.0.12\n            </div>\n            <ThemeToggle />\n          </div>\n        </div>\n\n      </div>\n    </QueryClientProvider>\n  )\n}\n\nexport default App\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/index.css\" ext=\".css\" role=\"entry-point\">\n        <cntx:meta size=\"5585\" modified=\"2025-06-25T06:27:10.282Z\" lines=\"156\" />\n        <cntx:content><![CDATA[@import \"tailwindcss\";\n@import \"tw-animate-css\";\n\n@custom-variant dark (&:is(.dark *));\n\n@theme inline {\n  --radius-sm: calc(var(--radius) - 1px);\n  --radius-md: calc(var(--radius) - 1px);\n  --radius-lg: var(--radius);\n  --radius-xl: calc(var(--radius) + 1px);\n  --color-background: var(--background);\n  --color-foreground: var(--foreground);\n  --color-card: var(--card);\n  --color-card-foreground: var(--card-foreground);\n  --color-popover: var(--popover);\n  --color-popover-foreground: var(--popover-foreground);\n  --color-primary: var(--primary);\n  --color-primary-foreground: var(--primary-foreground);\n  --color-secondary: var(--secondary);\n  --color-secondary-foreground: var(--secondary-foreground);\n  --color-muted: var(--muted);\n  --color-muted-foreground: var(--muted-foreground);\n  --color-accent: var(--accent);\n  --color-accent-foreground: var(--accent-foreground);\n  --color-destructive: var(--destructive);\n  --color-border: var(--border);\n  --color-input: var(--input);\n  --color-ring: var(--ring);\n  --color-chart-1: var(--chart-1);\n  --color-chart-2: var(--chart-2);\n  --color-chart-3: var(--chart-3);\n  --color-chart-4: var(--chart-4);\n  --color-chart-5: var(--chart-5);\n  --color-sidebar: var(--sidebar);\n  --color-sidebar-foreground: var(--sidebar-foreground);\n  --color-sidebar-primary: var(--sidebar-primary);\n  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);\n  --color-sidebar-accent: var(--sidebar-accent);\n  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);\n  --color-sidebar-border: var(--sidebar-border);\n  --color-sidebar-ring: var(--sidebar-ring);\n  \n  /* File type colors */\n  --color-type-components: var(--chart-2);\n  --color-type-components-fg: var(--chart-2);\n  --color-type-hooks: var(--chart-3);\n  --color-type-hooks-fg: var(--chart-3);\n  --color-type-utilities: var(--chart-1);\n  --color-type-utilities-fg: var(--chart-1);\n  --color-type-configuration: var(--chart-5);\n  --color-type-configuration-fg: var(--chart-5);\n  --color-type-styles: var(--chart-4);\n  --color-type-styles-fg: var(--chart-4);\n  --color-type-types: var(--primary);\n  --color-type-types-fg: var(--primary);\n  --color-type-tests: var(--accent);\n  --color-type-tests-fg: var(--accent);\n  --color-type-documentation: var(--muted);\n  --color-type-documentation-fg: var(--muted-foreground);\n  \n  /* Status colors */\n  --color-success: oklch(0.75 0.12 140);\n  --color-success-foreground: oklch(0.98 0.005 240);\n  --color-warning: oklch(0.8 0.12 65);\n  --color-warning-foreground: oklch(0.15 0.01 240);\n  --color-info: var(--primary);\n  --color-info-foreground: var(--primary-foreground);\n}\n\n:root {\n  --radius: 0.225rem;\n  --background: oklch(0.98 0.005 240);\n  --foreground: oklch(0.25 0.02 240);\n  --card: oklch(0.99 0.003 240);\n  --card-foreground: oklch(0.25 0.02 240);\n  --popover: oklch(0.99 0.003 240);\n  --popover-foreground: oklch(0.25 0.02 240);\n  --primary: oklch(0.65 0.08 200);\n  --primary-foreground: oklch(0.98 0.005 240);\n  --secondary: oklch(0.92 0.02 240);\n  --secondary-foreground: oklch(0.35 0.03 240);\n  --muted: oklch(0.94 0.01 240);\n  --muted-foreground: oklch(0.55 0.02 240);\n  --accent: oklch(0.88 0.03 220);\n  --accent-foreground: oklch(0.25 0.02 240);\n  --destructive: oklch(0.75 0.15 25);\n  --border: oklch(0.88 0.01 240);\n  --input: oklch(0.88 0.01 240);\n  --ring: oklch(0.65 0.08 200);\n  --chart-1: oklch(0.75 0.12 45);\n  --chart-2: oklch(0.7 0.08 180);\n  --chart-3: oklch(0.65 0.06 220);\n  --chart-4: oklch(0.8 0.1 90);\n  --chart-5: oklch(0.75 0.09 75);\n  --sidebar: oklch(0.96 0.004 240);\n  --sidebar-foreground: oklch(0.25 0.02 240);\n  --sidebar-primary: oklch(0.65 0.08 200);\n  --sidebar-primary-foreground: oklch(0.98 0.005 240);\n  --sidebar-accent: oklch(0.92 0.02 240);\n  --sidebar-accent-foreground: oklch(0.35 0.03 240);\n  --sidebar-border: oklch(0.88 0.01 240);\n  --sidebar-ring: oklch(0.65 0.08 200);\n}\n\n.dark {\n  --background: oklch(0.13 0.01 240);\n  --foreground: oklch(0.85 0.02 240);\n  --card: oklch(0.13 0.01 240);\n  --card-foreground: oklch(0.85 0.02 240);\n  --popover: oklch(0.22 0.015 240);\n  --popover-foreground: oklch(0.85 0.02 240);\n  --primary: oklch(0.7 0.06 200);\n  --primary-foreground: oklch(0.15 0.01 240);\n  --secondary: oklch(0.28 0.02 240);\n  --secondary-foreground: oklch(0.85 0.02 240);\n  --muted: oklch(0.28 0.02 240);\n  --muted-foreground: oklch(0.65 0.02 240);\n  --accent: oklch(0.32 0.025 240);\n  --accent-foreground: oklch(0.85 0.02 240);\n  --destructive: oklch(0.7 0.12 25);\n  --border: oklch(0.2 0.02 240);\n  --input: oklch(0.35 0.02 240);\n  --ring: oklch(0.7 0.06 200);\n  --chart-1: oklch(0.65 0.1 45);\n  --chart-2: oklch(0.6 0.07 180);\n  --chart-3: oklch(0.55 0.05 220);\n  --chart-4: oklch(0.7 0.08 90);\n  --chart-5: oklch(0.65 0.07 75);\n  --sidebar: oklch(0.18 0.012 240);\n  --sidebar-foreground: oklch(0.85 0.02 240);\n  --sidebar-primary: oklch(0.7 0.06 200);\n  --sidebar-primary-foreground: oklch(0.15 0.01 240);\n  --sidebar-accent: oklch(0.28 0.02 240);\n  --sidebar-accent-foreground: oklch(0.85 0.02 240);\n  --sidebar-border: oklch(0.35 0.02 240);\n  --sidebar-ring: oklch(0.7 0.06 200);\n  \n  /* Dark mode status colors */\n  --color-success: oklch(0.65 0.1 140);\n  --color-success-foreground: oklch(0.15 0.01 240);\n  --color-warning: oklch(0.7 0.1 65);\n  --color-warning-foreground: oklch(0.15 0.01 240);\n  --color-info: var(--primary);\n  --color-info-foreground: var(--primary-foreground);\n}\n\n@layer base {\n  * {\n    @apply border-border outline-ring/50;\n  }\n  body {\n    @apply bg-background text-foreground;\n    font-family: 'JetBrains Mono', monospace;\n  }\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/main.tsx\" ext=\".tsx\" role=\"entry-point\">\n        <cntx:meta size=\"729\" modified=\"2025-06-25T06:31:35.145Z\" lines=\"27\" />\n        <cntx:content><![CDATA[// web/src/main.tsx\nimport { StrictMode } from 'react'\nimport { createRoot } from 'react-dom/client'\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query'\nimport { Toaster } from './components/ui/toaster'\nimport { ThemeProvider } from './components/theme-provider'\nimport './index.css'\nimport App from './App'\n\nconst queryClient = new QueryClient()\n\ncreateRoot(document.getElementById('root')!).render(\n  <StrictMode>\n    <QueryClientProvider client={queryClient}>\n      <ThemeProvider\n        attribute=\"class\"\n        defaultTheme=\"system\"\n        enableSystem\n        disableTransitionOnChange\n      >\n        <App />\n        <Toaster />\n      </ThemeProvider>\n    </QueryClientProvider>\n  </StrictMode>,\n)\n]]></cntx:content>\n      </cntx:file>\n    </cntx:group>\n    <cntx:group type=\"components\" description=\"React/UI components and interface elements\">\n      <cntx:file path=\"web/src/components/AIRulesManager.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"9710\" modified=\"2025-06-26T00:22:22.986Z\" lines=\"270\" />\n        <cntx:content><![CDATA[import { useState, useEffect } from 'react'\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'\nimport { Card, CardHeader, CardTitle, CardContent } from './ui/card'\nimport { Button } from './ui/button'\nimport { Textarea } from './ui/textarea'\nimport { Alert, AlertDescription } from './ui/alert'\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from './ui/tabs'\nimport { Save, RefreshCw, Copy, Download, Sparkles, FileText, Info } from 'lucide-react'\nimport { toast } from '@/lib/toast'\n\n// Fetch functions for .cursorrules\nconst fetchCursorRules = async (): Promise<string> => {\n  const response = await fetch('http://localhost:3333/api/cursor-rules')\n  if (!response.ok) throw new Error('Failed to fetch cursor rules')\n  return response.text()\n}\n\nconst saveCursorRules = async (content: string): Promise<void> => {\n  const response = await fetch('http://localhost:3333/api/cursor-rules', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ content })\n  })\n  if (!response.ok) throw new Error('Failed to save cursor rules')\n}\n\n// Fetch functions for CLAUDE.md\nconst fetchClaudeMd = async (): Promise<string> => {\n  const response = await fetch('http://localhost:3333/api/claude-md')\n  if (!response.ok) throw new Error('Failed to fetch CLAUDE.md')\n  return response.text()\n}\n\nconst saveClaudeMd = async (content: string): Promise<void> => {\n  const response = await fetch('http://localhost:3333/api/claude-md', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ content })\n  })\n  if (!response.ok) throw new Error('Failed to save CLAUDE.md')\n}\n\nexport function AIRulesManager() {\n  const queryClient = useQueryClient()\n  const [editingCursorRules, setEditingCursorRules] = useState<string>('')\n  const [editingClaudeMd, setEditingClaudeMd] = useState<string>('')\n  const [activeTab, setActiveTab] = useState<'cursor' | 'claude'>('cursor')\n\n  // Cursor Rules queries\n  const { data: currentCursorRules, isLoading: cursorRulesLoading } = useQuery({\n    queryKey: ['cursor-rules'],\n    queryFn: fetchCursorRules\n  })\n\n  const cursorRulesMutation = useMutation({\n    mutationFn: saveCursorRules,\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['cursor-rules'] })\n      toast.success('.cursorrules saved successfully!')\n    },\n    onError: (error) => {\n      toast.error(`Failed to save .cursorrules: ${error.message}`)\n    }\n  })\n\n  // CLAUDE.md queries  \n  const { data: currentClaudeMd, isLoading: claudeMdLoading } = useQuery({\n    queryKey: ['claude-md'],\n    queryFn: fetchClaudeMd\n  })\n\n  const claudeMdMutation = useMutation({\n    mutationFn: saveClaudeMd,\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['claude-md'] })\n      toast.success('CLAUDE.md saved successfully!')\n    },\n    onError: (error) => {\n      toast.error(`Failed to save CLAUDE.md: ${error.message}`)\n    }\n  })\n\n  // Initialize editing states when data loads\n  useEffect(() => {\n    if (currentCursorRules && !editingCursorRules) {\n      setEditingCursorRules(currentCursorRules)\n    }\n  }, [currentCursorRules])\n\n  useEffect(() => {\n    if (currentClaudeMd && !editingClaudeMd) {\n      setEditingClaudeMd(currentClaudeMd)\n    }\n  }, [currentClaudeMd])\n\n  const handleSaveCursorRules = () => {\n    cursorRulesMutation.mutate(editingCursorRules)\n  }\n\n  const handleSaveClaudeMd = () => {\n    claudeMdMutation.mutate(editingClaudeMd)\n  }\n\n  const handleCopyToClipboard = (content: string, type: string) => {\n    navigator.clipboard.writeText(content)\n    toast.success(`${type} copied to clipboard!`)\n  }\n\n  const handleDownload = (content: string, filename: string) => {\n    const blob = new Blob([content], { type: 'text/plain' })\n    const url = URL.createObjectURL(blob)\n    const a = document.createElement('a')\n    a.href = url\n    a.download = filename\n    document.body.appendChild(a)\n    a.click()\n    document.body.removeChild(a)\n    URL.revokeObjectURL(url)\n    toast.success(`${filename} downloaded!`)\n  }\n\n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle className=\"flex items-center gap-2 text-sm font-medium\">\n          <Sparkles className=\"w-4 h-4\" />\n          AI Rules & Context\n        </CardTitle>\n      </CardHeader>\n      <CardContent>\n        <Alert className=\"mb-4\">\n          <Info className=\"w-4 h-4\" />\n          <AlertDescription>\n            Configure AI context files for better assistance. <strong>.cursorrules</strong> works with Cursor, \n            while <strong>CLAUDE.md</strong> provides project context for Claude.\n          </AlertDescription>\n        </Alert>\n\n        <Tabs value={activeTab} onValueChange={(value) => setActiveTab(value as 'cursor' | 'claude')} className=\"space-y-4\">\n          <TabsList className=\"grid w-full grid-cols-2\">\n            <TabsTrigger value=\"cursor\" className=\"flex items-center gap-2\">\n              <FileText className=\"w-4 h-4\" />\n              .cursorrules\n            </TabsTrigger>\n            <TabsTrigger value=\"claude\" className=\"flex items-center gap-2\">\n              <Sparkles className=\"w-4 h-4\" />\n              CLAUDE.md\n            </TabsTrigger>\n          </TabsList>\n\n          <TabsContent value=\"cursor\" className=\"space-y-4\">\n            <div className=\"flex justify-between items-center\">\n              <div>\n                <h3 className=\"text-sm font-medium\">Cursor AI Assistant Rules</h3>\n                <p className=\"text-xs text-muted-foreground font-normal\">\n                  Configure how Cursor's AI understands your project\n                </p>\n              </div>\n              <div className=\"flex gap-2\">\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  className=\"h-7 text-xs\"\n                  onClick={() => handleCopyToClipboard(editingCursorRules, '.cursorrules')}\n                >\n                  <Copy className=\"w-3 h-3 mr-1\" />\n                  Copy\n                </Button>\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  className=\"h-7 text-xs\"\n                  onClick={() => handleDownload(editingCursorRules, '.cursorrules')}\n                >\n                  <Download className=\"w-3 h-3 mr-1\" />\n                  Download\n                </Button>\n                <Button\n                  onClick={handleSaveCursorRules}\n                  disabled={cursorRulesMutation.isPending}\n                  size=\"sm\"\n                  className=\"h-7 text-xs\"\n                >\n                  <Save className=\"w-3 h-3 mr-1\" />\n                  Save\n                </Button>\n              </div>\n            </div>\n\n            {cursorRulesLoading ? (\n              <div className=\"flex items-center justify-center p-8\">\n                <RefreshCw className=\"w-6 h-6 animate-spin mr-2\" />\n                Loading...\n              </div>\n            ) : (\n              <Textarea\n                value={editingCursorRules}\n                onChange={(e) => setEditingCursorRules(e.target.value)}\n                placeholder=\"Enter your Cursor AI rules here...\"\n                className=\"min-h-[300px] font-mono text-sm\"\n              />\n            )}\n          </TabsContent>\n\n          <TabsContent value=\"claude\" className=\"space-y-4\">\n            <div className=\"flex justify-between items-center\">\n              <div>\n                <h3 className=\"text-sm font-medium\">Claude Project Context</h3>\n                <p className=\"text-xs text-muted-foreground font-normal\">\n                  Markdown file explaining your project structure and guidelines\n                </p>\n              </div>\n              <div className=\"flex gap-2\">\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  className=\"h-7 text-xs\"\n                  onClick={() => handleCopyToClipboard(editingClaudeMd, 'CLAUDE.md')}\n                >\n                  <Copy className=\"w-3 h-3 mr-1\" />\n                  Copy\n                </Button>\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  className=\"h-7 text-xs\"\n                  onClick={() => handleDownload(editingClaudeMd, 'CLAUDE.md')}\n                >\n                  <Download className=\"w-3 h-3 mr-1\" />\n                  Download\n                </Button>\n                <Button\n                  onClick={handleSaveClaudeMd}\n                  disabled={claudeMdMutation.isPending}\n                  size=\"sm\"\n                  className=\"h-7 text-xs\"\n                >\n                  <Save className=\"w-3 h-3 mr-1\" />\n                  Save\n                </Button>\n              </div>\n            </div>\n\n            {claudeMdLoading ? (\n              <div className=\"flex items-center justify-center p-8\">\n                <RefreshCw className=\"w-6 h-6 animate-spin mr-2\" />\n                Loading...\n              </div>\n            ) : (\n              <Textarea\n                value={editingClaudeMd}\n                onChange={(e) => setEditingClaudeMd(e.target.value)}\n                placeholder=\"Enter your Claude project context here...\"\n                className=\"min-h-[300px] font-mono text-sm\"\n              />\n            )}\n\n            <Alert>\n              <Info className=\"w-4 h-4\" />\n              <AlertDescription>\n                This file helps Claude understand your project. Include project structure, \n                coding conventions, key concepts, and any important context.\n              </AlertDescription>\n            </Alert>\n          </TabsContent>\n        </Tabs>\n      </CardContent>\n    </Card>\n  )\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/BundleConfig.tsx\" ext=\".tsx\" role=\"configuration\">\n        <cntx:meta size=\"25381\" modified=\"2025-06-25T06:32:51.511Z\" lines=\"696\" />\n        <cntx:content><![CDATA[import { useState, useEffect } from 'react'\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'\nimport { Card, CardHeader, CardTitle, CardContent } from './ui/card'\nimport { Button } from './ui/button'\nimport { Input } from './ui/input'\nimport { Badge } from './ui/badge'\nimport { Textarea } from './ui/textarea'\nimport { Trash2, Plus, Save, Eye, AlertTriangle, Settings, X } from 'lucide-react'\nimport { useButtonFeedback } from '../hooks/useButtonFeedback'\nimport { getButtonIcon, getButtonClassName } from '../utils/buttonHelpers'\nimport { toast } from '@/lib/toast'\n\n// Extend Window interface for timeout\ndeclare global {\n  interface Window {\n    patternChangeTimeout?: NodeJS.Timeout\n  }\n}\n\ninterface BundleConfig {\n  bundles: Record<string, string[]>\n}\n\ninterface Bundle {\n  name: string\n  files: string[]\n  size: number\n}\n\nconst fetchConfig = async (): Promise<BundleConfig> => {\n  const response = await fetch('http://localhost:3333/api/config')\n  if (!response.ok) throw new Error('Failed to fetch config')\n  return response.json()\n}\n\nconst fetchBundles = async (): Promise<Bundle[]> => {\n  const response = await fetch('http://localhost:3333/api/bundles')\n  if (!response.ok) throw new Error('Failed to fetch bundles')\n  return response.json()\n}\n\nconst saveConfig = async (config: BundleConfig): Promise<void> => {\n  const response = await fetch('http://localhost:3333/api/config', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(config)\n  })\n  if (!response.ok) throw new Error('Failed to save config')\n}\n\nconst testPattern = async (pattern: string): Promise<string[]> => {\n  const response = await fetch('http://localhost:3333/api/test-pattern', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ pattern })\n  })\n  if (!response.ok) throw new Error('Failed to test pattern')\n  return response.json()\n}\n\nexport function BundleConfig() {\n  const queryClient = useQueryClient()\n  const [editingConfig, setEditingConfig] = useState<BundleConfig | null>(null)\n  const [testingPattern, setTestingPattern] = useState('')\n  const [testResults, setTestResults] = useState<string[]>([])\n  const [pasteConfigText, setPasteConfigText] = useState('')\n\n  // New bundle creation state\n  const [showAddBundle, setShowAddBundle] = useState(false)\n  const [newBundleName, setNewBundleName] = useState('')\n  const [newBundlePatterns, setNewBundlePatterns] = useState('**/*')\n\n  const { setButtonState, getButtonState, isLoading } = useButtonFeedback()\n\n  const { data: config, isLoading: configLoading } = useQuery({\n    queryKey: ['config'],\n    queryFn: fetchConfig\n  })\n\n  const { data: bundles } = useQuery({\n    queryKey: ['bundles'],\n    queryFn: fetchBundles,\n    refetchInterval: 5000\n  })\n\n  const saveMutation = useMutation({\n    mutationFn: saveConfig,\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['config'] })\n      queryClient.invalidateQueries({ queryKey: ['bundles'] })\n      setEditingConfig(null)\n      setButtonState('save', 'success')\n      toast.success('Configuration saved successfully!')\n    },\n    onError: (error) => {\n      setButtonState('save', 'error')\n      toast.error(`Failed to save config: ${error.message}`)\n    }\n  })\n\n  useEffect(() => {\n    if (config && !editingConfig) {\n      setEditingConfig(config)\n    }\n  }, [config])\n\n  const handleSave = () => {\n    if (editingConfig) {\n      setButtonState('save', 'loading')\n      saveMutation.mutate(editingConfig)\n    }\n  }\n\n  const handleTestPattern = async () => {\n    if (!testingPattern.trim()) return\n\n    setButtonState('test', 'loading')\n    try {\n      const results = await testPattern(testingPattern)\n      setTestResults(results)\n      setButtonState('test', 'success')\n      toast.success(`Pattern matched ${results.length} files`)\n    } catch (error) {\n      console.error('Pattern test failed:', error)\n      setTestResults([])\n      setButtonState('test', 'error')\n      toast.error('Failed to test pattern')\n    }\n  }\n\n  const handlePasteConfig = async () => {\n    if (!pasteConfigText.trim()) return\n\n    setButtonState('paste', 'loading')\n    try {\n      const parsed = JSON.parse(pasteConfigText)\n      if (!parsed.bundles || typeof parsed.bundles !== 'object') {\n        throw new Error('Configuration must have a \"bundles\" object')\n      }\n\n      // Ensure master bundle exists\n      if (!parsed.bundles.master) {\n        parsed.bundles.master = ['**/*']\n      }\n\n      setEditingConfig({\n        bundles: Object.fromEntries(\n          Object.entries(parsed.bundles).map(([name, patterns]) => [\n            name,\n            Array.isArray(patterns) ? patterns : [patterns]\n          ])\n        )\n      })\n\n      const bundleCount = Object.keys(parsed.bundles).length\n      setPasteConfigText('')\n      setButtonState('paste', 'success')\n      toast.success(`Applied ${bundleCount} bundles successfully`)\n    } catch (error) {\n      setButtonState('paste', 'error')\n      toast.error(`Invalid configuration: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  // Handle adding new bundle - immediately save to system\n  const handleAddBundle = async () => {\n    if (!editingConfig || !newBundleName.trim()) return\n\n    const trimmedName = newBundleName.trim()\n\n    if (editingConfig.bundles[trimmedName]) {\n      toast.error(`Bundle \"${trimmedName}\" already exists`)\n      return\n    }\n\n    // Parse patterns (split by newlines, filter empty)\n    const patterns = newBundlePatterns\n      .split('\\n')\n      .map(p => p.trim())\n      .filter(p => p.length > 0)\n\n    if (patterns.length === 0) {\n      toast.error('At least one pattern is required')\n      return\n    }\n\n    const newConfig = {\n      ...editingConfig,\n      bundles: {\n        ...editingConfig.bundles,\n        [trimmedName]: patterns\n      }\n    }\n\n    try {\n      // Immediately save to system\n      setButtonState('create-bundle', 'loading')\n      await saveConfig(newConfig)\n\n      // Update local state\n      setEditingConfig(newConfig)\n\n      // Reset form\n      setNewBundleName('')\n      setNewBundlePatterns('**/*')\n      setShowAddBundle(false)\n\n      // Force refresh ALL bundle-related queries\n      await queryClient.invalidateQueries({ queryKey: ['config'] })\n      await queryClient.invalidateQueries({ queryKey: ['bundles'] })\n      await queryClient.invalidateQueries({ queryKey: ['bundle-visibility-stats'] })\n\n      // Also force refetch to ensure immediate update\n      queryClient.refetchQueries({ queryKey: ['bundles'] })\n\n      setButtonState('create-bundle', 'success')\n      toast.success(`Bundle \"${trimmedName}\" created and saved!`)\n    } catch (error) {\n      setButtonState('create-bundle', 'error')\n      toast.error(`Failed to create bundle: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  const handleDeleteBundle = async (bundleName: string) => {\n    if (!editingConfig || bundleName === 'master') return\n    if (!confirm(`Delete bundle \"${bundleName}\"?`)) return\n\n    try {\n      setButtonState(`delete-${bundleName}`, 'loading')\n\n      // Create new config without the deleted bundle\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const { [bundleName]: deleted, ...rest } = editingConfig.bundles\n      const newConfig = { ...editingConfig, bundles: rest }\n\n      // Immediately save to system\n      await saveConfig(newConfig)\n\n      // Update local state\n      setEditingConfig(newConfig)\n\n      // Wait a moment for server to process\n      await new Promise(resolve => setTimeout(resolve, 500))\n\n      // Force clear all cache and refetch\n      queryClient.removeQueries({ queryKey: ['bundles'] })\n      queryClient.removeQueries({ queryKey: ['config'] })\n      queryClient.removeQueries({ queryKey: ['bundle-visibility-stats'] })\n\n      // Force immediate refetch\n      await queryClient.refetchQueries({ queryKey: ['bundles'] })\n      await queryClient.refetchQueries({ queryKey: ['config'] })\n\n      setButtonState(`delete-${bundleName}`, 'success')\n      toast.success(`Bundle \"${bundleName}\" deleted successfully!`)\n    } catch (error) {\n      setButtonState(`delete-${bundleName}`, 'error')\n      toast.error(`Failed to delete bundle: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  const handlePatternChange = async (bundleName: string, index: number, newPattern: string) => {\n    if (!editingConfig) return\n\n    const newPatterns = [...editingConfig.bundles[bundleName]]\n    newPatterns[index] = newPattern\n    const newConfig = {\n      ...editingConfig,\n      bundles: { ...editingConfig.bundles, [bundleName]: newPatterns }\n    }\n\n    setEditingConfig(newConfig)\n\n    // Debounced save - only save after user stops typing for 1 second\n    clearTimeout(window.patternChangeTimeout)\n    window.patternChangeTimeout = setTimeout(async () => {\n      try {\n        await saveConfig(newConfig)\n        queryClient.invalidateQueries({ queryKey: ['config'] })\n        queryClient.invalidateQueries({ queryKey: ['bundles'] })\n      } catch (error) {\n        toast.error(`Failed to save pattern change: ${error instanceof Error ? error.message : 'Unknown error'}`)\n      }\n    }, 1000)\n  }\n\n  const handleAddPattern = async (bundleName: string) => {\n    if (!editingConfig) return\n\n    const newConfig = {\n      ...editingConfig,\n      bundles: {\n        ...editingConfig.bundles,\n        [bundleName]: [...editingConfig.bundles[bundleName], '']\n      }\n    }\n\n    try {\n      await saveConfig(newConfig)\n      setEditingConfig(newConfig)\n      queryClient.invalidateQueries({ queryKey: ['config'] })\n      queryClient.invalidateQueries({ queryKey: ['bundles'] })\n      toast.success('Pattern added')\n    } catch (error) {\n      toast.error(`Failed to add pattern: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  const handleRemovePattern = async (bundleName: string, index: number) => {\n    if (!editingConfig || editingConfig.bundles[bundleName].length === 1) return\n\n    const newPatterns = editingConfig.bundles[bundleName].filter((_, i) => i !== index)\n    const newConfig = {\n      ...editingConfig,\n      bundles: { ...editingConfig.bundles, [bundleName]: newPatterns }\n    }\n\n    try {\n      await saveConfig(newConfig)\n      setEditingConfig(newConfig)\n      queryClient.invalidateQueries({ queryKey: ['config'] })\n      queryClient.invalidateQueries({ queryKey: ['bundles'] })\n      toast.success('Pattern removed')\n    } catch (error) {\n      toast.error(`Failed to remove pattern: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  const getBundleStats = (bundleName: string) => {\n    const bundle = bundles?.find(b => b.name === bundleName)\n    return bundle ? { files: bundle.files.length, size: bundle.size } : { files: 0, size: 0 }\n  }\n\n  const formatSize = (bytes: number) => {\n    if (bytes === 0) return '0 B'\n    const k = 1024\n    const sizes = ['B', 'KB', 'MB', 'GB']\n    const i = Math.floor(Math.log(bytes) / Math.log(k))\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i]\n  }\n\n  if (configLoading) return <div>Loading configuration...</div>\n  if (!editingConfig) return <div>No configuration found</div>\n\n  const hasChanges = JSON.stringify(config) !== JSON.stringify(editingConfig)\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Header */}\n      <div className=\"flex justify-between items-center\">\n        <div>\n          <h2 className=\"text-lg font-semibold\">Bundle Configuration</h2>\n          <p className=\"text-sm text-muted-foreground\">\n            Define patterns for each bundle. Use glob patterns like *.js, src/**/*.tsx, etc.\n          </p>\n        </div>\n        <div className=\"flex gap-2\">\n          <Button\n            variant=\"outline\"\n            onClick={() => setEditingConfig(config || null)}\n            disabled={!hasChanges}\n          >\n            Reset\n          </Button>\n          <Button\n            onClick={handleSave}\n            disabled={!hasChanges || isLoading('save')}\n            className={getButtonClassName(getButtonState('save'))}\n          >\n            {getButtonIcon(getButtonState('save'), <Save className=\"w-4 h-4\" />)}\n            <span className=\"ml-1\">Save Changes</span>\n          </Button>\n        </div>\n      </div>\n\n      {/* Paste Configuration */}\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center gap-2\">\n            <Settings className=\"w-4 h-4\" />\n            Paste Bundle Configuration\n          </CardTitle>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <Textarea\n            placeholder=\"Paste bundle configuration JSON here...\"\n            value={pasteConfigText}\n            onChange={(e) => setPasteConfigText(e.target.value)}\n            className=\"min-h-32 font-mono text-sm\"\n          />\n          <div className=\"flex gap-2\">\n            <Button\n              onClick={handlePasteConfig}\n              disabled={!pasteConfigText.trim() || isLoading('paste')}\n              className={getButtonClassName(getButtonState('paste'))}\n            >\n              {getButtonIcon(getButtonState('paste'), <Settings className=\"w-4 h-4\" />)}\n              <span className=\"ml-1\">Apply Configuration</span>\n            </Button>\n            <Button\n              variant=\"outline\"\n              onClick={() => setPasteConfigText('')}\n              disabled={!pasteConfigText.trim()}\n            >\n              Clear\n            </Button>\n          </div>\n        </CardContent>\n      </Card>\n\n      {/* Pattern Tester */}\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center gap-2\">\n            <Eye className=\"w-4 h-4\" />\n            Pattern Tester\n          </CardTitle>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <div className=\"flex gap-2\">\n            <Input\n              placeholder=\"Test a glob pattern (e.g., src/**/*.ts)\"\n              value={testingPattern}\n              onChange={(e) => setTestingPattern(e.target.value)}\n              onKeyDown={(e) => e.key === 'Enter' && handleTestPattern()}\n            />\n            <Button\n              onClick={handleTestPattern}\n              disabled={!testingPattern.trim() || isLoading('test')}\n              className={getButtonClassName(getButtonState('test'))}\n            >\n              {getButtonIcon(getButtonState('test'), <Eye className=\"w-4 h-4\" />)}\n              <span className=\"ml-1\">Test</span>\n            </Button>\n          </div>\n\n          {testResults.length > 0 && (\n            <div className=\"space-y-2\">\n              <div className=\"text-sm font-medium\">\n                Matches {testResults.length} files:\n              </div>\n              <div className=\"max-h-40 overflow-y-auto bg-muted p-3 rounded-md\">\n                {testResults.slice(0, 20).map((file, i) => (\n                  <div key={i} className=\"text-sm font-mono\">{file}</div>\n                ))}\n                {testResults.length > 20 && (\n                  <div className=\"text-sm text-muted-foreground\">\n                    ... and {testResults.length - 20} more files\n                  </div>\n                )}\n              </div>\n            </div>\n          )}\n        </CardContent>\n      </Card>\n\n      {/* Bundle Enhancement Options - NEW SECTION */}\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center gap-2\">\n            <Settings className=\"w-4 h-4\" />\n            Bundle Enhancement Options\n          </CardTitle>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <div className=\"grid md:grid-cols-2 gap-6\">\n            {/* Structure & Context */}\n            <div className=\"space-y-3\">\n              <h4 className=\"font-medium text-sm\">Structure & Context</h4>\n              <div className=\"space-y-2\">\n                <label className=\"flex items-center gap-3\">\n                  <input type=\"checkbox\" className=\"rounded\" />\n                  <div className=\"flex-1\">\n                    <div className=\"text-sm\">Directory Tree</div>\n                    <div className=\"text-xs text-muted-foreground\">Include project structure overview</div>\n                  </div>\n                  <Badge variant=\"outline\" className=\"text-xs\">+10%</Badge>\n                </label>\n\n                <label className=\"flex items-center gap-3\">\n                  <input type=\"checkbox\" className=\"rounded\" />\n                  <div className=\"flex-1\">\n                    <div className=\"text-sm\">File Types</div>\n                    <div className=\"text-xs text-muted-foreground\">Auto-detect file purposes</div>\n                  </div>\n                  <Badge variant=\"outline\" className=\"text-xs\">+5%</Badge>\n                </label>\n\n                <label className=\"flex items-center gap-3\">\n                  <input type=\"checkbox\" className=\"rounded\" />\n                  <div className=\"flex-1\">\n                    <div className=\"text-sm\">Dependencies</div>\n                    <div className=\"text-xs text-muted-foreground\">Import/export mapping</div>\n                  </div>\n                  <Badge variant=\"outline\" className=\"text-xs\">+25%</Badge>\n                </label>\n              </div>\n            </div>\n\n            {/* AI Instructions */}\n            <div className=\"space-y-3\">\n              <h4 className=\"font-medium text-sm\">AI Instructions</h4>\n              <div className=\"space-y-2\">\n                <label className=\"flex items-center gap-3\">\n                  <input type=\"checkbox\" defaultChecked className=\"rounded\" />\n                  <div className=\"flex-1\">\n                    <div className=\"text-sm\">Bundle Purpose</div>\n                    <div className=\"text-xs text-muted-foreground\">What this bundle is for</div>\n                  </div>\n                  <Badge variant=\"outline\" className=\"text-xs\">+2%</Badge>\n                </label>\n\n                <label className=\"flex items-center gap-3\">\n                  <input type=\"checkbox\" defaultChecked className=\"rounded\" />\n                  <div className=\"flex-1\">\n                    <div className=\"text-sm\">Cursor Rules</div>\n                    <div className=\"text-xs text-muted-foreground\">Include .cursorrules content</div>\n                  </div>\n                  <Badge variant=\"outline\" className=\"text-xs\">+15%</Badge>\n                </label>\n\n                <label className=\"flex items-center gap-3\">\n                  <input type=\"checkbox\" className=\"rounded\" />\n                  <div className=\"flex-1\">\n                    <div className=\"text-sm\">Custom Instructions</div>\n                    <div className=\"text-xs text-muted-foreground\">Bundle-specific AI guidance</div>\n                  </div>\n                  <Badge variant=\"outline\" className=\"text-xs\">+5%</Badge>\n                </label>\n              </div>\n            </div>\n          </div>\n\n          <div className=\"bg-[color:var(--color-info)]/5 p-3 rounded-md\">\n            <div className=\"text-sm text-[color:var(--color-info)]\">\n              <strong>Coming Soon:</strong> These enhancement options will add rich context to your bundles,\n              making them more useful for AI agents. Enable features based on your needs vs. bundle size preferences.\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n\n      {/* Bundle Configurations */}\n      <div className=\"space-y-4\">\n        {Object.entries(editingConfig.bundles).map(([bundleName, patterns]) => {\n          const stats = getBundleStats(bundleName)\n          const isLarge = stats.size > 10 * 1024 * 1024\n\n          return (\n            <Card key={bundleName} className={isLarge ? 'border-[color:var(--color-warning)]' : ''}>\n              <CardHeader>\n                <div className=\"flex justify-between items-center\">\n                  <div className=\"flex items-center gap-3\">\n                    <CardTitle>{bundleName}</CardTitle>\n                    <Badge variant=\"outline\">\n                      {stats.files} files • {formatSize(stats.size)}\n                    </Badge>\n                    {isLarge && (\n                      <Badge variant=\"destructive\" className=\"flex items-center gap-1\">\n                        <AlertTriangle className=\"w-3 h-3\" />\n                        Large\n                      </Badge>\n                    )}\n                  </div>\n                  <div className=\"flex gap-2\">\n                    <Button\n                      variant=\"outline\"\n                      size=\"sm\"\n                      onClick={() => handleAddPattern(bundleName)}\n                    >\n                      <Plus className=\"w-4 h-4 mr-1\" />\n                      Add Pattern\n                    </Button>\n                    {bundleName !== 'master' && (\n                      <Button\n                        variant=\"outline\"\n                        size=\"sm\"\n                        onClick={() => handleDeleteBundle(bundleName)}\n                        disabled={isLoading(`delete-${bundleName}`)}\n                        className={getButtonClassName(getButtonState(`delete-${bundleName}`))}\n                      >\n                        {getButtonIcon(getButtonState(`delete-${bundleName}`), <Trash2 className=\"w-4 h-4\" />)}\n                      </Button>\n                    )}\n                  </div>\n                </div>\n              </CardHeader>\n              <CardContent className=\"space-y-3\">\n                {patterns.map((pattern, index) => (\n                  <div key={index} className=\"flex gap-2\">\n                    <Input\n                      value={pattern}\n                      onChange={(e) => handlePatternChange(bundleName, index, e.target.value)}\n                      placeholder=\"Glob pattern (e.g., src/**/*.ts)\"\n                      className=\"font-mono\"\n                    />\n                    {patterns.length > 1 && (\n                      <Button\n                        variant=\"outline\"\n                        size=\"sm\"\n                        onClick={() => handleRemovePattern(bundleName, index)}\n                      >\n                        <Trash2 className=\"w-4 h-4\" />\n                      </Button>\n                    )}\n                  </div>\n                ))}\n              </CardContent>\n            </Card>\n          )\n        })}\n      </div>\n\n      {/* Add New Bundle */}\n      <Card>\n        <CardContent className=\"pt-6\">\n          {!showAddBundle ? (\n            <Button\n              variant=\"outline\"\n              onClick={() => setShowAddBundle(true)}\n              className=\"w-full\"\n            >\n              <Plus className=\"w-4 h-4 mr-2\" />\n              Add New Bundle\n            </Button>\n          ) : (\n            <div className=\"space-y-4\">\n              <div className=\"flex justify-between items-center\">\n                <h3 className=\"text-lg font-medium\">Create New Bundle</h3>\n                <Button\n                  variant=\"ghost\"\n                  size=\"sm\"\n                  onClick={() => {\n                    setShowAddBundle(false)\n                    setNewBundleName('')\n                    setNewBundlePatterns('**/*')\n                  }}\n                >\n                  <X className=\"w-4 h-4\" />\n                </Button>\n              </div>\n\n              <div className=\"space-y-3\">\n                <div>\n                  <label className=\"text-sm font-medium\">Bundle Name</label>\n                  <Input\n                    placeholder=\"e.g., frontend, backend, tests\"\n                    value={newBundleName}\n                    onChange={(e) => setNewBundleName(e.target.value)}\n                  />\n                </div>\n\n                <div>\n                  <label className=\"text-sm font-medium\">Patterns (one per line)</label>\n                  <Textarea\n                    placeholder=\"src/components/**/*&#10;src/pages/**/*&#10;*.jsx\"\n                    value={newBundlePatterns}\n                    onChange={(e) => setNewBundlePatterns(e.target.value)}\n                    className=\"font-mono text-sm\"\n                    rows={4}\n                  />\n                  <div className=\"text-xs text-muted-foreground mt-1\">\n                    Examples: <code>src/**/*.ts</code>, <code>**/*.test.*</code>, <code>docs/**/*</code>\n                  </div>\n                </div>\n              </div>\n\n              <div className=\"flex gap-2\">\n                <Button\n                  onClick={handleAddBundle}\n                  disabled={!newBundleName.trim() || isLoading('create-bundle')}\n                  className={getButtonClassName(getButtonState('create-bundle'))}\n                >\n                  {getButtonIcon(getButtonState('create-bundle'), <Plus className=\"w-4 h-4\" />)}\n                  <span className=\"ml-1\">Create Bundle</span>\n                </Button>\n                <Button\n                  variant=\"outline\"\n                  onClick={() => {\n                    setShowAddBundle(false)\n                    setNewBundleName('')\n                    setNewBundlePatterns('**/*')\n                  }}\n                  disabled={isLoading('create-bundle')}\n                >\n                  Cancel\n                </Button>\n              </div>\n            </div>\n          )}\n        </CardContent>\n      </Card>\n    </div>\n  )\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/BundleList.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"42133\" modified=\"2025-06-26T17:12:31.324Z\" lines=\"1038\" />\n        <cntx:content><![CDATA[// web/src/components/BundleList.tsx\nimport { useQuery, useQueryClient } from '@tanstack/react-query'\nimport { Card, CardHeader, CardTitle, CardContent } from './ui/card'\nimport { Button } from '@/components/ui/button'\nimport { Badge } from '@/components/ui/badge'\n// import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'\nimport { Copy, RefreshCw, Loader2, CheckCircle, AlertCircle, Download, FileText, Settings, Code, BookOpen, Edit3, X, Plus, Minus, Search, AlertTriangle } from 'lucide-react'\nimport { useState } from 'react'\nimport { toast } from '@/lib/toast'\n\ninterface Bundle {\n  name: string\n  changed: boolean\n  fileCount: number\n  content: string\n  files: string[]\n  lastGenerated: string\n  size: number\n}\n\n\nconst fetchBundles = async (): Promise<Bundle[]> => {\n  const response = await fetch('http://localhost:3333/api/bundles')\n  if (!response.ok) throw new Error('Failed to fetch bundles')\n  return response.json()\n}\n\n\nconst fetchAllFiles = async (): Promise<string[]> => {\n  const response = await fetch('http://localhost:3333/api/files')\n  if (!response.ok) throw new Error('Failed to fetch files')\n  const fileData = await response.json()\n  return fileData.map((f: any) => f.path)\n}\n\nconst fetchUndercategorizedFiles = async (): Promise<{path: string, bundles: string[]}[]> => {\n  const response = await fetch('http://localhost:3333/api/files-with-visibility')\n  if (!response.ok) throw new Error('Failed to fetch files with visibility')\n  const filesData = await response.json()\n  \n  // Find files that are only in the 'master' bundle (need better bundle assignment)\n  // AND aren't globally hidden (which means they should be ignored)\n  return filesData\n    .filter((file: any) => {\n      const isNotGloballyHidden = !file.globallyHidden\n      const bundles = file.inBundles || []\n      const onlyInMaster = bundles.length === 1 && bundles[0] === 'master'\n      const hasNoBundles = bundles.length === 0\n      \n      return isNotGloballyHidden && (onlyInMaster || hasNoBundles)\n    })\n    .map((file: any) => ({\n      path: file.path,\n      bundles: file.inBundles || []\n    }))\n}\n\nconst suggestBundleForFile = (filePath: string): string[] => {\n  const fileName = filePath.toLowerCase()\n  const pathParts = fileName.split('/')\n  \n  const suggestions: string[] = []\n  \n  // Web/frontend files\n  if (pathParts.includes('web') || pathParts.includes('src')) {\n    suggestions.push('frontend')\n    \n    // More specific frontend bundles\n    if (pathParts.includes('components')) {\n      suggestions.push('ui-components')\n    }\n  }\n  \n  // Server/backend files\n  if (fileName.includes('server') || fileName.includes('api') || pathParts.includes('bin')) {\n    suggestions.push('server')\n  }\n  \n  // Configuration files\n  if (fileName.includes('config') || fileName.includes('setup') || fileName.endsWith('.json') || \n      fileName.endsWith('.sh') || fileName.includes('package')) {\n    suggestions.push('config')\n  }\n  \n  // Documentation\n  if (fileName.endsWith('.md') || fileName.includes('doc') || fileName.includes('readme')) {\n    suggestions.push('docs')\n  }\n  \n  // If no specific suggestions, suggest the most general applicable bundles\n  if (suggestions.length === 0) {\n    if (pathParts.includes('web')) {\n      suggestions.push('frontend')\n    } else {\n      suggestions.push('server', 'config')\n    }\n  }\n  \n  return suggestions\n}\n\nexport function BundleList() {\n  const queryClient = useQueryClient()\n  const [selectedBundle, setSelectedBundle] = useState<string | null>(null)\n  const [editingBundles, setEditingBundles] = useState<Set<string>>(new Set())\n  const [availableFiles, setAvailableFiles] = useState<string[]>([])\n  const [undercategorizedFiles, setUndercategorizedFiles] = useState<{path: string, bundles: string[]}[]>([])\n  const [showFileAnalysis, setShowFileAnalysis] = useState(false)\n  const [availableFilesSearch, setAvailableFilesSearch] = useState('')\n  const [loadingButtons, setLoadingButtons] = useState<Set<string>>(new Set())\n  const [successButtons, setSuccessButtons] = useState<Set<string>>(new Set())\n  const [errorButtons, setErrorButtons] = useState<Set<string>>(new Set())\n\n  // Use React Query for proper state management\n  const { data: bundles = [], isLoading, refetch } = useQuery({\n    queryKey: ['bundles'],\n    queryFn: fetchBundles,\n    refetchInterval: 5000,\n    refetchOnWindowFocus: true\n  })\n\n  const selectBundle = async (bundleName: string) => {\n    if (selectedBundle === bundleName) {\n      setSelectedBundle(null)\n    } else {\n      setSelectedBundle(bundleName)\n    }\n  }\n\n  // Get which bundles a file belongs to\n  const getFileBundles = (filePath: string) => {\n    return bundles.filter(bundle => bundle.files.includes(filePath)).map(b => b.name)\n  }\n\n  // Helper function to get icon for file type\n  const getFileIcon = (fileName: string) => {\n    const ext = fileName.split('.').pop()?.toLowerCase()\n    switch (ext) {\n      case 'tsx':\n      case 'jsx':\n        return <Code className=\"w-3 h-3 text-blue-500\" />\n      case 'ts':\n      case 'js':\n        return <FileText className=\"w-3 h-3 text-yellow-500\" />\n      case 'json':\n        return <Settings className=\"w-3 h-3 text-green-500\" />\n      case 'md':\n        return <BookOpen className=\"w-3 h-3 text-purple-500\" />\n      case 'css':\n      case 'scss':\n        return <FileText className=\"w-3 h-3 text-pink-500\" />\n      case 'html':\n        return <FileText className=\"w-3 h-3 text-orange-500\" />\n      case 'sh':\n        return <FileText className=\"w-3 h-3 text-gray-500\" />\n      default:\n        return <FileText className=\"w-3 h-3 text-gray-400\" />\n    }\n  }\n\n\n  // File picker functions\n  const toggleEditMode = async (bundleName: string) => {\n    const newEditing = new Set(editingBundles)\n    if (newEditing.has(bundleName)) {\n      newEditing.delete(bundleName)\n    } else {\n      newEditing.add(bundleName)\n      // Always fetch fresh available files when entering edit mode\n      try {\n        const files = await fetchAllFiles()\n        setAvailableFiles(files)\n      } catch (error) {\n        console.error('Failed to fetch files:', error)\n        toast.error('Failed to load file list')\n      }\n    }\n    setEditingBundles(newEditing)\n  }\n\n  const isFileInBundle = (fileName: string, bundle: Bundle) => {\n    return bundle.files.includes(fileName)\n  }\n\n  const getFileExclusions = (fileName: string, currentBundle: string): string[] => {\n    if (!bundles || !Array.isArray(bundles)) return []\n    return bundles\n      .filter((b: Bundle) => b.name !== currentBundle && b.files.includes(fileName))\n      .map((b: Bundle) => b.name)\n  }\n\n  const removeFileFromBundle = async (fileName: string, bundleName: string) => {\n    try {\n      setButtonState(`remove-${bundleName}-${fileName}`, 'loading')\n\n      console.log(`Removing ${fileName} from ${bundleName}`)\n\n      // Prevent modifications to master bundle\n      if (bundleName === 'master') {\n        setButtonState(`remove-${bundleName}-${fileName}`, 'error')\n        toast.error('Cannot modify master bundle files')\n        return\n      }\n\n      // Get current configuration\n      const configResponse = await fetch('http://localhost:3333/api/config')\n      if (!configResponse.ok) {\n        throw new Error('Failed to fetch current configuration')\n      }\n      \n      const currentConfig = await configResponse.json()\n      \n      // Remove the file from the bundle's patterns (not hide it!)\n      if (currentConfig.bundles[bundleName]) {\n        currentConfig.bundles[bundleName] = currentConfig.bundles[bundleName].filter(\n          (pattern: string) => pattern !== fileName\n        )\n        console.log(`Removed ${fileName} from ${bundleName} patterns`)\n      }\n\n      // Update the configuration\n      const updateResponse = await fetch('http://localhost:3333/api/config', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(currentConfig)\n      })\n\n      if (!updateResponse.ok) {\n        const errorText = await updateResponse.text()\n        console.error('API Error:', errorText)\n        throw new Error(`Failed to update configuration: ${errorText}`)\n      }\n\n      // Force refresh the bundles query to get the updated data\n      queryClient.invalidateQueries({ queryKey: ['bundles'] })\n\n      setButtonState(`remove-${bundleName}-${fileName}`, 'success')\n      toast.success(`Removed ${fileName} from ${bundleName} bundle`)\n\n    } catch (error) {\n      console.error('Failed to remove file:', error)\n      setButtonState(`remove-${bundleName}-${fileName}`, 'error')\n      toast.error(`Failed to remove file: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  const addFileToBundle = async (fileName: string, bundleName: string) => {\n    try {\n      setButtonState(`add-${bundleName}-${fileName}`, 'loading')\n\n      // Prevent modifications to master bundle\n      if (bundleName === 'master') {\n        setButtonState(`add-${bundleName}-${fileName}`, 'error')\n        toast.error('Cannot modify master bundle files')\n        return\n      }\n\n      // First, get the current configuration\n      const configResponse = await fetch('http://localhost:3333/api/config')\n      if (!configResponse.ok) {\n        throw new Error('Failed to fetch current configuration')\n      }\n      \n      const currentConfig = await configResponse.json()\n      \n      // Add the file to the bundle's patterns\n      if (!currentConfig.bundles[bundleName]) {\n        currentConfig.bundles[bundleName] = []\n      }\n      \n      // Add the exact file path if it's not already there\n      if (!currentConfig.bundles[bundleName].includes(fileName)) {\n        currentConfig.bundles[bundleName].push(fileName)\n      }\n\n      // Update the configuration\n      const updateResponse = await fetch('http://localhost:3333/api/config', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(currentConfig)\n      })\n\n      if (!updateResponse.ok) {\n        const errorText = await updateResponse.text()\n        throw new Error(`Failed to update configuration: ${errorText}`)\n      }\n\n      // Remove the file from the bundle's hidden list\n      await fetch('http://localhost:3333/api/hidden-files', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          action: 'toggle',\n          filePath: fileName,\n          bundleName: bundleName,\n          forceHide: false\n        })\n      })\n\n      // Force refresh the bundles query to get the updated data\n      queryClient.invalidateQueries({ queryKey: ['bundles'] })\n\n      setButtonState(`add-${bundleName}-${fileName}`, 'success')\n      toast.success(`Added ${fileName} to ${bundleName} bundle`)\n\n      // Refresh undercategorized files if they're currently being shown\n      if (showFileAnalysis) {\n        await loadFileAnalysis()\n      }\n\n    } catch (error) {\n      console.error('Failed to add file:', error)\n      setButtonState(`add-${bundleName}-${fileName}`, 'error')\n      toast.error(`Failed to add file: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  const setButtonState = (key: string, state: 'loading' | 'success' | 'error' | 'idle') => {\n    setLoadingButtons(prev => {\n      const newSet = new Set(prev)\n      if (state === 'loading') newSet.add(key)\n      else newSet.delete(key)\n      return newSet\n    })\n\n    setSuccessButtons(prev => {\n      const newSet = new Set(prev)\n      if (state === 'success') {\n        newSet.add(key)\n        // Auto-clear success state after 2 seconds\n        setTimeout(() => setSuccessButtons(current => {\n          const updated = new Set(current)\n          updated.delete(key)\n          return updated\n        }), 2000)\n      } else {\n        newSet.delete(key)\n      }\n      return newSet\n    })\n\n    setErrorButtons(prev => {\n      const newSet = new Set(prev)\n      if (state === 'error') {\n        newSet.add(key)\n        // Auto-clear error state after 3 seconds\n        setTimeout(() => setErrorButtons(current => {\n          const updated = new Set(current)\n          updated.delete(key)\n          return updated\n        }), 3000)\n      } else {\n        newSet.delete(key)\n      }\n      return newSet\n    })\n  }\n\n  const copyBundle = async (bundleName: string) => {\n    const key = `copy-${bundleName}`\n    setButtonState(key, 'loading')\n\n    try {\n      const response = await fetch(`http://localhost:3333/api/bundles/${bundleName}`)\n      if (!response.ok) throw new Error('Failed to fetch bundle content')\n\n      const content = await response.text()\n      await navigator.clipboard.writeText(content)\n\n      setButtonState(key, 'success')\n      toast.success(`Bundle \"${bundleName}\" copied to clipboard!`)\n    } catch (error) {\n      setButtonState(key, 'error')\n      toast.error(`Failed to copy bundle: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  const downloadBundle = async (bundleName: string) => {\n    const key = `download-${bundleName}`\n    setButtonState(key, 'loading')\n\n    try {\n      const response = await fetch(`http://localhost:3333/api/bundles/${bundleName}`)\n      if (!response.ok) throw new Error('Failed to fetch bundle content')\n\n      const content = await response.text()\n      const blob = new Blob([content], { type: 'application/xml' })\n      const url = URL.createObjectURL(blob)\n      const a = document.createElement('a')\n      a.href = url\n      a.download = `${bundleName}-bundle.xml`\n      a.click()\n      URL.revokeObjectURL(url)\n\n      setButtonState(key, 'success')\n      toast.success(`Bundle \"${bundleName}\" downloaded!`)\n    } catch (error) {\n      setButtonState(key, 'error')\n      toast.error(`Failed to download bundle: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  const regenerateBundle = async (bundleName: string) => {\n    const key = `regen-${bundleName}`\n    setButtonState(key, 'loading')\n\n    try {\n      const response = await fetch(`http://localhost:3333/api/regenerate/${bundleName}`, {\n        method: 'POST'\n      })\n      if (!response.ok) throw new Error('Failed to regenerate bundle')\n\n      await refetch()\n      setButtonState(key, 'success')\n      toast.success(`Bundle \"${bundleName}\" regenerated successfully!`)\n    } catch (error) {\n      setButtonState(key, 'error')\n      toast.error(`Failed to regenerate bundle: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  if (isLoading) return <div>Loading bundles...</div>\n  if (!bundles) return <div>No bundles found</div>\n\n  const loadFileAnalysis = async () => {\n    try {\n      const undercategorized = await fetchUndercategorizedFiles()\n      setUndercategorizedFiles(undercategorized)\n      \n      console.log('Found undercategorized files:', { \n        total: undercategorized.length,\n        files: undercategorized.map(f => ({ path: f.path, bundles: f.bundles }))\n      })\n    } catch (error) {\n      console.error('Failed to fetch file analysis:', error)\n      toast.error('Failed to load file analysis')\n    }\n  }\n\n  const suggestCategoryImprovement = async (filePath: string, suggestedCategory: string) => {\n    const key = `categorize-${filePath}`\n    setButtonState(key, 'loading')\n    \n    try {\n      // For now, we'll just show a success message and suggest the user report this to improve the backend\n      // In a real implementation, this would send category suggestions to the backend for ML training\n      toast.success(`Category suggestion recorded: ${filePath} → ${suggestedCategory}`)\n      \n      // TODO: Implement actual backend endpoint for category suggestions\n      // const response = await fetch('http://localhost:3333/api/suggest-category', {\n      //   method: 'POST',\n      //   headers: { 'Content-Type': 'application/json' },\n      //   body: JSON.stringify({ filePath, suggestedCategory })\n      // })\n      \n      setButtonState(key, 'success')\n    } catch (error) {\n      console.error('Failed to suggest category:', error)\n      setButtonState(key, 'error')\n      toast.error('Failed to record category suggestion')\n    }\n  }\n\n  const manualRefresh = async () => {\n    console.log('Manual refresh triggered')\n    queryClient.removeQueries({ queryKey: ['bundles'] })\n    const result = await refetch()\n    console.log('Fresh bundles data:', result.data)\n    \n    // Also refresh file analysis\n    if (showFileAnalysis) {\n      await loadFileAnalysis()\n    }\n  }\n\n  // Bundle Grid Card Component\n  const BundleGridCard = ({ bundle }: { bundle: Bundle }) => {\n    const copyKey = `copy-${bundle.name}`\n    const downloadKey = `download-${bundle.name}`\n    const regenKey = `regen-${bundle.name}`\n    const isCopyLoading = loadingButtons.has(copyKey)\n    const isDownloadLoading = loadingButtons.has(downloadKey)\n    const isRegenLoading = loadingButtons.has(regenKey)\n    const isCopySuccess = successButtons.has(copyKey)\n    const isDownloadSuccess = successButtons.has(downloadKey)\n    const isRegenSuccess = successButtons.has(regenKey)\n    const isCopyError = errorButtons.has(copyKey)\n    const isDownloadError = errorButtons.has(downloadKey)\n    const isRegenError = errorButtons.has(regenKey)\n    const isSelected = selectedBundle === bundle.name\n    \n    // Check if bundle has files needing bundle assignment (files only in master bundle)\n    const fileBundles = bundle.files.map(file => getFileBundles(file))\n    const hasUnassignedFiles = fileBundles.some(bundles => bundles.length === 1 && bundles[0] === 'master')\n\n    return (\n      <Card \n        className={`cursor-pointer transition-all hover:shadow-md ${\n          bundle.changed ? 'border-warning' : ''\n        } ${isSelected ? 'ring-2 ring-primary border-primary' : ''}`}\n        onClick={() => selectBundle(bundle.name)}\n      >\n        <CardHeader className=\"pb-2\">\n          <div className=\"space-y-1.5\">\n            <h3 className=\"text-sm font-medium truncate\">{bundle.name}</h3>\n            <Badge variant={bundle.changed ? 'destructive' : 'secondary'} className=\"text-xs font-normal h-4 w-fit\">\n              {bundle.changed ? 'CHANGED' : 'SYNCED'}\n            </Badge>\n          </div>\n        </CardHeader>\n        <CardContent className=\"pt-0\">\n          <div className=\"space-y-2\">\n            <div className=\"text-xs text-muted-foreground\">\n              <div className=\"flex flex-wrap gap-x-2 gap-y-1 items-center\">\n                <span>{bundle.fileCount} files</span>\n                <span>•</span>\n                <span>{(bundle.size / 1024).toFixed(1)}kb</span>\n                {hasUnassignedFiles && (\n                  <>\n                    <span>•</span>\n                    <span className=\"text-warning text-xs\">\n                      <AlertTriangle className=\"w-2.5 h-2.5 inline mr-1\" />\n                      Files need assignment\n                    </span>\n                  </>\n                )}\n              </div>\n            </div>\n            \n            <div className=\"flex\" onClick={(e) => e.stopPropagation()}>\n              <div className=\"inline-flex rounded-md border border-input bg-background shadow-sm\">\n                <Button\n                  variant=\"ghost\"\n                  size=\"sm\"\n                  onClick={() => regenerateBundle(bundle.name)}\n                  disabled={isRegenLoading}\n                  className=\"h-6 px-1.5 rounded-none border-r border-input first:rounded-l-md last:rounded-r-md hover:bg-accent\"\n                >\n                  {isRegenLoading ? (\n                    <Loader2 className=\"w-2.5 h-2.5 animate-spin\" />\n                  ) : isRegenSuccess ? (\n                    <CheckCircle className=\"w-2.5 h-2.5\" />\n                  ) : isRegenError ? (\n                    <AlertCircle className=\"w-2.5 h-2.5\" />\n                  ) : (\n                    <RefreshCw className=\"w-2.5 h-2.5\" />\n                  )}\n                </Button>\n                <Button\n                  variant=\"ghost\"\n                  size=\"sm\"\n                  onClick={() => copyBundle(bundle.name)}\n                  disabled={isCopyLoading}\n                  className=\"h-6 px-1.5 rounded-none border-r border-input first:rounded-l-md last:rounded-r-md hover:bg-accent\"\n                >\n                  {isCopyLoading ? (\n                    <Loader2 className=\"w-2.5 h-2.5 animate-spin\" />\n                  ) : isCopySuccess ? (\n                    <CheckCircle className=\"w-2.5 h-2.5\" />\n                  ) : isCopyError ? (\n                    <AlertCircle className=\"w-2.5 h-2.5\" />\n                  ) : (\n                    <Copy className=\"w-2.5 h-2.5\" />\n                  )}\n                </Button>\n                <Button\n                  variant=\"ghost\"\n                  size=\"sm\"\n                  onClick={() => downloadBundle(bundle.name)}\n                  disabled={isDownloadLoading}\n                  className=\"h-6 px-1.5 rounded-none first:rounded-l-md last:rounded-r-md hover:bg-accent\"\n                >\n                  {isDownloadLoading ? (\n                    <Loader2 className=\"w-2.5 h-2.5 animate-spin\" />\n                  ) : isDownloadSuccess ? (\n                    <CheckCircle className=\"w-2.5 h-2.5\" />\n                  ) : isDownloadError ? (\n                    <AlertCircle className=\"w-2.5 h-2.5\" />\n                  ) : (\n                    <Download className=\"w-2.5 h-2.5\" />\n                  )}\n                </Button>\n              </div>\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n    )\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex justify-between items-center\">\n        <div className=\"flex items-center gap-4\">\n          <h2 className=\"text-lg font-semibold\">Bundles</h2>\n          {undercategorizedFiles.length > 0 && (\n            <Badge variant=\"outline\" className=\"bg-warning/10 text-warning border-warning/20\">\n              <AlertTriangle className=\"w-3 h-3 mr-1\" />\n              {undercategorizedFiles.length} files need better bundle assignment\n            </Badge>\n          )}\n        </div>\n        <div className=\"flex gap-2\">\n          <Button\n            onClick={async () => {\n              if (!showFileAnalysis) {\n                await loadFileAnalysis()\n              }\n              setShowFileAnalysis(!showFileAnalysis)\n            }}\n            variant={showFileAnalysis ? \"default\" : \"outline\"}\n            size=\"sm\"\n          >\n            <Search className=\"w-4 h-4 mr-1\" />\n            {showFileAnalysis ? 'Hide' : 'Analyze'} File Bundle Assignment\n          </Button>\n          <Button onClick={manualRefresh} variant=\"outline\" size=\"sm\">\n            <RefreshCw className=\"w-4 h-4 mr-1\" />\n            Force Refresh\n          </Button>\n        </div>\n      </div>\n      \n      {/* File Bundle Assignment Analysis Section */}\n      {showFileAnalysis && (\n        <Card className=\"border-warning/20 bg-warning/5\">\n          <CardHeader>\n            <CardTitle className=\"flex items-center gap-2 text-warning\">\n              <AlertTriangle className=\"w-4 h-4\" />\n              File Bundle Assignment Analysis\n            </CardTitle>\n            <p className=\"text-sm text-muted-foreground\">\n              Files that need better bundle assignment. All files belong to the 'master' bundle by default, but should also belong to more specific bundles.\n            </p>\n          </CardHeader>\n          <CardContent>\n            {undercategorizedFiles.length === 0 ? (\n              <div className=\"text-center py-8 text-muted-foreground\">\n                <CheckCircle className=\"w-8 h-8 mx-auto mb-2 text-[color:var(--color-success)]\" />\n                <p>Excellent! All files are properly assigned to specific bundles.</p>\n                <p className=\"text-sm\">No files are sitting in only the master bundle.</p>\n              </div>\n            ) : (\n              <div className=\"space-y-4\">\n                <div className=\"space-y-3\">\n                  <h4 className=\"font-medium text-warning flex items-center gap-2\">\n                    <AlertTriangle className=\"w-4 h-4\" />\n                    Files Needing Bundle Assignment ({undercategorizedFiles.length})\n                  </h4>\n                  <p className=\"text-sm text-muted-foreground\">\n                    These files are only in the 'master' bundle and should be assigned to more specific bundles for better organization.\n                  </p>\n                  <div className=\"space-y-2 max-h-60 overflow-y-auto\">\n                    {undercategorizedFiles.map((fileInfo) => {\n                      const suggestions = suggestBundleForFile(fileInfo.path)\n                      const currentBundleText = fileInfo.bundles.length === 0 ? 'none' : fileInfo.bundles.join(', ')\n                      \n                      return (\n                        <div key={fileInfo.path} className=\"flex items-center gap-2 p-3 rounded border border-warning/20 bg-background\">\n                          <div className=\"flex-1 min-w-0\">\n                            <div className=\"font-mono text-sm text-foreground truncate\">\n                              {fileInfo.path}\n                            </div>\n                            <div className=\"flex items-center gap-2 mt-1\">\n                              <span className=\"text-xs text-muted-foreground\">\n                                Currently in: {currentBundleText === 'master' ? 'master only' : currentBundleText}\n                              </span>\n                              {suggestions.length > 0 && (\n                                <div className=\"flex items-center gap-1\">\n                                  <span className=\"text-xs text-muted-foreground\">Suggested:</span>\n                                  {suggestions.slice(0, 2).map((bundle) => (\n                                    <Badge key={bundle} variant=\"outline\" className=\"text-xs px-1 py-0\">\n                                      {bundle}\n                                    </Badge>\n                                  ))}\n                                </div>\n                              )}\n                            </div>\n                          </div>\n                          <div className=\"flex gap-1 flex-shrink-0\">\n                            <Button\n                              variant=\"outline\"\n                              size=\"sm\"\n                              onClick={() => {\n                                // Hide this file globally (add to ignore patterns)\n                                fetch('http://localhost:3333/api/hidden-files', {\n                                  method: 'POST',\n                                  headers: { 'Content-Type': 'application/json' },\n                                  body: JSON.stringify({\n                                    action: 'toggle',\n                                    filePath: fileInfo.path,\n                                    forceHide: true\n                                  })\n                                }).then(() => {\n                                  toast.success(`Hidden ${fileInfo.path} from all bundles`)\n                                  loadFileAnalysis() // Refresh the analysis\n                                }).catch(error => {\n                                  console.error('Failed to hide file:', error)\n                                  toast.error('Failed to hide file')\n                                })\n                              }}\n                              className=\"h-6 px-2 text-xs border-muted hover:bg-muted\"\n                            >\n                              Ignore\n                            </Button>\n                            {(suggestions.length > 0 ? suggestions.slice(0, 2) : bundles.filter(b => b.name !== 'master').slice(0, 2)).map((bundleName) => (\n                              <Button\n                                key={bundleName}\n                                variant=\"outline\"\n                                size=\"sm\"\n                                onClick={() => addFileToBundle(fileInfo.path, bundleName)}\n                                className=\"h-6 px-2 text-xs\"\n                              >\n                                Add to {bundleName}\n                              </Button>\n                            ))}\n                          </div>\n                        </div>\n                      )\n                    })}\n                  </div>\n                </div>\n\n                <div className=\"flex justify-between items-center pt-2 border-t border-warning/20\">\n                  <span className=\"text-sm text-muted-foreground\">\n                    {undercategorizedFiles.length} files need better bundle assignment\n                  </span>\n                  <Button\n                    variant=\"outline\"\n                    size=\"sm\"\n                    onClick={loadFileAnalysis}\n                  >\n                    <RefreshCw className=\"w-3 h-3 mr-1\" />\n                    Refresh Analysis\n                  </Button>\n                </div>\n              </div>\n            )}\n          </CardContent>\n        </Card>\n      )}\n      \n      {/* Responsive Layout */}\n      <div className=\"flex flex-col lg:flex-row gap-6\">\n        {/* Bundle Grid */}\n        <div className={`${selectedBundle ? 'hidden lg:block lg:w-1/2' : 'w-full'} transition-all`}>\n          <div className={`grid grid-cols-1 gap-4 ${\n            selectedBundle \n              ? 'md:grid-cols-2' \n              : 'sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4'\n          }`}>\n            {bundles && Array.isArray(bundles) ? bundles.map((bundle) => (\n              <BundleGridCard key={bundle.name} bundle={bundle} />\n            )) : <div>No bundles available</div>}\n          </div>\n        </div>\n\n        {/* Detail Panel */}\n        {selectedBundle && (\n          <div className={`${selectedBundle ? 'block' : 'hidden'} ${\n            selectedBundle ? 'fixed inset-0 z-50 bg-background lg:relative lg:inset-auto lg:z-auto lg:w-1/2' : ''\n          } transition-all flex flex-col`}>\n            {/* Mobile Close Button */}\n            <div className=\"lg:hidden sticky top-0 bg-background border-b p-4 flex justify-between items-center flex-shrink-0\">\n              <h3 className=\"font-semibold\">Bundle Details</h3>\n              <Button \n                variant=\"ghost\" \n                size=\"sm\" \n                onClick={() => setSelectedBundle(null)}\n              >\n                <X className=\"w-4 h-4\" />\n              </Button>\n            </div>\n            \n            <div className=\"flex-1 overflow-y-auto p-4 lg:p-0\">\n              {(() => {\n                const bundle = bundles?.find((b: Bundle) => b.name === selectedBundle)\n                if (!bundle) return <div>Bundle not found</div>\n\n                return (\n                  <BundleDetailView \n                    bundle={bundle}\n                    bundles={bundles}\n                    selectedBundleName={selectedBundle}\n                    editingBundles={editingBundles}\n                    availableFiles={availableFiles}\n                    loadingButtons={loadingButtons}\n                    successButtons={successButtons}\n                    errorButtons={errorButtons}\n                    toggleEditMode={toggleEditMode}\n                    removeFileFromBundle={removeFileFromBundle}\n                    addFileToBundle={addFileToBundle}\n                    getFileBundles={getFileBundles}\n                    getFileIcon={getFileIcon}\n                    availableFilesSearch={availableFilesSearch}\n                    setAvailableFilesSearch={setAvailableFilesSearch}\n                  />\n                )\n              })()}\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  )\n}\n\n// Bundle Detail View Component\nconst BundleDetailView = ({ \n  bundle, \n  bundles,\n  selectedBundleName,\n  editingBundles, \n  availableFiles, \n  loadingButtons, \n  successButtons, \n  errorButtons,\n  toggleEditMode,\n  removeFileFromBundle,\n  addFileToBundle,\n  getFileBundles,\n  getFileIcon,\n  availableFilesSearch,\n  setAvailableFilesSearch\n}: {\n  bundle: Bundle\n  bundles: Bundle[]\n  selectedBundleName: string\n  editingBundles: Set<string>\n  availableFiles: string[]\n  loadingButtons: Set<string>\n  successButtons: Set<string>\n  errorButtons: Set<string>\n  toggleEditMode: (bundleName: string) => void\n  removeFileFromBundle: (fileName: string, bundleName: string) => void\n  addFileToBundle: (fileName: string, bundleName: string) => void\n  getFileBundles: (filePath: string) => string[]\n  getFileIcon: (fileName: string) => React.ReactNode\n  availableFilesSearch: string\n  setAvailableFilesSearch: (value: string) => void\n}) => {\n  // Get the most current bundle from bundles array to ensure we have latest file updates\n  const currentBundle = bundles?.find((b: Bundle) => b.name === selectedBundleName) || bundle\n  \n  return (\n    <Card>\n      <CardHeader className=\"pb-3\">\n        <div className=\"flex flex-col gap-2\">\n          <div className=\"flex items-center gap-2 min-w-0\">\n            <h3 className=\"text-sm font-medium truncate\">{bundle.name}</h3>\n            <Badge variant={bundle.changed ? 'destructive' : 'secondary'} className=\"text-xs font-normal\">\n              {bundle.changed ? 'CHANGED' : 'SYNCED'}\n            </Badge>\n          </div>\n          <div className=\"flex gap-1\">\n            <Button\n              variant=\"outline\"\n              size=\"sm\"\n              onClick={() => toggleEditMode(bundle.name)}\n              disabled={bundle.name === 'master'}\n              className={`h-7 text-xs ${editingBundles.has(bundle.name) ? 'bg-primary/10 border-primary/20' : ''}`}\n            >\n              {editingBundles.has(bundle.name) ? (\n                <X className=\"w-3 h-3\" />\n              ) : (\n                <Edit3 className=\"w-3 h-3\" />\n              )}\n            </Button>\n          </div>\n        </div>\n      </CardHeader>\n      <CardContent className=\"pt-0\">\n        <div className=\"text-xs text-muted-foreground mb-3\">\n          <div className=\"flex flex-wrap gap-x-2 gap-y-1 items-center\">\n            <span>{bundle.fileCount} files</span>\n            <span>•</span>\n            <span>{(bundle.size / 1024).toFixed(1)}kb</span>\n            {bundle.lastGenerated && (\n              <>\n                <span>•</span>\n                <span className=\"truncate max-w-[200px]\">\n                  Generated {new Date(bundle.lastGenerated).toLocaleTimeString()}\n                </span>\n              </>\n            )}\n          </div>\n        </div>\n\n        <div className=\"space-y-3\">\n          {/* Bundle Files */}\n          <div className=\"space-y-2\">\n            <div className=\"flex items-center gap-2 flex-wrap\">\n              <Badge variant=\"outline\" className=\"text-xs font-normal h-5\">\n                Files\n              </Badge>\n              <span className=\"text-xs text-muted-foreground\">\n                ({currentBundle.files.length} files)\n              </span>\n            </div>\n            <div className=\"space-y-1 max-h-64 overflow-y-auto\">\n              {editingBundles.has(bundle.name) ? (\n                // Edit mode: show files with remove buttons\n                currentBundle.files.map((file) => {\n                  const removeKey = `remove-${bundle.name}-${file}`\n                  const isLoading = loadingButtons.has(removeKey)\n                  const fileBundles = getFileBundles(file).filter(b => b !== bundle.name)\n                  const fileName = file.split('/').pop() || file\n                  return (\n                    <div key={file} className=\"flex items-center gap-2 py-0.5 px-1 hover:bg-muted/50 rounded-sm group\">\n                      <Button\n                        variant=\"ghost\"\n                        size=\"sm\"\n                        onClick={() => removeFileFromBundle(file, bundle.name)}\n                        disabled={isLoading || bundle.name === 'master'}\n                        className=\"h-4 w-4 p-0 opacity-0 group-hover:opacity-100 hover:bg-destructive/10 flex-shrink-0\"\n                      >\n                        {isLoading ? (\n                          <Loader2 className=\"w-2.5 h-2.5 animate-spin\" />\n                        ) : (\n                          <Minus className=\"w-2.5 h-2.5 text-destructive\" />\n                        )}\n                      </Button>\n                      <div className=\"flex items-center gap-1.5 flex-1 min-w-0\">\n                        <div className=\"flex-shrink-0\">{getFileIcon(file)}</div>\n                        <span className=\"text-xs text-foreground truncate font-normal\">{fileName}</span>\n                        {fileBundles.length > 0 && (\n                          <div className=\"flex gap-1 flex-wrap ml-auto\">\n                            {fileBundles.map(bundleName => (\n                              <Badge key={bundleName} variant=\"outline\" className=\"text-xs font-normal h-4 px-1.5\">\n                                {bundleName}\n                              </Badge>\n                            ))}\n                          </div>\n                        )}\n                      </div>\n                    </div>\n                  )\n                })\n              ) : (\n                // View mode: show files with bundle labels\n                currentBundle.files.map((file) => {\n                  const fileBundles = getFileBundles(file).filter(b => b !== bundle.name)\n                  const fileName = file.split('/').pop() || file\n                  return (\n                    <div key={file} className=\"flex items-center gap-1.5 py-0.5 px-1 hover:bg-muted/30 rounded-sm\">\n                      <div className=\"flex-shrink-0\">{getFileIcon(file)}</div>\n                      <span className=\"text-xs text-foreground truncate flex-1 font-normal\">{fileName}</span>\n                      {fileBundles.length > 0 && (\n                        <div className=\"flex gap-1 flex-wrap\">\n                          {fileBundles.map(bundleName => (\n                            <Badge key={bundleName} variant=\"outline\" className=\"text-xs font-normal h-4 px-1.5\">\n                              {bundleName}\n                            </Badge>\n                          ))}\n                        </div>\n                      )}\n                    </div>\n                  )\n                })\n              )}\n            </div>\n          </div>\n\n          {/* Available Files Section (Edit Mode Only) */}\n          {editingBundles.has(bundle.name) && (\n            <div className=\"space-y-2 mt-4 pt-3 border-t\">\n              <div className=\"flex items-center gap-2 flex-wrap\">\n                <Badge variant=\"outline\" className=\"bg-muted text-muted-foreground border-border text-xs font-normal h-5\">\n                  <Plus className=\"w-2.5 h-2.5 mr-1\" />\n                  Available Files\n                </Badge>\n                <span className=\"text-xs text-muted-foreground\">\n                  (Click + to add to bundle)\n                </span>\n              </div>\n              <div className=\"mb-2\">\n                <div className=\"relative\">\n                  <Search className=\"absolute left-2 top-1/2 transform -translate-y-1/2 text-muted-foreground w-3 h-3\" />\n                  <input\n                    type=\"text\"\n                    placeholder=\"Search files...\"\n                    value={availableFilesSearch}\n                    onChange={(e) => setAvailableFilesSearch(e.target.value)}\n                    className=\"w-full pl-7 pr-3 py-1 text-xs border border-input rounded-md bg-background text-foreground placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring\"\n                  />\n                </div>\n              </div>\n              <div className=\"space-y-1 max-h-40 overflow-y-auto\">\n                {availableFiles\n                  .filter(file => !currentBundle.files.includes(file))\n                  .filter(file => availableFilesSearch === '' || file.toLowerCase().includes(availableFilesSearch.toLowerCase()))\n                  .map((file) => {\n                    const addKey = `add-${currentBundle.name}-${file}`\n                    const isLoading = loadingButtons.has(addKey)\n                    const fileBundles = getFileBundles(file)\n                    const fileName = file.split('/').pop() || file\n                    return (\n                      <div key={file} className=\"flex items-center gap-2 py-0.5 px-1 hover:bg-muted/50 rounded-sm group\">\n                        <Button\n                          variant=\"ghost\"\n                          size=\"sm\"\n                          onClick={() => addFileToBundle(file, currentBundle.name)}\n                          disabled={isLoading}\n                          className=\"h-4 w-4 p-0 opacity-0 group-hover:opacity-100 hover:bg-primary/10 flex-shrink-0\"\n                        >\n                          {isLoading ? (\n                            <Loader2 className=\"w-2.5 h-2.5 animate-spin\" />\n                          ) : (\n                            <Plus className=\"w-2.5 h-2.5 text-primary\" />\n                          )}\n                        </Button>\n                        <div className=\"flex items-center gap-1.5 flex-1 min-w-0\">\n                          <div className=\"flex-shrink-0\">{getFileIcon(file)}</div>\n                          <span className=\"text-xs text-muted-foreground truncate font-normal\">{fileName}</span>\n                          {fileBundles.length > 0 && (\n                            <div className=\"flex gap-1 flex-wrap ml-auto\">\n                              {fileBundles.map(bundleName => (\n                                <Badge key={bundleName} variant=\"outline\" className=\"text-xs font-normal h-4 px-1.5\">\n                                  {bundleName}\n                                </Badge>\n                              ))}\n                            </div>\n                          )}\n                        </div>\n                      </div>\n                    )\n                  })\n                }\n              </div>\n            </div>\n          )}\n\n        </div>\n      </CardContent>\n    </Card>\n  )\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/CursorRulesManager.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"15371\" modified=\"2025-06-25T06:32:26.052Z\" lines=\"415\" />\n        <cntx:content><![CDATA[// Updated CursorRulesManager.tsx\nimport { useState, useEffect } from 'react'\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'\nimport { Card, CardHeader, CardTitle, CardContent } from './ui/card'\nimport { Button } from './ui/button'\nimport { Textarea } from './ui/textarea'\nimport { Alert, AlertDescription } from './ui/alert'\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from './ui/tabs'\nimport { Save, RefreshCw, Copy, Download, Upload, Sparkles, FileText, Info } from 'lucide-react'\nimport { useButtonFeedback } from '../hooks/useButtonFeedback'\nimport { getButtonIcon, getButtonClassName } from '../utils/buttonHelpers'\nimport { toast } from '@/lib/toast'\n\ninterface CursorRulesTemplates {\n  react: string\n  node: string\n  general: string\n}\n\nconst fetchCursorRules = async (): Promise<string> => {\n  const response = await fetch('http://localhost:3333/api/cursor-rules')\n  if (!response.ok) throw new Error('Failed to fetch cursor rules')\n  return response.text()\n}\n\nconst saveCursorRules = async (content: string): Promise<void> => {\n  const response = await fetch('http://localhost:3333/api/cursor-rules', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ content })\n  })\n  if (!response.ok) throw new Error('Failed to save cursor rules')\n}\n\nconst fetchTemplates = async (): Promise<CursorRulesTemplates> => {\n  const response = await fetch('http://localhost:3333/api/cursor-rules/templates')\n  if (!response.ok) throw new Error('Failed to fetch templates')\n  return response.json()\n}\n\nexport function CursorRulesManager() {\n  const queryClient = useQueryClient()\n  const [editingRules, setEditingRules] = useState<string>('')\n  const [selectedTemplate, setSelectedTemplate] = useState<string>('')\n\n  const { setButtonState, getButtonState, isLoading } = useButtonFeedback()\n\n  const { data: currentRules, isLoading: rulesLoading } = useQuery({\n    queryKey: ['cursor-rules'],\n    queryFn: fetchCursorRules\n  })\n\n  const { data: templates } = useQuery({\n    queryKey: ['cursor-templates'],\n    queryFn: fetchTemplates\n  })\n\n  const saveMutation = useMutation({\n    mutationFn: saveCursorRules,\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['cursor-rules'] })\n      setButtonState('save', 'success')\n      toast.success('Cursor rules saved successfully!')\n    },\n    onError: (error) => {\n      setButtonState('save', 'error')\n      toast.error(`Failed to save cursor rules: ${error.message}`)\n    }\n  })\n\n  useEffect(() => {\n    if (currentRules && !editingRules) {\n      setEditingRules(currentRules)\n    }\n  }, [currentRules])\n\n  const handleSave = () => {\n    if (editingRules) {\n      setButtonState('save', 'loading')\n      saveMutation.mutate(editingRules)\n    }\n  }\n\n  const handleReset = () => {\n    setEditingRules(currentRules || '')\n    toast.info('Reset to last saved version')\n  }\n\n  const handleLoadTemplate = (templateType: keyof CursorRulesTemplates) => {\n    if (templates && templates[templateType]) {\n      setEditingRules(templates[templateType])\n      setSelectedTemplate(templateType)\n      toast.success(`Loaded ${templateType} template`)\n    }\n  }\n\n  const copyToClipboard = async () => {\n    if (!editingRules) return\n\n    setButtonState('copy', 'loading')\n    try {\n      await navigator.clipboard.writeText(editingRules)\n      setButtonState('copy', 'success')\n      toast.success('Cursor rules copied to clipboard!')\n    } catch (error) {\n      setButtonState('copy', 'error')\n      toast.error('Failed to copy to clipboard')\n    }\n  }\n\n  const downloadRules = () => {\n    setButtonState('download', 'loading')\n    try {\n      const blob = new Blob([editingRules], { type: 'text/plain' })\n      const url = URL.createObjectURL(blob)\n      const a = document.createElement('a')\n      a.href = url\n      a.download = '.cursorrules'\n      a.click()\n      URL.revokeObjectURL(url)\n      setButtonState('download', 'success')\n      toast.success('Cursor rules downloaded!')\n    } catch (error) {\n      setButtonState('download', 'error')\n      toast.error('Failed to download file')\n    }\n  }\n\n  const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {\n    const file = event.target.files?.[0]\n    if (!file) return\n\n    setButtonState('upload', 'loading')\n    const reader = new FileReader()\n    reader.onload = (e) => {\n      const content = e.target?.result as string\n      setEditingRules(content)\n      setButtonState('upload', 'success')\n      toast.success('Cursor rules uploaded successfully!')\n    }\n    reader.onerror = () => {\n      setButtonState('upload', 'error')\n      toast.error('Failed to read file')\n    }\n    reader.readAsText(file)\n  }\n\n  if (rulesLoading) return <div>Loading cursor rules...</div>\n\n  const hasChanges = currentRules !== editingRules\n  const wordCount = editingRules.split(/\\s+/).filter(word => word.length > 0).length\n  const lineCount = editingRules.split('\\n').length\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Header */}\n      <div className=\"flex justify-between items-start\">\n        <div>\n          <h2 className=\"text-lg font-semibold flex items-center gap-2\">\n            <Sparkles className=\"w-5 h-5\" />\n            Cursor Rules Management\n          </h2>\n          <p className=\"text-sm text-muted-foreground\">\n            Configure AI assistant behavior and project context for Cursor IDE\n          </p>\n        </div>\n        <div className=\"flex gap-2\">\n          <Button\n            variant=\"outline\"\n            onClick={handleReset}\n            disabled={!hasChanges}\n          >\n            <RefreshCw className=\"w-4 h-4 mr-1\" />\n            Reset\n          </Button>\n          <Button\n            onClick={handleSave}\n            disabled={!hasChanges || isLoading('save')}\n            className={`bg-[color:var(--color-type-hooks)] hover:bg-[color:var(--color-type-hooks)]/80 ${getButtonClassName(getButtonState('save'))}`}\n          >\n            {getButtonIcon(getButtonState('save'), <Save className=\"w-4 h-4\" />)}\n            <span className=\"ml-1\">Save Rules</span>\n          </Button>\n        </div>\n      </div>\n\n      {/* Status Info */}\n      <Card>\n        <CardContent className=\"pt-6\">\n          <div className=\"flex items-center justify-between\">\n            <div className=\"flex items-center gap-4\">\n              <div className=\"flex items-center gap-2\">\n                <FileText className=\"w-4 h-4 text-muted-foreground\" />\n                <span className=\"text-sm text-muted-foreground\">\n                  {lineCount} lines • {wordCount} words\n                </span>\n              </div>\n              {currentRules && (\n                <div className=\"flex items-center gap-2\">\n                  <span className=\"text-sm text-[color:var(--color-success)]\">.cursorrules file exists</span>\n                </div>\n              )}\n            </div>\n            <div className=\"flex gap-2\">\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={copyToClipboard}\n                disabled={isLoading('copy')}\n                className={getButtonClassName(getButtonState('copy'))}\n              >\n                {getButtonIcon(getButtonState('copy'), <Copy className=\"w-4 h-4\" />)}\n                <span className=\"ml-1\">Copy</span>\n              </Button>\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={downloadRules}\n                disabled={isLoading('download')}\n                className={getButtonClassName(getButtonState('download'))}\n              >\n                {getButtonIcon(getButtonState('download'), <Download className=\"w-4 h-4\" />)}\n                <span className=\"ml-1\">Download</span>\n              </Button>\n              <label className=\"cursor-pointer\">\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  asChild\n                  className={getButtonClassName(getButtonState('upload'))}\n                >\n                  <span>\n                    {getButtonIcon(getButtonState('upload'), <Upload className=\"w-4 h-4\" />)}\n                    <span className=\"ml-1\">Upload</span>\n                  </span>\n                </Button>\n                <input\n                  type=\"file\"\n                  accept=\".cursorrules,.txt,.md\"\n                  onChange={handleFileUpload}\n                  className=\"hidden\"\n                />\n              </label>\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n\n      <Tabs defaultValue=\"editor\" className=\"space-y-6\">\n        <TabsList>\n          <TabsTrigger value=\"editor\">Rules Editor</TabsTrigger>\n          <TabsTrigger value=\"templates\">Templates</TabsTrigger>\n          <TabsTrigger value=\"help\">Help & Examples</TabsTrigger>\n        </TabsList>\n\n        <TabsContent value=\"editor\">\n          <Card>\n            <CardHeader>\n              <CardTitle>Edit Cursor Rules</CardTitle>\n            </CardHeader>\n            <CardContent className=\"space-y-4\">\n              {hasChanges && (\n                <Alert className=\"border-[color:var(--color-warning)]/20 bg-[color:var(--color-warning)]/5\">\n                  <Info className=\"w-4 h-4\" />\n                  <AlertDescription>\n                    You have unsaved changes. Click \"Save Rules\" to apply them to your .cursorrules file.\n                  </AlertDescription>\n                </Alert>\n              )}\n\n              <Textarea\n                value={editingRules}\n                onChange={(e) => setEditingRules(e.target.value)}\n                placeholder=\"Enter your cursor rules here...\"\n                className=\"min-h-96 font-mono text-sm\"\n              />\n\n              {selectedTemplate && (\n                <div className=\"flex items-center gap-2\">\n                  <span className=\"text-sm text-muted-foreground\">\n                    Template: {selectedTemplate}\n                  </span>\n                  <Button\n                    variant=\"ghost\"\n                    size=\"sm\"\n                    onClick={() => setSelectedTemplate('')}\n                  >\n                    Clear\n                  </Button>\n                </div>\n              )}\n            </CardContent>\n          </Card>\n        </TabsContent>\n\n        <TabsContent value=\"templates\">\n          <div className=\"space-y-4\">\n            <Card>\n              <CardHeader>\n                <CardTitle>Project Templates</CardTitle>\n              </CardHeader>\n              <CardContent>\n                <p className=\"text-sm text-muted-foreground mb-4\">\n                  Choose a template that matches your project type. You can customize it after loading.\n                </p>\n                <div className=\"grid gap-3\">\n                  <Button\n                    variant=\"outline\"\n                    onClick={() => handleLoadTemplate('react')}\n                    className=\"justify-start h-auto p-4\"\n                  >\n                    <div className=\"text-left\">\n                      <div className=\"font-medium\">React Application</div>\n                      <div className=\"text-sm text-muted-foreground\">\n                        Modern React with TypeScript, hooks, and Tailwind CSS\n                      </div>\n                    </div>\n                  </Button>\n\n                  <Button\n                    variant=\"outline\"\n                    onClick={() => handleLoadTemplate('node')}\n                    className=\"justify-start h-auto p-4\"\n                  >\n                    <div className=\"text-left\">\n                      <div className=\"font-medium\">Node.js Backend</div>\n                      <div className=\"text-sm text-muted-foreground\">\n                        Express/Fastify backend with ES modules and TypeScript\n                      </div>\n                    </div>\n                  </Button>\n\n                  <Button\n                    variant=\"outline\"\n                    onClick={() => handleLoadTemplate('general')}\n                    className=\"justify-start h-auto p-4\"\n                  >\n                    <div className=\"text-left\">\n                      <div className=\"font-medium\">General Project</div>\n                      <div className=\"text-sm text-muted-foreground\">\n                        Basic template for any type of project\n                      </div>\n                    </div>\n                  </Button>\n                </div>\n              </CardContent>\n            </Card>\n          </div>\n        </TabsContent>\n\n        <TabsContent value=\"help\">\n          <div className=\"space-y-4\">\n            <Card>\n              <CardHeader>\n                <CardTitle>What are Cursor Rules?</CardTitle>\n              </CardHeader>\n              <CardContent className=\"space-y-4\">\n                <p className=\"text-sm text-muted-foreground\">\n                  Cursor rules (.cursorrules) provide context and guidelines to AI assistants like Cursor IDE's AI.\n                  They help the AI understand your project structure, coding preferences, and best practices.\n                </p>\n\n                <div className=\"space-y-3\">\n                  <div>\n                    <h4 className=\"font-medium mb-2\">Best Practices</h4>\n                    <ul className=\"text-sm text-muted-foreground space-y-1 list-disc list-inside\">\n                      <li>Include project context and technology stack</li>\n                      <li>Specify coding standards and naming conventions</li>\n                      <li>Document file organization patterns</li>\n                      <li>Mention important dependencies and frameworks</li>\n                      <li>Include team preferences and architectural decisions</li>\n                    </ul>\n                  </div>\n\n                  <div>\n                    <h4 className=\"font-medium mb-2\">Example Sections</h4>\n                    <div className=\"bg-muted/50 p-3 rounded text-xs font-mono\">\n                      # Project Context<br />\n                      # Development Guidelines<br />\n                      # Code Style<br />\n                      # File Organization<br />\n                      # Bundle Context<br />\n                      # AI Assistant Instructions\n                    </div>\n                  </div>\n                </div>\n              </CardContent>\n            </Card>\n\n            <Card>\n              <CardHeader>\n                <CardTitle>Integration with cntx-ui</CardTitle>\n              </CardHeader>\n              <CardContent>\n                <p className=\"text-sm text-muted-foreground mb-3\">\n                  Your cursor rules automatically include information about your cntx-ui bundle configuration,\n                  helping AI assistants understand your project structure and file organization.\n                </p>\n\n                <Alert>\n                  <Sparkles className=\"w-4 h-4\" />\n                  <AlertDescription>\n                    When you change your bundle configuration, consider updating your cursor rules\n                    to reflect the new project structure and help AI assistants provide better suggestions.\n                  </AlertDescription>\n                </Alert>\n              </CardContent>\n            </Card>\n          </div>\n        </TabsContent>\n      </Tabs>\n    </div>\n  )\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/EnhancedBundleConfig.tsx\" ext=\".tsx\" role=\"configuration\">\n        <cntx:meta size=\"18186\" modified=\"2025-06-26T00:21:56.905Z\" lines=\"487\" />\n        <cntx:content><![CDATA[import { useState } from 'react'\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'\nimport { Card, CardHeader, CardTitle, CardContent } from './ui/card'\nimport { Button } from './ui/button'\nimport { Input } from './ui/input'\nimport { Badge } from './ui/badge'\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from './ui/tabs'\nimport { Plus, Trash2, Eye, CheckCircle2, Circle } from 'lucide-react'\nimport { toast } from '@/lib/toast'\n\ninterface BundleConfig {\n  bundles: Record<string, string[]>\n}\n\ninterface ProjectFile {\n  path: string\n  type: string\n  size: number\n}\n\nconst fetchConfig = async (): Promise<BundleConfig> => {\n  const response = await fetch('http://localhost:3333/api/config')\n  if (!response.ok) throw new Error('Failed to fetch config')\n  return response.json()\n}\n\nconst saveConfig = async (config: BundleConfig): Promise<void> => {\n  const response = await fetch('http://localhost:3333/api/config', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(config)\n  })\n  if (!response.ok) throw new Error('Failed to save config')\n}\n\nconst fetchProjectFiles = async (): Promise<ProjectFile[]> => {\n  const response = await fetch('http://localhost:3333/api/files')\n  if (!response.ok) throw new Error('Failed to fetch files')\n  return response.json()\n}\n\nconst testPattern = async (pattern: string): Promise<string[]> => {\n  const response = await fetch('http://localhost:3333/api/test-pattern', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ pattern })\n  })\n  if (!response.ok) throw new Error('Failed to test pattern')\n  return response.json()\n}\n\nexport function EnhancedBundleConfig() {\n  const queryClient = useQueryClient()\n  const [editingBundle, setEditingBundle] = useState<string | null>(null)\n  const [showCreateBundle, setShowCreateBundle] = useState(false)\n  const [createBundleStep, setCreateBundleStep] = useState<'name' | 'files' | 'patterns'>('name')\n  \n  // Bundle creation state\n  const [newBundleName, setNewBundleName] = useState('')\n  const [selectedFiles, setSelectedFiles] = useState<Set<string>>(new Set())\n  const [generatedPatterns, setGeneratedPatterns] = useState<string[]>([])\n  const [lastSelectedIndex, setLastSelectedIndex] = useState<number>(-1)\n  \n  // Pattern testing\n  const [testingPattern, setTestingPattern] = useState('')\n  const [testResults, setTestResults] = useState<string[]>([])\n\n  const { data: config, isLoading: configLoading } = useQuery({\n    queryKey: ['config'],\n    queryFn: fetchConfig\n  })\n\n  const { data: projectFiles, isLoading: filesLoading } = useQuery({\n    queryKey: ['project-files'],\n    queryFn: fetchProjectFiles\n  })\n\n  const saveMutation = useMutation({\n    mutationFn: saveConfig,\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['config'] })\n      queryClient.invalidateQueries({ queryKey: ['bundles'] })\n      setEditingBundle(null)\n      setShowCreateBundle(false)\n      setNewBundleName('')\n      setSelectedFiles(new Set())\n      setGeneratedPatterns([])\n      setCreateBundleStep('name')\n      toast.success('Bundle configuration saved!')\n    },\n    onError: (error) => {\n      toast.error(`Failed to save: ${error.message}`)\n    }\n  })\n\n  // Generate patterns from selected files\n  const generatePatternsFromFiles = (files: string[]) => {\n    const patterns: string[] = []\n    const directories = new Set<string>()\n    \n    files.forEach(file => {\n      const dir = file.split('/').slice(0, -1).join('/')\n      if (dir) directories.add(dir)\n    })\n    \n    // Create patterns for common directory structures\n    directories.forEach(dir => {\n      const filesInDir = files.filter(f => f.startsWith(dir + '/'))\n      if (filesInDir.length > 1) {\n        patterns.push(`${dir}/**/*`)\n      }\n    })\n    \n    // Add individual files that don't fit patterns\n    files.forEach(file => {\n      const matchedByPattern = patterns.some(pattern => {\n        const regex = new RegExp(pattern.replace(/\\*\\*/g, '.*').replace(/\\*/g, '[^/]*'))\n        return regex.test(file)\n      })\n      if (!matchedByPattern) {\n        patterns.push(file)\n      }\n    })\n    \n    return patterns.length > 0 ? patterns : files\n  }\n\n  const handleCreateBundle = () => {\n    if (!config || !newBundleName.trim()) return\n    \n    const patterns = generatedPatterns.length > 0 ? generatedPatterns : Array.from(selectedFiles)\n    \n    const updatedConfig = {\n      ...config,\n      bundles: {\n        ...config.bundles,\n        [newBundleName]: patterns\n      }\n    }\n    \n    saveMutation.mutate(updatedConfig)\n  }\n\n  const handleDeleteBundle = (bundleName: string) => {\n    if (!config) return\n    \n    const { [bundleName]: deleted, ...remainingBundles } = config.bundles\n    const updatedConfig = {\n      ...config,\n      bundles: remainingBundles\n    }\n    \n    saveMutation.mutate(updatedConfig)\n  }\n\n  const handlePatternChange = (bundleName: string, patterns: string[]) => {\n    if (!config) return\n    \n    const updatedConfig = {\n      ...config,\n      bundles: {\n        ...config.bundles,\n        [bundleName]: patterns\n      }\n    }\n    \n    saveMutation.mutate(updatedConfig)\n  }\n\n  const handleTestPattern = async () => {\n    if (!testingPattern.trim()) return\n    \n    try {\n      const results = await testPattern(testingPattern)\n      setTestResults(results)\n    } catch (error) {\n      toast.error('Failed to test pattern')\n    }\n  }\n\n  const handleFileSelection = (filePath: string, index: number, event?: React.MouseEvent) => {\n    const newSelected = new Set(selectedFiles)\n    \n    // Handle shift+click for range selection\n    if (event?.shiftKey && lastSelectedIndex >= 0 && projectFiles) {\n      const startIndex = Math.min(lastSelectedIndex, index)\n      const endIndex = Math.max(lastSelectedIndex, index)\n      \n      for (let i = startIndex; i <= endIndex; i++) {\n        if (projectFiles[i]) {\n          newSelected.add(projectFiles[i].path)\n        }\n      }\n    } else {\n      // Normal click - toggle selection\n      if (newSelected.has(filePath)) {\n        newSelected.delete(filePath)\n      } else {\n        newSelected.add(filePath)\n      }\n    }\n    \n    setSelectedFiles(newSelected)\n    setLastSelectedIndex(index)\n    \n    // Auto-generate patterns when files are selected\n    if (newSelected.size > 0) {\n      const patterns = generatePatternsFromFiles(Array.from(newSelected))\n      setGeneratedPatterns(patterns)\n    } else {\n      setGeneratedPatterns([])\n    }\n  }\n\n  if (configLoading || filesLoading) {\n    return <div className=\"p-4\">Loading...</div>\n  }\n\n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle className=\"flex items-center justify-between text-sm font-medium\">\n          Bundle Configuration\n          <Button\n            onClick={() => setShowCreateBundle(true)}\n            size=\"sm\"\n            className=\"h-7 text-xs\"\n          >\n            <Plus className=\"w-3 h-3 mr-1\" />\n            Create Bundle\n          </Button>\n        </CardTitle>\n      </CardHeader>\n      <CardContent className=\"space-y-6\">\n        {/* Create Bundle Modal */}\n        {showCreateBundle && (\n          <Card className=\"border-2 border-[color:var(--color-info)]/20 bg-[color:var(--color-info)]/5\">\n            <CardHeader>\n              <CardTitle className=\"text-sm font-medium\">Create New Bundle</CardTitle>\n            </CardHeader>\n            <CardContent>\n              <Tabs value={createBundleStep} onValueChange={(value) => setCreateBundleStep(value as any)}>\n                <TabsList className=\"grid w-full grid-cols-3\">\n                  <TabsTrigger value=\"name\">1. Name</TabsTrigger>\n                  <TabsTrigger value=\"files\" disabled={!newBundleName.trim()}>2. Select Files</TabsTrigger>\n                  <TabsTrigger value=\"patterns\" disabled={selectedFiles.size === 0}>3. Review</TabsTrigger>\n                </TabsList>\n\n                <TabsContent value=\"name\" className=\"space-y-4\">\n                  <div>\n                    <label className=\"text-xs font-medium\">Bundle Name</label>\n                    <Input\n                      placeholder=\"e.g., frontend, api, components\"\n                      value={newBundleName}\n                      onChange={(e) => setNewBundleName(e.target.value)}\n                    />\n                  </div>\n                  <Button \n                    onClick={() => setCreateBundleStep('files')}\n                    disabled={!newBundleName.trim()}\n                    size=\"sm\"\n                    className=\"h-7 text-xs\"\n                  >\n                    Next: Select Files\n                  </Button>\n                </TabsContent>\n\n                <TabsContent value=\"files\" className=\"space-y-4\">\n                  <div>\n                    <div className=\"flex items-center justify-between mb-3\">\n                      <label className=\"text-xs font-medium\">Select Files for \"{newBundleName}\"</label>\n                      <Badge variant=\"outline\">{selectedFiles.size} selected</Badge>\n                    </div>\n                    \n                    <div className=\"text-xs text-muted-foreground mb-2\">\n                      Click to select files. Hold Shift and click to select ranges.\n                    </div>\n                    \n                    <div className=\"max-h-64 overflow-y-auto border rounded-lg p-3 space-y-1\">\n                      {projectFiles?.map((file, index) => (\n                        <div\n                          key={file.path}\n                          className=\"flex items-center gap-2 p-2 hover:bg-muted/50 rounded cursor-pointer select-none\"\n                          onClick={(e) => handleFileSelection(file.path, index, e)}\n                        >\n                          {selectedFiles.has(file.path) ? (\n                            <CheckCircle2 className=\"w-4 h-4 text-[color:var(--color-info)]\" />\n                          ) : (\n                            <Circle className=\"w-4 h-4 text-muted-foreground\" />\n                          )}\n                          <span className=\"text-xs font-mono flex-1\">{file.path}</span>\n                          <Badge variant=\"outline\" className=\"text-xs\">{file.type}</Badge>\n                        </div>\n                      ))}\n                    </div>\n                  </div>\n                  \n                  <div className=\"flex gap-2\">\n                    <Button variant=\"outline\" size=\"sm\" className=\"h-7 text-xs\" onClick={() => setCreateBundleStep('name')}>\n                      Back\n                    </Button>\n                    <Button \n                      onClick={() => setCreateBundleStep('patterns')}\n                      disabled={selectedFiles.size === 0}\n                      size=\"sm\"\n                      className=\"h-7 text-xs\"\n                    >\n                      Next: Review Patterns\n                    </Button>\n                  </div>\n                </TabsContent>\n\n                <TabsContent value=\"patterns\" className=\"space-y-4\">\n                  <div>\n                    <label className=\"text-xs font-medium\">Generated Patterns</label>\n                    <div className=\"space-y-2 mt-2\">\n                      {generatedPatterns.map((pattern, index) => (\n                        <div key={index} className=\"flex gap-2\">\n                          <Input\n                            value={pattern}\n                            onChange={(e) => {\n                              const newPatterns = [...generatedPatterns]\n                              newPatterns[index] = e.target.value\n                              setGeneratedPatterns(newPatterns)\n                            }}\n                            className=\"font-mono text-sm\"\n                          />\n                          <Button\n                            variant=\"outline\"\n                            size=\"sm\"\n                            onClick={() => {\n                              const newPatterns = generatedPatterns.filter((_, i) => i !== index)\n                              setGeneratedPatterns(newPatterns)\n                            }}\n                          >\n                            <Trash2 className=\"w-4 h-4\" />\n                          </Button>\n                        </div>\n                      ))}\n                      <Button\n                        variant=\"outline\"\n                        size=\"sm\"\n                        onClick={() => setGeneratedPatterns([...generatedPatterns, '**/*'])}\n                      >\n                        <Plus className=\"w-4 h-4 mr-1\" />\n                        Add Pattern\n                      </Button>\n                    </div>\n                  </div>\n\n                  <div className=\"flex gap-2\">\n                    <Button variant=\"outline\" size=\"sm\" className=\"h-7 text-xs\" onClick={() => setCreateBundleStep('files')}>\n                      Back\n                    </Button>\n                    <Button variant=\"outline\" size=\"sm\" className=\"h-7 text-xs\" onClick={() => setShowCreateBundle(false)}>\n                      Cancel\n                    </Button>\n                    <Button onClick={handleCreateBundle} disabled={saveMutation.isPending} size=\"sm\" className=\"h-7 text-xs\">\n                      Create Bundle\n                    </Button>\n                  </div>\n                </TabsContent>\n              </Tabs>\n            </CardContent>\n          </Card>\n        )}\n\n        {/* Existing Bundles */}\n        <div className=\"space-y-4\">\n          {config && Object.entries(config.bundles).map(([bundleName, patterns]) => (\n            <div key={bundleName} className=\"border rounded-lg p-4\">\n              <div className=\"flex items-center justify-between mb-3\">\n                <h3 className=\"text-sm font-medium\">{bundleName}</h3>\n                <div className=\"flex gap-2\">\n                  <Button\n                    variant=\"outline\"\n                    size=\"sm\"\n                    className=\"h-7 text-xs\"\n                    onClick={() => setEditingBundle(editingBundle === bundleName ? null : bundleName)}\n                  >\n                    {editingBundle === bundleName ? 'Done' : 'Edit'}\n                  </Button>\n                  {bundleName !== 'master' && (\n                    <Button\n                      variant=\"outline\"\n                      size=\"sm\"\n                      className=\"h-7 text-xs\"\n                      onClick={() => handleDeleteBundle(bundleName)}\n                    >\n                      <Trash2 className=\"w-3 h-3\" />\n                    </Button>\n                  )}\n                </div>\n              </div>\n              \n              {editingBundle === bundleName ? (\n                <div className=\"space-y-2\">\n                  {patterns.map((pattern, index) => (\n                    <div key={index} className=\"flex gap-2\">\n                      <Input\n                        value={pattern}\n                        onChange={(e) => {\n                          const newPatterns = [...patterns]\n                          newPatterns[index] = e.target.value\n                          handlePatternChange(bundleName, newPatterns)\n                        }}\n                        placeholder=\"e.g., src/**/*.ts\"\n                        className=\"font-mono text-sm\"\n                      />\n                      {patterns.length > 1 && (\n                        <Button\n                          variant=\"outline\"\n                          size=\"sm\"\n                          onClick={() => {\n                            const newPatterns = patterns.filter((_, i) => i !== index)\n                            handlePatternChange(bundleName, newPatterns)\n                          }}\n                        >\n                          <Trash2 className=\"w-4 h-4\" />\n                        </Button>\n                      )}\n                    </div>\n                  ))}\n                  <Button\n                    variant=\"outline\"\n                    size=\"sm\"\n                    onClick={() => handlePatternChange(bundleName, [...patterns, '**/*'])}\n                  >\n                    <Plus className=\"w-4 h-4 mr-1\" />\n                    Add Pattern\n                  </Button>\n                </div>\n              ) : (\n                <div className=\"flex flex-wrap gap-1\">\n                  {patterns.map((pattern, index) => (\n                    <Badge key={index} variant=\"secondary\" className=\"font-mono text-xs\">\n                      {pattern}\n                    </Badge>\n                  ))}\n                </div>\n              )}\n            </div>\n          ))}\n        </div>\n\n        {/* Pattern Tester */}\n        <Card>\n          <CardHeader>\n            <CardTitle className=\"text-sm font-medium\">Test a Pattern</CardTitle>\n          </CardHeader>\n          <CardContent className=\"space-y-3\">\n            <div className=\"flex gap-2\">\n              <Input\n                placeholder=\"e.g., src/**/*.ts\"\n                value={testingPattern}\n                onChange={(e) => setTestingPattern(e.target.value)}\n                className=\"font-mono\"\n              />\n              <Button onClick={handleTestPattern} size=\"sm\" className=\"h-7 text-xs\">\n                <Eye className=\"w-3 h-3 mr-1\" />\n                Test\n              </Button>\n            </div>\n            \n            {testResults.length > 0 && (\n              <div className=\"mt-3\">\n                <p className=\"text-sm text-muted-foreground mb-2\">\n                  Found {testResults.length} files:\n                </p>\n                <div className=\"max-h-32 overflow-y-auto text-xs space-y-1 bg-muted/50 p-2 rounded font-mono\">\n                  {testResults.slice(0, 20).map((file, index) => (\n                    <div key={index}>{file}</div>\n                  ))}\n                  {testResults.length > 20 && (\n                    <div className=\"text-muted-foreground\">\n                      ... and {testResults.length - 20} more files\n                    </div>\n                  )}\n                </div>\n              </div>\n            )}\n          </CardContent>\n        </Card>\n      </CardContent>\n    </Card>\n  )\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/FileTree.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"8780\" modified=\"2025-06-26T00:21:27.205Z\" lines=\"309\" />\n        <cntx:content><![CDATA[import { useQuery } from '@tanstack/react-query'\nimport { useState } from 'react'\nimport { ChevronDown, ChevronRight, File, Folder, FolderOpen } from 'lucide-react'\nimport { Button } from './ui/button'\nimport { Badge } from './ui/badge'\nimport { Card } from './ui/card'\n\ninterface FileNode {\n  name: string\n  path: string\n  type: 'file' | 'directory'\n  size?: number\n  children?: FileNode[]\n  bundles?: string[]\n}\n\ninterface Bundle {\n  name: string\n  files: string[]\n}\n\nconst fetchBundles = async (): Promise<Bundle[]> => {\n  const response = await fetch('http://localhost:3333/api/bundles')\n  if (!response.ok) throw new Error('Failed to fetch bundles')\n  return response.json()\n}\n\nconst buildFileTree = (bundles: Bundle[]): FileNode => {\n  const root: FileNode = { name: '', path: '', type: 'directory', children: [] }\n  const allFiles = new Set<string>()\n  const fileBundleMap = new Map<string, string[]>()\n\n  // Collect all files and their bundle associations\n  bundles.forEach(bundle => {\n    bundle.files.forEach(file => {\n      allFiles.add(file)\n      if (!fileBundleMap.has(file)) {\n        fileBundleMap.set(file, [])\n      }\n      fileBundleMap.get(file)!.push(bundle.name)\n    })\n  })\n\n  // Build tree structure\n  allFiles.forEach(filePath => {\n    const parts = filePath.split('/')\n    let current = root\n\n    parts.forEach((part, index) => {\n      const isFile = index === parts.length - 1\n      const currentPath = parts.slice(0, index + 1).join('/')\n\n      if (!current.children) current.children = []\n\n      let existing = current.children.find(child => child.name === part)\n\n      if (!existing) {\n        existing = {\n          name: part,\n          path: currentPath,\n          type: isFile ? 'file' : 'directory',\n          children: isFile ? undefined : [],\n          bundles: isFile ? fileBundleMap.get(filePath) : undefined\n        }\n        current.children.push(existing)\n      }\n\n      if (!isFile) {\n        current = existing\n      }\n    })\n  })\n\n  // Sort: directories first, then files, alphabetically\n  const sortChildren = (node: FileNode) => {\n    if (node.children) {\n      node.children.sort((a, b) => {\n        if (a.type !== b.type) {\n          return a.type === 'directory' ? -1 : 1\n        }\n        return a.name.localeCompare(b.name)\n      })\n      node.children.forEach(sortChildren)\n    }\n  }\n\n  sortChildren(root)\n  return root\n}\n\nconst formatFileSize = (bytes: number): string => {\n  if (bytes === 0) return '0 B'\n  const k = 1024\n  const sizes = ['B', 'KB', 'MB', 'GB']\n  const i = Math.floor(Math.log(bytes) / Math.log(k))\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i]\n}\n\ninterface FileTreeNodeProps {\n  node: FileNode\n  level: number\n  expandedDirs: Set<string>\n  onToggleDir: (path: string) => void\n}\n\nfunction FileTreeNode({ node, level, expandedDirs, onToggleDir }: FileTreeNodeProps) {\n  const isExpanded = expandedDirs.has(node.path)\n  const indent = level * 16\n\n  if (node.type === 'directory') {\n    return (\n      <div>\n        <div\n          className=\"flex items-center gap-2 py-1 px-2 hover:bg-muted/50 rounded cursor-pointer\"\n          style={{ paddingLeft: `${indent + 8}px` }}\n          onClick={() => onToggleDir(node.path)}\n        >\n          {isExpanded ? (\n            <ChevronDown className=\"w-4 h-4 text-muted-foreground\" />\n          ) : (\n            <ChevronRight className=\"w-4 h-4 text-muted-foreground\" />\n          )}\n          {isExpanded ? (\n            <FolderOpen className=\"w-4 h-4 text-[color:var(--color-info)]\" />\n          ) : (\n            <Folder className=\"w-4 h-4 text-[color:var(--color-info)]\" />\n          )}\n          <span className=\"text-xs font-normal\">{node.name}</span>\n          {node.children && (\n            <span className=\"text-xs text-muted-foreground ml-auto\">\n              {node.children.length} items\n            </span>\n          )}\n        </div>\n\n        {isExpanded && node.children && (\n          <div>\n            {node.children.map((child) => (\n              <FileTreeNode\n                key={child.path}\n                node={child}\n                level={level + 1}\n                expandedDirs={expandedDirs}\n                onToggleDir={onToggleDir}\n              />\n            ))}\n          </div>\n        )}\n      </div>\n    )\n  }\n\n  // File node\n  const getFileIcon = (filename: string) => {\n    const ext = filename.split('.').pop()?.toLowerCase()\n    const iconClass = \"w-4 h-4\"\n\n    switch (ext) {\n      case 'js':\n      case 'ts':\n      case 'jsx':\n      case 'tsx':\n        return <File className={`${iconClass} text-[color:var(--color-warning)]`} />\n      case 'json':\n        return <File className={`${iconClass} text-[color:var(--color-success)]`} />\n      case 'md':\n        return <File className={`${iconClass} text-[color:var(--color-info)]/80`} />\n      case 'css':\n      case 'scss':\n        return <File className={`${iconClass} text-[color:var(--color-type-styles)]`} />\n      case 'html':\n        return <File className={`${iconClass} text-[color:var(--color-type-configuration)]`} />\n      default:\n        return <File className={`${iconClass} text-muted-foreground`} />\n    }\n  }\n\n  return (\n    <div\n      className=\"flex items-center gap-2 py-1 px-2 hover:bg-muted/50 rounded\"\n      style={{ paddingLeft: `${indent + 24}px` }}\n    >\n      {getFileIcon(node.name)}\n      <span className=\"text-xs font-mono\">{node.name}</span>\n\n      {node.bundles && node.bundles.length > 0 && (\n        <div className=\"flex gap-1 ml-2\">\n          {node.bundles.map(bundle => (\n            <Badge\n              key={bundle}\n              variant=\"outline\"\n              className=\"text-xs px-1 py-0 h-4\"\n            >\n              {bundle}\n            </Badge>\n          ))}\n        </div>\n      )}\n\n      {node.size && (\n        <span className=\"text-xs text-muted-foreground ml-auto\">\n          {formatFileSize(node.size)}\n        </span>\n      )}\n    </div>\n  )\n}\n\nexport function FileTree() {\n  const [expandedDirs, setExpandedDirs] = useState<Set<string>>(new Set(['']))\n  // wtf is this shit broseph? \n  // const [showUnbundled, setShowUnbundled] = useState(false)\n\n  const { data: bundles, isLoading } = useQuery({\n    queryKey: ['bundles'],\n    queryFn: fetchBundles,\n    refetchInterval: 5000,\n  })\n\n  const handleToggleDir = (path: string) => {\n    const newExpanded = new Set(expandedDirs)\n    if (newExpanded.has(path)) {\n      newExpanded.delete(path)\n    } else {\n      newExpanded.add(path)\n    }\n    setExpandedDirs(newExpanded)\n  }\n\n  const expandAll = () => {\n    if (!bundles) return\n    const tree = buildFileTree(bundles)\n    const allDirs = new Set<string>()\n\n    const collectDirs = (node: FileNode) => {\n      if (node.type === 'directory') {\n        allDirs.add(node.path)\n        node.children?.forEach(collectDirs)\n      }\n    }\n\n    collectDirs(tree)\n    setExpandedDirs(allDirs)\n  }\n\n  const collapseAll = () => {\n    setExpandedDirs(new Set(['']))\n  }\n\n  if (isLoading) return <div>Loading file tree...</div>\n  if (!bundles) return <div>No bundles found</div>\n\n  const tree = buildFileTree(bundles)\n  const totalFiles = bundles.reduce((acc, bundle) => acc + bundle.files.length, 0)\n\n  return (\n    <div className=\"space-y-4\">\n      {/* Controls */}\n      <div className=\"flex items-center justify-between\">\n        <div className=\"flex gap-1\">\n          <Button variant=\"outline\" size=\"sm\" className=\"h-7 text-xs\" onClick={expandAll}>\n            Expand All\n          </Button>\n          <Button variant=\"outline\" size=\"sm\" className=\"h-7 text-xs\" onClick={collapseAll}>\n            Collapse All\n          </Button>\n        </div>\n\n        <div className=\"text-xs text-muted-foreground font-normal\">\n          {totalFiles} files tracked\n        </div>\n      </div>\n\n      {/* File Tree */}\n      <Card className=\"p-4\">\n        <div className=\"space-y-1 max-h-96 overflow-y-auto\">\n          {tree.children && tree.children.length > 0 ? (\n            tree.children.map((child) => (\n              <FileTreeNode\n                key={child.path}\n                node={child}\n                level={0}\n                expandedDirs={expandedDirs}\n                onToggleDir={handleToggleDir}\n              />\n            ))\n          ) : (\n            <div className=\"text-center text-muted-foreground py-8\">\n              No files found\n            </div>\n          )}\n        </div>\n      </Card>\n\n      {/* Bundle Legend */}\n      <Card className=\"p-4\">\n        <h3 className=\"text-xs font-medium mb-2\">Bundle Legend</h3>\n        <div className=\"flex flex-wrap gap-2\">\n          {bundles.map(bundle => (\n            <Badge key={bundle.name} variant=\"outline\">\n              {bundle.name} ({bundle.files.length})\n            </Badge>\n          ))}\n        </div>\n      </Card>\n    </div>\n  )\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/HiddenFilesManager.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"25917\" modified=\"2025-06-26T00:23:43.363Z\" lines=\"673\" />\n        <cntx:content><![CDATA[import { useState } from 'react'\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'\nimport { Card, CardHeader, CardTitle, CardContent } from './ui/card'\nimport { Button } from './ui/button'\nimport { Input } from './ui/input'\nimport { Badge } from './ui/badge'\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from './ui/tabs'\nimport {\n  Eye,\n  EyeOff,\n  Search,\n  Plus,\n  Trash2,\n  RotateCcw,\n  FileText,\n  Settings,\n  AlertCircle,\n  CheckCircle,\n  Info,\n} from 'lucide-react'\nimport { toast } from '@/lib/toast'\n\ninterface FileWithVisibility {\n  path: string\n  size: number\n  modified: string\n  visible: boolean\n  globallyHidden: boolean\n  bundleHidden: boolean\n  inBundles: string[]\n  matchesIgnorePattern: boolean\n}\n\ninterface IgnorePattern {\n  pattern: string\n  active: boolean\n}\n\ninterface IgnorePatterns {\n  system: IgnorePattern[]\n  user: IgnorePattern[]\n  file: IgnorePattern[]\n}\n\ninterface BundleStats {\n  total: number\n  visible: number\n  hidden: number\n  patterns: string[]\n}\n\n// API functions\nconst fetchFilesWithVisibility = async (bundleName: string | null = null): Promise<FileWithVisibility[]> => {\n  const url = bundleName\n    ? `http://localhost:3333/api/files-with-visibility?bundle=${bundleName}`\n    : 'http://localhost:3333/api/files-with-visibility'\n  const response = await fetch(url)\n  if (!response.ok) throw new Error('Failed to fetch files')\n  return response.json()\n}\n\nconst fetchIgnorePatterns = async (): Promise<IgnorePatterns> => {\n  const response = await fetch('http://localhost:3333/api/ignore-patterns')\n  if (!response.ok) throw new Error('Failed to fetch ignore patterns')\n  return response.json()\n}\n\nconst fetchBundleVisibilityStats = async (): Promise<Record<string, BundleStats>> => {\n  const response = await fetch('http://localhost:3333/api/bundle-visibility-stats')\n  if (!response.ok) throw new Error('Failed to fetch bundle stats')\n  return response.json()\n}\n\nconst toggleFileVisibility = async ({ filePath, bundleName = null, forceHide = null }: {\n  filePath: string\n  bundleName?: string | null\n  forceHide?: boolean | null\n}) => {\n  const response = await fetch('http://localhost:3333/api/hidden-files', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      action: 'toggle',\n      filePath,\n      bundleName,\n      forceHide\n    })\n  })\n  if (!response.ok) throw new Error('Failed to toggle file visibility')\n  return response.json()\n}\n\nconst bulkToggleVisibility = async ({ filePaths, bundleName = null, forceHide }: {\n  filePaths: string[]\n  bundleName?: string | null\n  forceHide: boolean\n}) => {\n  const response = await fetch('http://localhost:3333/api/hidden-files', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      action: 'bulk-toggle',\n      filePaths,\n      bundleName,\n      forceHide\n    })\n  })\n  if (!response.ok) throw new Error('Failed to bulk toggle visibility')\n  return response.json()\n}\n\nconst manageIgnorePattern = async ({ action, pattern }: {\n  action: 'add' | 'remove' | 'toggle-system'\n  pattern: string\n}) => {\n  const response = await fetch('http://localhost:3333/api/ignore-patterns', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ action, pattern })\n  })\n  if (!response.ok) throw new Error('Failed to manage ignore pattern')\n  return response.json()\n}\n\nconst resetHiddenFiles = async ({ scope, bundleName = null }: {\n  scope: 'global' | 'bundle' | 'all'\n  bundleName?: string | null\n}) => {\n  const response = await fetch('http://localhost:3333/api/reset-hidden-files', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ scope, bundleName })\n  })\n  if (!response.ok) throw new Error('Failed to reset hidden files')\n  return response.json()\n}\n\nexport function HiddenFilesManager() {\n  const queryClient = useQueryClient()\n  const [selectedBundle, setSelectedBundle] = useState<string | null>(null)\n  const [searchTerm, setSearchTerm] = useState('')\n  const [showHidden, setShowHidden] = useState(false)\n  const [filterBy, setFilterBy] = useState('all') // all, hidden, visible\n  const [newPattern, setNewPattern] = useState('')\n  const [selectedFiles, setSelectedFiles] = useState<string[]>([])\n\n  // Queries\n  const { data: files = [], isLoading: filesLoading } = useQuery({\n    queryKey: ['files-with-visibility', selectedBundle],\n    queryFn: () => fetchFilesWithVisibility(selectedBundle),\n    refetchInterval: 5000\n  })\n\n  const { data: ignorePatterns = { system: [], user: [], file: [] }, isLoading: patternsLoading } = useQuery({\n    queryKey: ['ignore-patterns'],\n    queryFn: fetchIgnorePatterns,\n    refetchInterval: 10000\n  })\n\n  const { data: bundleStats = {}, isLoading: statsLoading } = useQuery({\n    queryKey: ['bundle-visibility-stats'],\n    queryFn: fetchBundleVisibilityStats,\n    refetchInterval: 5000\n  })\n\n  // Mutations\n  const toggleFileMutation = useMutation({\n    mutationFn: toggleFileVisibility,\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['files-with-visibility'] })\n      queryClient.invalidateQueries({ queryKey: ['bundle-visibility-stats'] })\n      queryClient.invalidateQueries({ queryKey: ['bundles'] })\n      toast.success('File visibility updated')\n    },\n    onError: (error: Error) => toast.error(`Failed to update file visibility: ${error.message}`)\n  })\n\n  const bulkToggleMutation = useMutation({\n    mutationFn: bulkToggleVisibility,\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['files-with-visibility'] })\n      queryClient.invalidateQueries({ queryKey: ['bundle-visibility-stats'] })\n      queryClient.invalidateQueries({ queryKey: ['bundles'] })\n      setSelectedFiles([])\n      toast.success('Bulk visibility update completed')\n    },\n    onError: (error: Error) => toast.error(`Failed to bulk update visibility: ${error.message}`)\n  })\n\n  const patternMutation = useMutation({\n    mutationFn: manageIgnorePattern,\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['ignore-patterns'] })\n      queryClient.invalidateQueries({ queryKey: ['files-with-visibility'] })\n      queryClient.invalidateQueries({ queryKey: ['bundles'] })\n      toast.success('Ignore pattern updated')\n    },\n    onError: (error: Error) => toast.error(`Failed to update ignore pattern: ${error.message}`)\n  })\n\n  const resetMutation = useMutation({\n    mutationFn: resetHiddenFiles,\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['files-with-visibility'] })\n      queryClient.invalidateQueries({ queryKey: ['bundle-visibility-stats'] })\n      queryClient.invalidateQueries({ queryKey: ['bundles'] })\n      toast.success('Hidden files reset successfully')\n    },\n    onError: (error: Error) => toast.error(`Failed to reset hidden files: ${error.message}`)\n  })\n\n  // Filter files\n  const filteredFiles = files.filter(file => {\n    const matchesSearch = file.path.toLowerCase().includes(searchTerm.toLowerCase())\n    const matchesVisibility = filterBy === 'all' ||\n      (filterBy === 'hidden' && !file.visible) ||\n      (filterBy === 'visible' && file.visible)\n    const shouldShow = showHidden || file.visible\n\n    return matchesSearch && matchesVisibility && shouldShow\n  })\n\n  // Handlers\n  const handleToggleFile = (filePath: string) => {\n    toggleFileMutation.mutate({ filePath, bundleName: selectedBundle })\n  }\n\n  const handleBulkToggle = (forceHide: boolean) => {\n    bulkToggleMutation.mutate({\n      filePaths: selectedFiles,\n      bundleName: selectedBundle,\n      forceHide\n    })\n  }\n\n  const handleAddPattern = () => {\n    if (newPattern.trim()) {\n      patternMutation.mutate({ action: 'add', pattern: newPattern.trim() })\n      setNewPattern('')\n    }\n  }\n\n  const handleTogglePattern = (pattern: string, isSystem = false) => {\n    const action = isSystem ? 'toggle-system' : 'remove'\n    patternMutation.mutate({ action, pattern })\n  }\n\n  const allPatterns = [\n    ...(ignorePatterns.system || []).map(p => ({ ...p, source: 'system' as const })),\n    ...(ignorePatterns.user || []).map(p => ({ ...p, source: 'user' as const })),\n    ...(ignorePatterns.file || []).map(p => ({ ...p, source: 'file' as const }))\n  ]\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Header */}\n      <div className=\"flex justify-between items-center\">\n        <div>\n          <h2 className=\"text-sm font-medium\">File Visibility & Ignore Management</h2>\n          <p className=\"text-xs text-muted-foreground font-normal\">\n            Control which files appear in bundles and manage ignore patterns\n          </p>\n        </div>\n        <div className=\"flex items-center gap-2\">\n          <Badge variant=\"outline\" className=\"flex items-center gap-1\">\n            <Eye className=\"w-3 h-3\" />\n            {filteredFiles.filter(f => f.visible).length} visible\n          </Badge>\n          <Badge variant=\"outline\" className=\"flex items-center gap-1\">\n            <EyeOff className=\"w-3 h-3\" />\n            {filteredFiles.filter(f => !f.visible).length} hidden\n          </Badge>\n        </div>\n      </div>\n\n      <Tabs defaultValue=\"files\" className=\"space-y-6\">\n        <TabsList>\n          <TabsTrigger value=\"files\">File Visibility</TabsTrigger>\n          <TabsTrigger value=\"patterns\">Ignore Patterns</TabsTrigger>\n          <TabsTrigger value=\"bundles\">Bundle Overview</TabsTrigger>\n        </TabsList>\n\n        {/* File Visibility Tab */}\n        <TabsContent value=\"files\" className=\"space-y-4\">\n          {/* Bundle Selector */}\n          <Card>\n            <CardContent className=\"pt-6\">\n              <div className=\"flex items-center gap-4 mb-4\">\n                <div className=\"flex items-center gap-2\">\n                  <label className=\"text-xs font-medium\">Bundle:</label>\n                  <select\n                    value={selectedBundle || ''}\n                    onChange={(e) => setSelectedBundle(e.target.value || null)}\n                    className=\"px-2 py-1 border rounded-md text-xs\"\n                  >\n                    <option value=\"\">All Bundles (Global)</option>\n                    {Object.keys(bundleStats).map(bundleName => (\n                      <option key={bundleName} value={bundleName}>{bundleName}</option>\n                    ))}\n                  </select>\n                </div>\n\n                {selectedBundle && (\n                  <Badge variant=\"secondary\">\n                    Bundle-specific visibility for {selectedBundle}\n                  </Badge>\n                )}\n              </div>\n\n              <div className=\"flex items-center gap-4\">\n                <div className=\"flex-1\">\n                  <div className=\"relative\">\n                    <Search className=\"absolute left-2 top-2.5 h-4 w-4 text-muted-foreground\" />\n                    <Input\n                      placeholder=\"Search files...\"\n                      value={searchTerm}\n                      onChange={(e) => setSearchTerm(e.target.value)}\n                      className=\"pl-8\"\n                    />\n                  </div>\n                </div>\n\n                <div className=\"flex items-center gap-2\">\n                  <Button\n                    variant=\"outline\"\n                    size=\"sm\"\n                    className={`h-7 text-xs ${showHidden ? 'bg-[color:var(--color-info)]/5 border-[color:var(--color-info)]/20' : ''}`}\n                    onClick={() => setShowHidden(!showHidden)}\n                  >\n                    {showHidden ? <Eye className=\"w-3 h-3\" /> : <EyeOff className=\"w-3 h-3\" />}\n                    {showHidden ? 'Hide Hidden' : 'Show Hidden'}\n                  </Button>\n\n                  <select\n                    value={filterBy}\n                    onChange={(e) => setFilterBy(e.target.value)}\n                    className=\"px-2 py-1 border rounded-md text-xs\"\n                  >\n                    <option value=\"all\">All Files</option>\n                    <option value=\"visible\">Visible Only</option>\n                    <option value=\"hidden\">Hidden Only</option>\n                  </select>\n                </div>\n              </div>\n\n              {/* Bulk Actions */}\n              {selectedFiles.length > 0 && (\n                <div className=\"flex items-center gap-2 p-3 bg-[color:var(--color-info)]/5 rounded-md border border-[color:var(--color-info)]/20 mt-4\">\n                  <Info className=\"w-4 h-4 text-[color:var(--color-info)]\" />\n                  <span className=\"text-xs text-[color:var(--color-info)] font-normal\">\n                    {selectedFiles.length} files selected\n                  </span>\n                  <div className=\"flex gap-2 ml-auto\">\n                    <Button size=\"sm\" className=\"h-7 text-xs\" onClick={() => handleBulkToggle(false)}>\n                      <Eye className=\"w-3 h-3 mr-1\" />\n                      Show All\n                    </Button>\n                    <Button size=\"sm\" className=\"h-7 text-xs\" variant=\"outline\" onClick={() => handleBulkToggle(true)}>\n                      <EyeOff className=\"w-3 h-3 mr-1\" />\n                      Hide All\n                    </Button>\n                    <Button\n                      size=\"sm\"\n                      className=\"h-7 text-xs\"\n                      variant=\"ghost\"\n                      onClick={() => setSelectedFiles([])}\n                    >\n                      Cancel\n                    </Button>\n                  </div>\n                </div>\n              )}\n            </CardContent>\n          </Card>\n\n          {/* File List */}\n          <Card>\n            <CardContent className=\"pt-6\">\n              {filesLoading ? (\n                <div className=\"text-center py-8\">Loading files...</div>\n              ) : (\n                <div className=\"space-y-2 max-h-96 overflow-y-auto\">\n                  {filteredFiles.map((file) => (\n                    <div\n                      key={file.path}\n                      className={`flex items-center gap-3 p-2 rounded-md border transition-colors ${!file.visible ? 'opacity-60 bg-muted/50' : 'hover:bg-muted/50'\n                        }`}\n                    >\n                      <input\n                        type=\"checkbox\"\n                        checked={selectedFiles.includes(file.path)}\n                        onChange={(e) => {\n                          if (e.target.checked) {\n                            setSelectedFiles([...selectedFiles, file.path])\n                          } else {\n                            setSelectedFiles(selectedFiles.filter(f => f !== file.path))\n                          }\n                        }}\n                        className=\"rounded\"\n                      />\n\n                      <FileText className=\"w-4 h-4 text-muted-foreground flex-shrink-0\" />\n\n                      <div className=\"flex-1 min-w-0\">\n                        <div className=\"font-mono text-xs truncate\">{file.path}</div>\n                        <div className=\"flex items-center gap-2 mt-1\">\n                          {file.inBundles.map(bundle => (\n                            <Badge key={bundle} variant=\"outline\" className=\"text-xs\">\n                              {bundle}\n                            </Badge>\n                          ))}\n                          {file.globallyHidden && (\n                            <Badge variant=\"destructive\" className=\"text-xs\">\n                              Globally Hidden\n                            </Badge>\n                          )}\n                          {file.bundleHidden && selectedBundle && (\n                            <Badge variant=\"secondary\" className=\"text-xs\">\n                              Hidden in {selectedBundle}\n                            </Badge>\n                          )}\n                          {file.matchesIgnorePattern && (\n                            <Badge variant=\"outline\" className=\"text-xs text-muted-foreground\">\n                              Ignored\n                            </Badge>\n                          )}\n                        </div>\n                      </div>\n\n                      <div className=\"text-xs text-muted-foreground\">\n                        {(file.size / 1024).toFixed(1)}kb\n                      </div>\n\n                      <Button\n                        size=\"sm\"\n                        variant=\"ghost\"\n                        onClick={() => handleToggleFile(file.path)}\n                        disabled={toggleFileMutation.isPending}\n                        className=\"flex-shrink-0\"\n                      >\n                        {file.visible ? (\n                          <>\n                            <EyeOff className=\"w-3 h-3 mr-1\" />\n                            Hide\n                          </>\n                        ) : (\n                          <>\n                            <Eye className=\"w-3 h-3 mr-1\" />\n                            Show\n                          </>\n                        )}\n                      </Button>\n                    </div>\n                  ))}\n                </div>\n              )}\n\n              {filteredFiles.length === 0 && !filesLoading && (\n                <div className=\"text-center py-8 text-muted-foreground\">\n                  No files match your current filters\n                </div>\n              )}\n            </CardContent>\n          </Card>\n\n          {/* Reset Options */}\n          <Card>\n            <CardHeader>\n              <CardTitle className=\"flex items-center gap-2 text-sm font-medium\">\n                <RotateCcw className=\"w-4 h-4\" />\n                Reset Options\n              </CardTitle>\n            </CardHeader>\n            <CardContent className=\"space-y-3\">\n              <div className=\"flex gap-2\">\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  className=\"h-7 text-xs\"\n                  onClick={() => resetMutation.mutate({ scope: 'global' })}\n                  disabled={resetMutation.isPending}\n                >\n                  Reset Global Hidden Files\n                </Button>\n\n                {selectedBundle && (\n                  <Button\n                    variant=\"outline\"\n                    size=\"sm\"\n                    onClick={() => resetMutation.mutate({ scope: 'bundle', bundleName: selectedBundle })}\n                    disabled={resetMutation.isPending}\n                  >\n                    Reset {selectedBundle} Bundle\n                  </Button>\n                )}\n\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  onClick={() => resetMutation.mutate({ scope: 'all' })}\n                  disabled={resetMutation.isPending}\n                  className=\"text-destructive border-destructive/20 hover:bg-destructive/5\"\n                >\n                  Reset All Hidden Files\n                </Button>\n              </div>\n            </CardContent>\n          </Card>\n        </TabsContent>\n\n        {/* Ignore Patterns Tab */}\n        <TabsContent value=\"patterns\" className=\"space-y-4\">\n          {/* Add New Pattern */}\n          <Card>\n            <CardHeader>\n              <CardTitle className=\"text-sm font-medium\">Add Ignore Pattern</CardTitle>\n            </CardHeader>\n            <CardContent className=\"space-y-4\">\n              <div className=\"flex gap-2\">\n                <Input\n                  placeholder=\"Enter glob pattern (e.g., *.log, src/debug/**)\"\n                  value={newPattern}\n                  onChange={(e) => setNewPattern(e.target.value)}\n                  className=\"flex-1\"\n                  onKeyDown={(e) => e.key === 'Enter' && handleAddPattern()}\n                />\n                <Button\n                  onClick={handleAddPattern}\n                  disabled={!newPattern.trim() || patternMutation.isPending}\n                  size=\"sm\"\n                  className=\"h-7 text-xs\"\n                >\n                  <Plus className=\"w-3 h-3 mr-1\" />\n                  Add Pattern\n                </Button>\n              </div>\n\n              <div className=\"text-sm text-muted-foreground\">\n                Examples: <code>*.log</code>, <code>node_modules/**</code>, <code>src/debug.ts</code>, <code>**/*.test.*</code>\n              </div>\n            </CardContent>\n          </Card>\n\n          {/* Existing Patterns */}\n          <Card>\n            <CardHeader>\n              <CardTitle className=\"text-sm font-medium\">Current Ignore Patterns</CardTitle>\n            </CardHeader>\n            <CardContent>\n              {patternsLoading ? (\n                <div className=\"text-center py-4\">Loading patterns...</div>\n              ) : (\n                <div className=\"space-y-3\">\n                  {allPatterns.map((item, index) => (\n                    <div\n                      key={index}\n                      className={`flex items-center gap-3 p-3 rounded-md border ${!item.active ? 'opacity-60 bg-muted/50' : ''\n                        }`}\n                    >\n                      <div className=\"flex-1\">\n                        <div className=\"font-mono text-xs\">{item.pattern}</div>\n                        <div className=\"flex items-center gap-2 mt-1\">\n                          <Badge\n                            variant={item.source === 'system' ? 'secondary' :\n                              item.source === 'user' ? 'default' : 'outline'}\n                            className=\"text-xs\"\n                          >\n                            {item.source === 'system' ? 'System Default' :\n                              item.source === 'user' ? 'User Added' : 'File Pattern'}\n                          </Badge>\n                          {item.active ? (\n                            <Badge variant=\"outline\" className=\"text-xs text-[color:var(--color-success)]\">\n                              <CheckCircle className=\"w-3 h-3 mr-1\" />\n                              Active\n                            </Badge>\n                          ) : (\n                            <Badge variant=\"outline\" className=\"text-xs text-muted-foreground\">\n                              <AlertCircle className=\"w-3 h-3 mr-1\" />\n                              Disabled\n                            </Badge>\n                          )}\n                        </div>\n                      </div>\n\n                      <div className=\"flex gap-2\">\n                        {item.source === 'system' ? (\n                          <Button\n                            size=\"sm\"\n                            variant=\"ghost\"\n                            onClick={() => handleTogglePattern(item.pattern, true)}\n                            disabled={patternMutation.isPending}\n                          >\n                            {item.active ? 'Disable' : 'Enable'}\n                          </Button>\n                        ) : (\n                          <Button\n                            size=\"sm\"\n                            variant=\"ghost\"\n                            onClick={() => handleTogglePattern(item.pattern, false)}\n                            disabled={patternMutation.isPending}\n                          >\n                            <Trash2 className=\"w-4 h-4\" />\n                          </Button>\n                        )}\n                      </div>\n                    </div>\n                  ))}\n                </div>\n              )}\n            </CardContent>\n          </Card>\n        </TabsContent>\n\n        {/* Bundle Overview Tab */}\n        <TabsContent value=\"bundles\" className=\"space-y-4\">\n          {statsLoading ? (\n            <div className=\"text-center py-8\">Loading bundle statistics...</div>\n          ) : (\n            <div className=\"grid gap-4\">\n              {Object.entries(bundleStats).map(([bundleName, stats]) => (\n                <Card key={bundleName}>\n                  <CardHeader>\n                    <div className=\"flex justify-between items-center\">\n                      <CardTitle className=\"text-sm font-medium\">{bundleName}</CardTitle>\n                      <div className=\"flex items-center gap-2\">\n                        <Badge variant=\"outline\">\n                          {stats.visible} / {stats.total} visible\n                        </Badge>\n                        {stats.hidden > 0 && (\n                          <Badge variant=\"secondary\">\n                            {stats.hidden} hidden\n                          </Badge>\n                        )}\n                      </div>\n                    </div>\n                  </CardHeader>\n                  <CardContent>\n                    <div className=\"space-y-3\">\n                      <div className=\"flex items-center gap-4\">\n                        <div className=\"flex-1 bg-border rounded-full h-2\">\n                          <div\n                            className=\"bg-[color:var(--color-info)] h-2 rounded-full\"\n                            style={{\n                              width: `${stats.total > 0 ? (stats.visible / stats.total) * 100 : 0}%`\n                            }}\n                          />\n                        </div>\n                        <Button\n                          size=\"sm\"\n                          variant=\"outline\"\n                          className=\"h-7 text-xs\"\n                          onClick={() => setSelectedBundle(bundleName)}\n                        >\n                          <Settings className=\"w-3 h-3 mr-1\" />\n                          Manage Files\n                        </Button>\n                      </div>\n\n                      <div className=\"text-sm text-muted-foreground\">\n                        <div>Patterns: {stats.patterns.join(', ')}</div>\n                      </div>\n                    </div>\n                  </CardContent>\n                </Card>\n              ))}\n            </div>\n          )}\n        </TabsContent>\n      </Tabs>\n    </div>\n  )\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/SemanticChunks.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"25816\" modified=\"2025-06-26T23:01:24.638Z\" lines=\"672\" />\n        <cntx:content><![CDATA[import { useState, useMemo } from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { Card, CardHeader, CardTitle, CardContent } from './ui/card'\nimport { Button } from './ui/button'\nimport { Badge } from './ui/badge'\nimport { Alert, AlertDescription } from './ui/alert'\nimport { Input } from './ui/input'\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from './ui/select'\nimport {\n  Copy,\n  RefreshCw,\n  Zap,\n  FileText,\n  Code,\n  Package,\n  AlertTriangle,\n  Eye,\n  EyeOff,\n  BarChart3,\n  Search,\n  Filter,\n  X\n} from 'lucide-react'\nimport { toast } from '@/lib/toast'\n\ninterface SemanticChunk {\n  name: string\n  type: string\n  subtype?: string\n  purpose: string\n  filePath: string\n  size: number\n  startLine?: number\n  isExported?: boolean\n  isAsync?: boolean\n  complexity: {\n    level: string\n    score: number\n  }\n  includes?: {\n    imports: string[]\n    types: string[]\n  }\n  tags: string[]\n  code?: string\n  bundles: string[]\n}\n\ninterface SemanticAnalysis {\n  summary: {\n    totalFiles: number\n    totalFunctions: number\n    totalChunks: number\n    averageChunkSize: number\n  }\n  chunks: SemanticChunk[]\n}\n\n// API functions\nconst fetchSemanticAnalysis = async (): Promise<SemanticAnalysis> => {\n  const response = await fetch('http://localhost:3333/api/semantic-chunks')\n  if (!response.ok) throw new Error('Failed to fetch semantic analysis')\n  return response.json()\n}\n\n\nexport function SemanticChunks() {\n  const [showDetails, setShowDetails] = useState<string | null>(null)\n\n  // Filter states\n  const [searchTerm, setSearchTerm] = useState('')\n  const [typeFilter, setTypeFilter] = useState<string>('all')\n  const [complexityFilter, setComplexityFilter] = useState<string>('all')\n  const [purposeFilter, setPurposeFilter] = useState<string>('all')\n  const [asyncFilter, setAsyncFilter] = useState<string>('all')\n  const [exportedFilter, setExportedFilter] = useState<string>('all')\n  const [bundleFilter, setBundleFilter] = useState<string>('all')\n\n  const { data: analysis, isLoading, error, refetch } = useQuery({\n    queryKey: ['semantic-analysis'],\n    queryFn: fetchSemanticAnalysis,\n    staleTime: 30000, // Cache for 30 seconds\n    refetchInterval: 60000 // Refresh every minute\n  })\n\n\n  // Filtered chunks based on search and filters\n  const filteredChunks = useMemo(() => {\n    if (!analysis?.chunks) return []\n\n    const filtered = analysis.chunks.filter(chunk => {\n      // Search filter\n      if (searchTerm) {\n        const searchLower = searchTerm.toLowerCase()\n        const matchesSearch =\n          chunk.name.toLowerCase().includes(searchLower) ||\n          chunk.purpose.toLowerCase().includes(searchLower) ||\n          chunk.filePath.toLowerCase().includes(searchLower) ||\n          chunk.code?.toLowerCase().includes(searchLower)\n\n        if (!matchesSearch) return false\n      }\n\n      // Type filter\n      if (typeFilter !== 'all' && chunk.subtype !== typeFilter) return false\n\n      // Complexity filter\n      if (complexityFilter !== 'all' && chunk.complexity?.level !== complexityFilter) return false\n\n      // Purpose filter\n      if (purposeFilter !== 'all' && !chunk.purpose.toLowerCase().includes(purposeFilter.toLowerCase())) return false\n\n      // Async filter\n      if (asyncFilter === 'async' && !chunk.isAsync) return false\n      if (asyncFilter === 'sync' && chunk.isAsync) return false\n\n      // Exported filter\n      if (exportedFilter === 'exported' && !chunk.isExported) return false\n      if (exportedFilter === 'internal' && chunk.isExported) return false\n\n      // Bundle filter\n      if (bundleFilter !== 'all' && !chunk.bundles?.includes(bundleFilter)) return false\n\n      return true\n    })\n\n    return filtered\n  }, [analysis?.chunks, searchTerm, typeFilter, complexityFilter, purposeFilter, asyncFilter, exportedFilter, bundleFilter])\n\n  // Get unique values for filter options\n  const filterOptions = useMemo(() => {\n    if (!analysis?.chunks) return { types: [], purposes: [], complexities: [], bundles: [] }\n\n    const types = [...new Set(analysis.chunks.map(c => c.subtype).filter(Boolean))].sort()\n    const purposes = [...new Set(analysis.chunks.map(c => c.purpose))].sort()\n    const complexities = [...new Set(analysis.chunks.map(c => c.complexity?.level).filter(Boolean))].sort()\n    const bundles = [...new Set(analysis.chunks.flatMap(c => c.bundles || []))].sort()\n\n    return { types, purposes, complexities, bundles }\n  }, [analysis?.chunks])\n\n  const clearFilters = () => {\n    setSearchTerm('')\n    setTypeFilter('all')\n    setComplexityFilter('all')\n    setPurposeFilter('all')\n    setAsyncFilter('all')\n    setExportedFilter('all')\n    setBundleFilter('all')\n  }\n\n  const hasActiveFilters = searchTerm || typeFilter !== 'all' || complexityFilter !== 'all' ||\n    purposeFilter !== 'all' || asyncFilter !== 'all' || exportedFilter !== 'all' || bundleFilter !== 'all'\n\n\n  const getChunkIcon = (chunk: SemanticChunk) => {\n    if (chunk.subtype === 'react_component' || chunk.tags?.includes('react_component')) return <Code className=\"w-4 h-4\" />\n    if (chunk.purpose?.includes('React hook')) return <Zap className=\"w-4 h-4\" />\n    if (chunk.subtype === 'arrow_function') return <FileText className=\"w-4 h-4\" />\n    if (chunk.subtype === 'method') return <Package className=\"w-4 h-4\" />\n    return <FileText className=\"w-4 h-4\" />\n  }\n\n  const getComplexityColor = (level: string) => {\n    switch (level) {\n      case 'low': return 'text-green-600'\n      case 'medium': return 'text-yellow-600'\n      case 'high': return 'text-red-600'\n      default: return 'text-gray-600'\n    }\n  }\n\n  if (isLoading) {\n    return (\n      <Card>\n        <CardContent className=\"pt-6\">\n          <div className=\"flex items-center justify-center py-8\">\n            <RefreshCw className=\"w-6 h-6 animate-spin mr-2\" />\n            <span className=\"text-sm\">Analyzing code semantics...</span>\n          </div>\n        </CardContent>\n      </Card>\n    )\n  }\n\n  if (error) {\n    return (\n      <Card>\n        <CardContent className=\"pt-6\">\n          <Alert>\n            <AlertTriangle className=\"w-4 h-4\" />\n            <AlertDescription>\n              Failed to load semantic analysis. Make sure the server supports semantic chunking.\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                className=\"ml-2\"\n                onClick={() => refetch()}\n              >\n                Retry\n              </Button>\n            </AlertDescription>\n          </Alert>\n        </CardContent>\n      </Card>\n    )\n  }\n\n  if (!analysis) return null\n\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Filters */}\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center justify-between text-sm font-medium\">\n            <div className=\"flex items-center gap-2\">\n              <Filter className=\"w-4 h-4\" />\n              Filters\n            </div>\n            {hasActiveFilters && (\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                className=\"h-7 text-xs\"\n                onClick={clearFilters}\n              >\n                <X className=\"w-3 h-3 mr-1\" />\n                Clear All\n              </Button>\n            )}\n          </CardTitle>\n        </CardHeader>\n        <CardContent>\n          <div className=\"grid grid-cols-1 md:grid-cols-3 lg:grid-cols-7 gap-4\">\n            {/* Search */}\n            <div className=\"md:col-span-2\">\n              <div className=\"relative\">\n                <Search className=\"absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-muted-foreground\" />\n                <Input\n                  placeholder=\"Search functions...\"\n                  value={searchTerm}\n                  onChange={(e) => setSearchTerm(e.target.value)}\n                  className=\"pl-10 h-8 text-xs\"\n                />\n              </div>\n            </div>\n\n            {/* Function Type */}\n            <div>\n              <Select value={typeFilter} onValueChange={setTypeFilter}>\n                <SelectTrigger className=\"h-8 text-xs\">\n                  <SelectValue placeholder=\"Type\" />\n                </SelectTrigger>\n                <SelectContent>\n                  <SelectItem value=\"all\">All Types</SelectItem>\n                  {filterOptions.types.map(type => (\n                    <SelectItem key={type} value={type}>{type}</SelectItem>\n                  ))}\n                </SelectContent>\n              </Select>\n            </div>\n\n            {/* Complexity */}\n            <div>\n              <Select value={complexityFilter} onValueChange={setComplexityFilter}>\n                <SelectTrigger className=\"h-8 text-xs\">\n                  <SelectValue placeholder=\"Complexity\" />\n                </SelectTrigger>\n                <SelectContent>\n                  <SelectItem value=\"all\">All Complexity</SelectItem>\n                  {filterOptions.complexities.map(complexity => (\n                    <SelectItem key={complexity} value={complexity}>{complexity}</SelectItem>\n                  ))}\n                </SelectContent>\n              </Select>\n            </div>\n\n            {/* Purpose */}\n            <div>\n              <Select value={purposeFilter} onValueChange={setPurposeFilter}>\n                <SelectTrigger className=\"h-8 text-xs\">\n                  <SelectValue placeholder=\"Purpose\" />\n                </SelectTrigger>\n                <SelectContent>\n                  <SelectItem value=\"all\">All Purposes</SelectItem>\n                  {filterOptions.purposes.map(purpose => (\n                    <SelectItem key={purpose} value={purpose}>{purpose}</SelectItem>\n                  ))}\n                </SelectContent>\n              </Select>\n            </div>\n\n            {/* Async/Sync */}\n            <div>\n              <Select value={asyncFilter} onValueChange={setAsyncFilter}>\n                <SelectTrigger className=\"h-8 text-xs\">\n                  <SelectValue placeholder=\"Async\" />\n                </SelectTrigger>\n                <SelectContent>\n                  <SelectItem value=\"all\">All Functions</SelectItem>\n                  <SelectItem value=\"async\">Async Only</SelectItem>\n                  <SelectItem value=\"sync\">Sync Only</SelectItem>\n                </SelectContent>\n              </Select>\n            </div>\n\n            {/* Bundle */}\n            <div>\n              <Select value={bundleFilter} onValueChange={setBundleFilter}>\n                <SelectTrigger className=\"h-8 text-xs\">\n                  <SelectValue placeholder=\"Bundle\" />\n                </SelectTrigger>\n                <SelectContent>\n                  <SelectItem value=\"all\">All Bundles</SelectItem>\n                  {filterOptions.bundles.map(bundle => (\n                    <SelectItem key={bundle} value={bundle}>{bundle}</SelectItem>\n                  ))}\n                </SelectContent>\n              </Select>\n            </div>\n          </div>\n\n          {/* Active Filters Display */}\n          {hasActiveFilters && (\n            <div className=\"flex flex-wrap gap-2 mt-4 pt-4 border-t\">\n              {searchTerm && (\n                <Badge variant=\"secondary\" className=\"text-xs flex items-center gap-1\">\n                  Search: \"{searchTerm}\"\n                  <button\n                    onClick={(e) => {\n                      e.preventDefault()\n                      e.stopPropagation()\n                      setSearchTerm('')\n                    }}\n                    className=\"ml-1 hover:bg-muted rounded-sm p-0.5\"\n                  >\n                    <X className=\"w-3 h-3\" />\n                  </button>\n                </Badge>\n              )}\n              {typeFilter !== 'all' && (\n                <Badge variant=\"secondary\" className=\"text-xs flex items-center gap-1\">\n                  Type: {typeFilter}\n                  <button\n                    onClick={(e) => {\n                      e.preventDefault()\n                      e.stopPropagation()\n                      setTypeFilter('all')\n                    }}\n                    className=\"ml-1 hover:bg-muted rounded-sm p-0.5\"\n                  >\n                    <X className=\"w-3 h-3\" />\n                  </button>\n                </Badge>\n              )}\n              {complexityFilter !== 'all' && (\n                <Badge variant=\"secondary\" className=\"text-xs flex items-center gap-1\">\n                  Complexity: {complexityFilter}\n                  <button\n                    onClick={(e) => {\n                      e.preventDefault()\n                      e.stopPropagation()\n                      setComplexityFilter('all')\n                    }}\n                    className=\"ml-1 hover:bg-muted rounded-sm p-0.5\"\n                  >\n                    <X className=\"w-3 h-3\" />\n                  </button>\n                </Badge>\n              )}\n              {purposeFilter !== 'all' && (\n                <Badge variant=\"secondary\" className=\"text-xs flex items-center gap-1\">\n                  Purpose: {purposeFilter}\n                  <button\n                    onClick={(e) => {\n                      e.preventDefault()\n                      e.stopPropagation()\n                      setPurposeFilter('all')\n                    }}\n                    className=\"ml-1 hover:bg-muted rounded-sm p-0.5\"\n                  >\n                    <X className=\"w-3 h-3\" />\n                  </button>\n                </Badge>\n              )}\n              {asyncFilter !== 'all' && (\n                <Badge variant=\"secondary\" className=\"text-xs flex items-center gap-1\">\n                  {asyncFilter === 'async' ? 'Async Only' : 'Sync Only'}\n                  <button\n                    onClick={(e) => {\n                      e.preventDefault()\n                      e.stopPropagation()\n                      setAsyncFilter('all')\n                    }}\n                    className=\"ml-1 hover:bg-muted rounded-sm p-0.5\"\n                  >\n                    <X className=\"w-3 h-3\" />\n                  </button>\n                </Badge>\n              )}\n              {bundleFilter !== 'all' && (\n                <Badge variant=\"secondary\" className=\"text-xs flex items-center gap-1\">\n                  Bundle: {bundleFilter}\n                  <button\n                    onClick={(e) => {\n                      e.preventDefault()\n                      e.stopPropagation()\n                      setBundleFilter('all')\n                    }}\n                    className=\"ml-1 hover:bg-muted rounded-sm p-0.5\"\n                  >\n                    <X className=\"w-3 h-3\" />\n                  </button>\n                </Badge>\n              )}\n            </div>\n          )}\n        </CardContent>\n      </Card>\n\n      {/* Analysis Summary */}\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center justify-between text-sm font-medium\">\n            <div className=\"flex items-center gap-2\">\n              <BarChart3 className=\"w-4 h-4\" />\n              Project Analysis\n            </div>\n            <Button\n              variant=\"outline\"\n              size=\"sm\"\n              className=\"h-7 text-xs\"\n              onClick={() => refetch()}\n              disabled={isLoading}\n            >\n              <RefreshCw className=\"w-3 h-3 mr-1\" />\n              Refresh\n            </Button>\n          </CardTitle>\n        </CardHeader>\n        <CardContent>\n          <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4 text-center\">\n            <div>\n              <div className=\"text-lg font-medium\">{analysis.summary?.totalFiles || 0}</div>\n              <div className=\"text-xs text-muted-foreground font-normal\">Files Analyzed</div>\n            </div>\n            <div>\n              <div className=\"text-lg font-medium\">{analysis.summary?.totalFunctions || 0}</div>\n              <div className=\"text-xs text-muted-foreground font-normal\">Functions Extracted</div>\n            </div>\n            <div>\n              <div className=\"text-lg font-medium\">\n                {filteredChunks.length}\n                {hasActiveFilters && (\n                  <span className=\"text-sm text-muted-foreground\"> / {analysis.summary?.totalChunks || 0}</span>\n                )}\n              </div>\n              <div className=\"text-xs text-muted-foreground font-normal\">\n                {hasActiveFilters ? 'Filtered' : 'Total'} Chunks\n              </div>\n            </div>\n            <div>\n              <div className=\"text-lg font-medium\">{Math.round(analysis.summary?.averageChunkSize || 0)}</div>\n              <div className=\"text-xs text-muted-foreground font-normal\">Avg Chunk Size</div>\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n\n      {/* Semantic Chunks Grid */}\n      <div className=\"grid gap-4\">\n        {filteredChunks.length === 0 ? (\n          <Card>\n            <CardContent className=\"pt-6\">\n              <div className=\"text-center py-8\">\n                <Package className=\"w-12 h-12 mx-auto text-muted-foreground mb-4\" />\n                <h3 className=\"text-lg font-medium mb-2\">No chunks match your filters</h3>\n                <p className=\"text-sm text-muted-foreground mb-4\">\n                  Try adjusting your search criteria or clearing the filters.\n                </p>\n                {hasActiveFilters && (\n                  <Button variant=\"outline\" onClick={clearFilters}>\n                    Clear All Filters\n                  </Button>\n                )}\n              </div>\n            </CardContent>\n          </Card>\n        ) : (\n          filteredChunks.map((chunk, index) => (\n            <Card key={`${chunk.filePath}-${chunk.name}-${index}`} className=\"relative\">\n              <CardHeader>\n                <div className=\"flex items-start justify-between\">\n                  <div className=\"flex items-start gap-3\">\n                    <div className=\"mt-1\">\n                      {getChunkIcon(chunk)}\n                    </div>\n                    <div className=\"flex-1\">\n                      <CardTitle className=\"text-sm font-medium tracking-wide\">\n                        {chunk.name}\n                      </CardTitle>\n                      <div className=\"flex items-center gap-2 mt-1\">\n                        <Badge variant=\"outline\" className=\"text-xs h-4\">\n                          {chunk.subtype || chunk.type}\n                        </Badge>\n                        <Badge variant=\"outline\" className=\"text-xs h-4\">\n                          {chunk.size} chars\n                        </Badge>\n                        <Badge\n                          variant=\"outline\"\n                          className={`text-xs h-4 ${getComplexityColor(chunk.complexity?.level || 'unknown')}`}\n                        >\n                          {chunk.complexity?.level || 'unknown'} complexity\n                        </Badge>\n                        {chunk.isAsync && (\n                          <Badge variant=\"outline\" className=\"text-xs h-4 bg-blue-50\">\n                            async\n                          </Badge>\n                        )}\n                        {chunk.isExported && (\n                          <Badge variant=\"outline\" className=\"text-xs h-4 bg-green-50\">\n                            exported\n                          </Badge>\n                        )}\n                      </div>\n                    </div>\n                  </div>\n                  <div className=\"flex gap-1\">\n                    <Button\n                      variant=\"outline\"\n                      size=\"sm\"\n                      className=\"h-7 text-xs\"\n                      onClick={() => setShowDetails(showDetails === chunk.name ? null : chunk.name)}\n                    >\n                      {showDetails === chunk.name ? (\n                        <EyeOff className=\"w-3 h-3\" />\n                      ) : (\n                        <Eye className=\"w-3 h-3\" />\n                      )}\n                    </Button>\n                  </div>\n                </div>\n              </CardHeader>\n              <CardContent>\n                <div className=\"space-y-3\">\n                  {/* Purpose and Tags */}\n                  <div>\n                    <p className=\"text-xs text-muted-foreground font-normal mb-2\">\n                      🎯 {chunk.purpose}\n                    </p>\n                    <div className=\"flex flex-wrap gap-1\">\n                      {(chunk.tags || []).slice(0, 6).map(tag => (\n                        <Badge key={tag} variant=\"secondary\" className=\"text-xs h-4\">\n                          {tag}\n                        </Badge>\n                      ))}\n                      {(chunk.tags || []).length > 6 && (\n                        <Badge variant=\"secondary\" className=\"text-xs h-4\">\n                          +{(chunk.tags || []).length - 6} more\n                        </Badge>\n                      )}\n                    </div>\n                  </div>\n\n                  {/* File Path and Location */}\n                  <div>\n                    <div className=\"text-xs font-medium mb-1\">Location:</div>\n                    <div className=\"text-xs text-muted-foreground font-normal font-mono\">\n                      {chunk.filePath}{chunk.startLine ? `:${chunk.startLine}` : ''}\n                    </div>\n                  </div>\n\n                  {/* Bundle Membership */}\n                  {(chunk.bundles?.length || 0) > 0 && (\n                    <div className=\"flex items-start gap-2 p-2 bg-blue-50 rounded text-xs\">\n                      <Package className=\"w-3 h-3 mt-0.5 text-blue-600\" />\n                      <div>\n                        <div className=\"font-medium text-blue-800\">Bundles:</div>\n                        <div className=\"flex flex-wrap gap-1 mt-1\">\n                          {chunk.bundles?.map(bundle => (\n                            <Badge key={bundle} variant=\"outline\" className=\"text-xs h-4 bg-blue-100 text-blue-700 border-blue-200\">\n                              {bundle}\n                            </Badge>\n                          ))}\n                        </div>\n                      </div>\n                    </div>\n                  )}\n\n                  {/* Function Includes (imports/types) */}\n                  {(chunk.includes?.imports.length || 0) > 0 && (\n                    <div className=\"flex items-start gap-2 p-2 bg-muted/50 rounded text-xs\">\n                      <Package className=\"w-3 h-3 mt-0.5 text-blue-500\" />\n                      <div>\n                        <div className=\"font-medium\">Imports:</div>\n                        <div className=\"font-normal\">{chunk.includes?.imports.slice(0, 3).join(', ')}</div>\n                        {(chunk.includes?.imports.length || 0) > 3 && (\n                          <div className=\"text-muted-foreground\">+{(chunk.includes?.imports.length || 0) - 3} more</div>\n                        )}\n                      </div>\n                    </div>\n                  )}\n\n                  {/* Expanded Details */}\n                  {showDetails === chunk.name && (\n                    <div className=\"border-t pt-3 space-y-3\">\n                      {/* Function Code Preview */}\n                      {chunk.code && (\n                        <div>\n                          <div className=\"flex items-center justify-between mb-2\">\n                            <div className=\"text-xs font-medium\">Function Code:</div>\n                            <Button\n                              variant=\"outline\"\n                              size=\"sm\"\n                              className=\"h-6 text-xs\"\n                              onClick={() => {\n                                navigator.clipboard.writeText(chunk.code || '')\n                                toast.success('Code copied to clipboard!')\n                              }}\n                            >\n                              <Copy className=\"w-3 h-3 mr-1\" />\n                              Copy\n                            </Button>\n                          </div>\n                          <div className=\"bg-muted/30 rounded p-3 text-xs font-mono overflow-x-auto\">\n                            <pre className=\"whitespace-pre-wrap\">{chunk.code}</pre>\n                          </div>\n                        </div>\n                      )}\n\n                      {/* Dependencies */}\n                      {(chunk.includes?.imports.length || 0) > 0 && (\n                        <div>\n                          <div className=\"text-xs font-medium mb-2\">All Imports:</div>\n                          <div className=\"space-y-1\">\n                            {chunk.includes?.imports.map((imp, idx) => (\n                              <div key={idx} className=\"text-xs font-mono text-muted-foreground bg-muted/30 px-2 py-1 rounded\">\n                                {imp}\n                              </div>\n                            ))}\n                          </div>\n                        </div>\n                      )}\n\n                      {/* Types */}\n                      {(chunk.includes?.types.length || 0) > 0 && (\n                        <div>\n                          <div className=\"text-xs font-medium mb-2\">Related Types:</div>\n                          <div className=\"space-y-1\">\n                            {chunk.includes?.types.map((type, idx) => (\n                              <div key={idx} className=\"text-xs font-mono text-muted-foreground bg-muted/30 px-2 py-1 rounded\">\n                                {type}\n                              </div>\n                            ))}\n                          </div>\n                        </div>\n                      )}\n\n                    </div>\n                  )}\n                </div>\n              </CardContent>\n            </Card>\n          )))}\n      </div>\n\n    </div>\n  )\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/SetupComponents.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"11953\" modified=\"2025-06-26T00:24:40.307Z\" lines=\"328\" />\n        <cntx:content><![CDATA[// Updated SetupComponents.tsx with clearer CLI vs UI guidance\n\nimport { useQuery } from '@tanstack/react-query'\nimport { Card, CardHeader, CardTitle, CardContent } from './ui/card'\nimport { Button } from './ui/button'\nimport { Alert, AlertDescription } from './ui/alert'\nimport { CheckCircle, AlertTriangle, Settings, Play, Terminal, FileText, Monitor, Command } from 'lucide-react'\n\ninterface SetupStatus {\n  hasConfig: boolean\n  hasIgnoreFile: boolean\n  bundleCount: number\n  hasCursorRules: boolean\n  isFirstTime: boolean\n}\n\nconst fetchSetupStatus = async (): Promise<SetupStatus> => {\n  try {\n    const [configResponse, bundlesResponse, cursorResponse] = await Promise.all([\n      fetch('http://localhost:3333/api/config'),\n      fetch('http://localhost:3333/api/bundles'),\n      fetch('http://localhost:3333/api/cursor-rules')\n    ])\n\n    const hasConfig = configResponse.ok\n    const bundles = bundlesResponse.ok ? await bundlesResponse.json() : []\n    const hasCursorRules = cursorResponse.ok\n\n    return {\n      hasConfig,\n      hasIgnoreFile: true, // We can assume this exists if config exists\n      bundleCount: bundles.length || 0,\n      hasCursorRules,\n      isFirstTime: !hasConfig || bundles.length === 0\n    }\n  } catch (error) {\n    return {\n      hasConfig: false,\n      hasIgnoreFile: false,\n      bundleCount: 0,\n      hasCursorRules: false,\n      isFirstTime: true\n    }\n  }\n}\n\ninterface SetupBannerProps {\n  onStartSetup: () => void\n}\n\nexport function SetupBanner({ onStartSetup }: SetupBannerProps) {\n  const { data: status, isLoading } = useQuery({\n    queryKey: ['setup-status'],\n    queryFn: fetchSetupStatus,\n    refetchInterval: 5000,\n  })\n\n  if (isLoading || !status?.isFirstTime) {\n    return null\n  }\n\n  return (\n    <Alert className=\"mb-6 border-[color:var(--color-info)]/20 bg-[color:var(--color-info)]/5\">\n      <Settings className=\"w-4 h-4\" />\n      <AlertDescription className=\"flex items-center justify-between\">\n        <div>\n          <strong>Welcome to cntx-ui!</strong> This looks like your first time.\n          The web interface is already running - let's help you get set up properly.\n        </div>\n        <Button onClick={onStartSetup} size=\"sm\">\n          Start Setup Guide\n        </Button>\n      </AlertDescription>\n    </Alert>\n  )\n}\n\ninterface SetupChecklistProps {\n  onOpenFullSetup: () => void\n}\n\nexport function SetupChecklist({ onOpenFullSetup }: SetupChecklistProps) {\n  const { data: status, isLoading } = useQuery({\n    queryKey: ['setup-status'],\n    queryFn: fetchSetupStatus,\n    refetchInterval: 10000,\n  })\n\n  if (isLoading) {\n    return <div>Checking setup status...</div>\n  }\n\n  const checks = [\n    {\n      label: 'Configuration file exists',\n      passed: status?.hasConfig || false,\n      description: '.cntx/config.json with bundle definitions'\n    },\n    {\n      label: 'Ignore patterns configured',\n      passed: status?.hasIgnoreFile || false,\n      description: '.cntxignore file to exclude unnecessary files'\n    },\n    {\n      label: 'Bundles generated',\n      passed: (status?.bundleCount || 0) > 0,\n      description: `${status?.bundleCount || 0} bundles currently configured`\n    },\n    {\n      label: 'Cursor rules created',\n      passed: status?.hasCursorRules || false,\n      description: '.cursorrules file for AI assistant context'\n    }\n  ]\n\n  const allPassed = checks.every(check => check.passed)\n\n  return (\n    <Card className={!allPassed ? 'border-[color:var(--color-warning)]/20' : ''}>\n      <CardHeader>\n        <CardTitle className=\"flex items-center gap-2 text-sm font-medium\">\n          <Settings className=\"w-4 h-4\" />\n          Setup Status\n          {allPassed ? (\n            <CheckCircle className=\"w-4 h-4 text-[color:var(--color-success)]\" />\n          ) : (\n            <AlertTriangle className=\"w-4 h-4 text-[color:var(--color-warning)]\" />\n          )}\n        </CardTitle>\n      </CardHeader>\n      <CardContent>\n        <div className=\"space-y-3\">\n          {checks.map((check, index) => (\n            <div key={index} className=\"flex items-start gap-3\">\n              <div className=\"flex-shrink-0 mt-0.5\">\n                {check.passed ? (\n                  <CheckCircle className=\"w-4 h-4 text-[color:var(--color-success)]\" />\n                ) : (\n                  <AlertTriangle className=\"w-4 h-4 text-[color:var(--color-warning)]\" />\n                )}\n              </div>\n              <div className=\"flex-1\">\n                <div className={`text-xs font-medium ${check.passed ? 'text-[color:var(--color-success)]' : 'text-[color:var(--color-warning)]'}`}>\n                  {check.label}\n                </div>\n                <div className=\"text-xs text-muted-foreground font-normal\">{check.description}</div>\n              </div>\n            </div>\n          ))}\n        </div>\n\n        {!allPassed && (\n          <div className=\"mt-4 pt-4 border-t\">\n            <Button onClick={onOpenFullSetup} variant=\"outline\" size=\"sm\" className=\"w-full h-7 text-xs\">\n              <Play className=\"w-3 h-3 mr-2\" />\n              Complete Setup Guide\n            </Button>\n          </div>\n        )}\n      </CardContent>\n    </Card>\n  )\n}\n\n// CLI vs UI guidance component\nexport function UsageGuidance() {\n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle className=\"flex items-center gap-2 text-sm font-medium\">\n          <Monitor className=\"w-4 h-4\" />\n          How to Use cntx-ui\n        </CardTitle>\n      </CardHeader>\n      <CardContent className=\"space-y-4\">\n        <Alert className=\"border-[color:var(--color-info)]/20 bg-[color:var(--color-info)]/5\">\n          <Terminal className=\"w-4 h-4\" />\n          <AlertDescription>\n            <strong>You're already running!</strong> The web interface provides full functionality.\n            CLI commands are available for automation and advanced workflows.\n          </AlertDescription>\n        </Alert>\n\n        <div className=\"space-y-4\">\n          <div>\n            <h4 className=\"text-xs font-medium mb-2 flex items-center gap-2\">\n              <Monitor className=\"w-3 h-3\" />\n              Web Interface (Recommended)\n            </h4>\n            <div className=\"text-xs text-muted-foreground font-normal space-y-2\">\n              <p>Perfect for interactive use and project management:</p>\n              <div className=\"ml-4 space-y-1\">\n                <div>• <strong>Bundle Management:</strong> View, create, and manage bundles</div>\n                <div>• <strong>Configuration:</strong> Edit bundle patterns visually</div>\n                <div>• <strong>Hidden Files:</strong> Control file visibility per bundle</div>\n                <div>• <strong>Cursor Rules:</strong> Manage AI assistant context</div>\n                <div>• <strong>Real-time Updates:</strong> See changes immediately</div>\n              </div>\n            </div>\n          </div>\n\n          <div>\n            <h4 className=\"text-xs font-medium mb-2 flex items-center gap-2\">\n              <Command className=\"w-3 h-3\" />\n              Command Line Interface\n            </h4>\n            <div className=\"text-xs text-muted-foreground font-normal space-y-2\">\n              <p>Great for automation, scripts, and CI/CD:</p>\n              <div className=\"ml-4 space-y-1\">\n                <div>• <strong>Quick bundle generation:</strong> <code className=\"bg-muted px-1 rounded\">cntx-ui bundle master</code></div>\n                <div>• <strong>Status checking:</strong> <code className=\"bg-muted px-1 rounded\">cntx-ui status</code></div>\n                <div>• <strong>Scripting workflows:</strong> Integrate with build processes</div>\n              </div>\n            </div>\n          </div>\n        </div>\n      </CardContent>\n    </Card>\n  )\n}\n\n// Quick CLI reference for advanced users\nexport function QuickCliReference() {\n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle className=\"flex items-center gap-2 text-sm font-medium\">\n          <Terminal className=\"w-4 h-4\" />\n          CLI Reference\n        </CardTitle>\n      </CardHeader>\n      <CardContent>\n        <div className=\"space-y-3 text-sm font-mono\">\n          <div className=\"flex items-center gap-2\">\n            <code className=\"bg-muted px-2 py-1 rounded text-xs\">cntx-ui watch</code>\n            <span className=\"text-muted-foreground text-xs\">Start server (already running)</span>\n          </div>\n          <div className=\"flex items-center gap-2\">\n            <code className=\"bg-muted px-2 py-1 rounded text-xs\">cntx-ui status</code>\n            <span className=\"text-muted-foreground text-xs\">Check configuration status</span>\n          </div>\n          <div className=\"flex items-center gap-2\">\n            <code className=\"bg-muted px-2 py-1 rounded text-xs\">cntx-ui bundle [name]</code>\n            <span className=\"text-muted-foreground text-xs\">Generate specific bundle</span>\n          </div>\n        </div>\n      </CardContent>\n    </Card>\n  )\n}\n\n// Workflow instructions component\nexport function WorkflowInstructions() {\n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle className=\"flex items-center gap-2 text-sm font-medium\">\n          <FileText className=\"w-4 h-4\" />\n          Common Workflows\n        </CardTitle>\n      </CardHeader>\n      <CardContent className=\"space-y-4\">\n        <div>\n          <h4 className=\"text-xs font-medium mb-2\">🎯 For AI Development</h4>\n          <div className=\"text-xs text-muted-foreground font-normal space-y-1\">\n            <div>1. Create focused bundles (api, ui, core)</div>\n            <div>2. Hide debug/temp files from bundles</div>\n            <div>3. Copy bundle XML for AI context</div>\n            <div>4. Use Cursor Rules for project context</div>\n          </div>\n        </div>\n\n        <div>\n          <h4 className=\"text-xs font-medium mb-2\">📁 For Project Organization</h4>\n          <div className=\"text-xs text-muted-foreground font-normal space-y-1\">\n            <div>1. Configure ignore patterns for unwanted files</div>\n            <div>2. Create bundles by feature or responsibility</div>\n            <div>3. Use hidden files to trim bundle scope</div>\n            <div>4. Monitor bundle sizes and file counts</div>\n          </div>\n        </div>\n\n        <div>\n          <h4 className=\"text-xs font-medium mb-2\">🤖 For CI/CD Integration</h4>\n          <div className=\"text-xs text-muted-foreground font-normal space-y-1\">\n            <div>1. Use CLI commands in build scripts</div>\n            <div>2. Generate bundles for automated testing</div>\n            <div>3. Export project context for deployment</div>\n          </div>\n        </div>\n      </CardContent>\n    </Card>\n  )\n}\n\n// Installation reminder for new users\nexport function InstallationReminder() {\n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle className=\"text-sm font-medium\">First Time Setup</CardTitle>\n      </CardHeader>\n      <CardContent className=\"space-y-3\">\n        <Alert className=\"border-[color:var(--color-success)]/20 bg-[color:var(--color-success)]/5\">\n          <CheckCircle className=\"w-4 h-4\" />\n          <AlertDescription>\n            <strong>You're all set!</strong> cntx-ui is installed and running.\n            Use this web interface for full functionality.\n          </AlertDescription>\n        </Alert>\n\n        <div className=\"text-xs text-muted-foreground font-normal\">\n          <p className=\"mb-2\"><strong>For new projects:</strong></p>\n          <div className=\"ml-4 space-y-1\">\n            <div>1. Install: <code className=\"bg-muted px-1 rounded\">npm install -g cntx-ui</code></div>\n            <div>2. Initialize: <code className=\"bg-muted px-1 rounded\">cntx-ui init</code></div>\n            <div>3. Start: <code className=\"bg-muted px-1 rounded\">cntx-ui watch</code></div>\n          </div>\n        </div>\n      </CardContent>\n    </Card>\n  )\n}\n\n// Legacy components for backward compatibility\nexport const QuickSetupTips = QuickCliReference\nexport const UsageInstructions = WorkflowInstructions\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/SetupScreen.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"32815\" modified=\"2025-06-26T00:31:31.564Z\" lines=\"666\" />\n        <cntx:content><![CDATA[import { useState } from 'react'\nimport { CheckCircle, Circle, Copy, Monitor, FolderOpen, Settings, ArrowRight, ExternalLink, AlertTriangle, Play, Sparkles, Eye, Zap, Download } from 'lucide-react'\nimport { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card'\nimport { Button } from '@/components/ui/button'\nimport { Badge } from '@/components/ui/badge'\nimport { Alert, AlertDescription } from '@/components/ui/alert'\n\ninterface SetupStep {\n  id: string\n  title: string\n  description: string\n  completed: boolean\n  required: boolean\n}\n\nexport default function SetupScreen() {\n  const [currentStep, setCurrentStep] = useState(0)\n  const [setupSteps, setSetupSteps] = useState<SetupStep[]>([\n    {\n      id: 'welcome',\n      title: 'Welcome to cntx-ui',\n      description: 'Organize your code into focused bundles for AI assistance',\n      completed: false,\n      required: true\n    },\n    {\n      id: 'bundles',\n      title: 'Create Your First Bundles',\n      description: 'Set up focused file collections and learn the basics',\n      completed: false,\n      required: true\n    },\n    {\n      id: 'ai-analysis',\n      title: 'AI Bundle Analysis (Optional)',\n      description: 'Let AI analyze your code and suggest optimal bundles',\n      completed: false,\n      required: false\n    },\n    {\n      id: 'mcp-integration',\n      title: 'MCP Integration (Enhanced)',\n      description: 'Set up seamless AI integration with Claude Desktop',\n      completed: false,\n      required: false\n    },\n    {\n      id: 'workflows',\n      title: 'Choose Your Workflow',\n      description: 'Manual copy/paste or seamless MCP integration',\n      completed: false,\n      required: false\n    }\n  ])\n\n  const [aiPromptCopied, setAiPromptCopied] = useState(false)\n  const [masterBundleCopied, setMasterBundleCopied] = useState(false)\n\n  const copyAiPrompt = async () => {\n    const prompt = `Analyze this codebase bundle and suggest an optimal bundle configuration for cntx-ui.\n\nBased on the file structure and content, recommend 3-6 meaningful bundles with glob patterns that group related files logically.\n\nConsider these common bundle types:\n- Frontend/UI components and pages\n- Backend API routes and controllers  \n- Configuration files\n- Documentation\n- Tests\n- Utilities/helpers\n- Styles/assets\n\nReturn ONLY a JSON configuration in this exact format:\n{\n  \"bundles\": {\n    \"master\": [\"**/*\"],\n    \"frontend\": [\"src/components/**/*\", \"src/pages/**/*\", \"src/hooks/**/*\"],\n    \"api\": [\"src/api/**/*\", \"routes/**/*\", \"controllers/**/*\"],\n    \"config\": [\"*.config.*\", \"package.json\", \"tsconfig.json\"],\n    \"docs\": [\"README.md\", \"docs/**/*\", \"*.md\"],\n    \"tests\": [\"**/*.test.*\", \"**/*.spec.*\", \"__tests__/**/*\"]\n  }\n}\n\nPlease analyze the following master bundle and suggest appropriate bundles:\n\n[PASTE YOUR MASTER BUNDLE XML CONTENT HERE]`\n\n    try {\n      await navigator.clipboard.writeText(prompt)\n      setAiPromptCopied(true)\n      setTimeout(() => setAiPromptCopied(false), 3000)\n    } catch (err) {\n      console.error('Failed to copy AI prompt:', err)\n    }\n  }\n\n  const copyMasterBundle = async () => {\n    try {\n      const response = await fetch('http://localhost:3333/api/bundles/master')\n      if (!response.ok) throw new Error('Failed to fetch master bundle')\n\n      const xmlContent = await response.text()\n      await navigator.clipboard.writeText(xmlContent)\n      setMasterBundleCopied(true)\n      setTimeout(() => setMasterBundleCopied(false), 3000)\n    } catch (err) {\n      console.error('Failed to copy master bundle:', err)\n    }\n  }\n\n  const downloadMasterBundle = async () => {\n    try {\n      const response = await fetch('http://localhost:3333/api/bundles/master')\n      if (!response.ok) throw new Error('Failed to fetch master bundle')\n\n      const xmlContent = await response.text()\n      const blob = new Blob([xmlContent], { type: 'application/xml' })\n      const url = URL.createObjectURL(blob)\n      const a = document.createElement('a')\n      a.href = url\n      a.download = 'master-bundle.xml'\n      a.click()\n      URL.revokeObjectURL(url)\n    } catch (err) {\n      console.error('Failed to download master bundle:', err)\n    }\n  }\n\n  const markStepComplete = (stepId: string) => {\n    setSetupSteps(prev => prev.map(step =>\n      step.id === stepId ? { ...step, completed: true } : step\n    ))\n  }\n\n  const StepIndicator = ({ step, isActive }: { step: SetupStep, isActive: boolean }) => (\n    <div className={`flex items-center gap-3 p-3 rounded-lg transition-colors ${isActive ? 'bg-accent border border-border' : 'hover:bg-muted/50'\n      }`}>\n      <div className=\"flex-shrink-0\">\n        {step.completed ? (\n          <CheckCircle className=\"w-6 h-6 text-[color:var(--color-success)]\" />\n        ) : (\n          <Circle className={`w-6 h-6 ${isActive ? 'text-primary' : 'text-muted-foreground'}`} />\n        )}\n      </div>\n      <div className=\"flex-1\">\n        <div className=\"flex items-center gap-2\">\n          <h3 className={`text-xs font-medium ${isActive ? 'text-foreground' : 'text-foreground'}`}>\n            {step.title}\n          </h3>\n          {step.required && (\n            <Badge variant=\"outline\" className=\"text-xs\">Required</Badge>\n          )}\n        </div>\n        <p className=\"text-xs text-muted-foreground font-normal\">{step.description}</p>\n      </div>\n    </div>\n  )\n\n  return (\n    <div className=\"min-h-screen bg-gradient-to-br from-background to-muted/20\">\n      <div className=\"container mx-auto px-4 py-8\">\n        {/* Header */}\n        <div className=\"text-center mb-8\">\n          <h1 className=\"text-2xl font-normal text-foreground mb-2\">Welcome to cntx-ui</h1>\n          <p className=\"text-sm text-muted-foreground font-normal max-w-2xl mx-auto\">\n            You're already up and running! Let's explore what you can do with the web interface.\n          </p>\n        </div>\n\n        <div className=\"grid lg:grid-cols-3 gap-8 max-w-7xl mx-auto\">\n          {/* Steps Sidebar */}\n          <div className=\"lg:col-span-1\">\n            <Card>\n              <CardHeader>\n                <CardTitle className=\"flex items-center gap-2 text-sm font-medium\">\n                  <Settings className=\"w-4 h-4\" />\n                  Quick Tour\n                </CardTitle>\n              </CardHeader>\n              <CardContent className=\"space-y-2\">\n                {setupSteps.map((step, index) => (\n                  <div\n                    key={step.id}\n                    onClick={() => setCurrentStep(index)}\n                    className=\"cursor-pointer\"\n                  >\n                    <StepIndicator step={step} isActive={currentStep === index} />\n                  </div>\n                ))}\n              </CardContent>\n            </Card>\n          </div>\n\n          {/* Main Content */}\n          <div className=\"lg:col-span-2 space-y-6\">\n            {/* Step 1: Welcome */}\n            {currentStep === 0 && (\n              <Card>\n                <CardHeader>\n                  <CardTitle className=\"flex items-center gap-2 text-sm font-medium\">\n                    <Sparkles className=\"w-4 h-4\" />\n                    Welcome to cntx-ui\n                  </CardTitle>\n                </CardHeader>\n                <CardContent className=\"space-y-6\">\n                  <Alert className=\"border-green-200 bg-green-50\">\n                    <CheckCircle className=\"w-4 h-4\" />\n                    <AlertDescription>\n                      <strong>You're all set!</strong> cntx-ui is running and ready to organize your code for AI assistance.\n                      Start with basic bundle management, then optionally enhance with seamless AI integration.\n                    </AlertDescription>\n                  </Alert>\n\n                  <div className=\"bg-accent/50 p-4 rounded-lg border\">\n                    <h4 className=\"text-xs font-medium text-foreground mb-2\">What is cntx-ui?</h4>\n                    <p className=\"text-xs text-muted-foreground font-normal mb-3\">\n                      cntx-ui organizes your codebase into focused bundles for AI development.\n                      Create meaningful file collections, copy them to AI tools, or use advanced MCP integration for seamless workflows.\n                    </p>\n                    <div className=\"grid grid-cols-2 gap-2 text-xs text-muted-foreground font-normal\">\n                      <div>• Bundle files by purpose or feature</div>\n                      <div>• Hide irrelevant files from AI context</div>\n                      <div>• Copy bundles to any AI tool</div>\n                      <div>• Optional seamless AI integration</div>\n                    </div>\n                  </div>\n\n                  <div className=\"grid md:grid-cols-2 gap-4\">\n                    <Card className=\"border-border\">\n                      <CardContent className=\"pt-6\">\n                        <Monitor className=\"w-8 h-8 text-primary mb-3\" />\n                        <h3 className=\"text-xs font-medium mb-2\">Core Experience</h3>\n                        <p className=\"text-xs text-muted-foreground font-normal\">\n                          Organize bundles in the web interface, copy XML to Claude, ChatGPT, or any AI tool.\n                        </p>\n                        <Badge variant=\"outline\" className=\"mt-2\">Works everywhere</Badge>\n                      </CardContent>\n                    </Card>\n\n                    <Card className=\"border-border\">\n                      <CardContent className=\"pt-6\">\n                        <Zap className=\"w-8 h-8 text-primary mb-3\" />\n                        <h3 className=\"text-xs font-medium mb-2\">Enhanced Experience</h3>\n                        <p className=\"text-xs text-muted-foreground font-normal\">\n                          Optional MCP server integration for seamless access in Claude Desktop and other MCP clients.\n                        </p>\n                        <Badge variant=\"outline\" className=\"mt-2\">Progressive enhancement</Badge>\n                      </CardContent>\n                    </Card>\n                  </div>\n\n                  <div className=\"flex justify-between\">\n                    <Button variant=\"outline\" size=\"sm\" className=\"h-7 text-xs\" disabled>Previous</Button>\n                    <Button onClick={() => { markStepComplete('welcome'); setCurrentStep(1); }} size=\"sm\" className=\"h-7 text-xs\">\n                      Create Your First Bundles <ArrowRight className=\"w-3 h-3 ml-1\" />\n                    </Button>\n                  </div>\n                </CardContent>\n              </Card>\n            )}\n\n            {/* Step 2: Create Bundles */}\n            {currentStep === 1 && (\n              <Card>\n                <CardHeader>\n                  <CardTitle className=\"flex items-center gap-2 text-sm font-medium\">\n                    <FolderOpen className=\"w-4 h-4\" />\n                    Create Your First Bundles\n                  </CardTitle>\n                </CardHeader>\n                <CardContent className=\"space-y-6\">\n                  <div>\n                    <p className=\"text-xs text-muted-foreground font-normal mb-4\">\n                      cntx-ui starts with a \"master\" bundle containing all your files. Let's explore the basics\n                      and learn how to create focused bundles for better AI assistance.\n                    </p>\n\n                    <Alert className=\"border-border bg-accent/50\">\n                      <FolderOpen className=\"w-4 h-4\" />\n                      <AlertDescription>\n                        <strong>✅ You're ready to go!</strong> cntx-ui has already created a master bundle with all your project files.\n                        Now let's organize them into meaningful collections.\n                      </AlertDescription>\n                    </Alert>\n                  </div>\n\n                  <div className=\"bg-accent/50 p-4 rounded-lg border\">\n                    <h4 className=\"text-xs font-medium text-foreground mb-3\">Here's the workflow:</h4>\n                    <ol className=\"text-xs text-muted-foreground font-normal space-y-2 list-decimal list-inside\">\n                      <li><strong>Copy the AI analysis prompt</strong> (button below)</li>\n                      <li><strong>Go to Bundles tab</strong> → Copy the \"master\" bundle XML</li>\n                      <li><strong>Open Claude/ChatGPT</strong> → Paste the prompt</li>\n                      <li><strong>Paste your master bundle XML</strong> after the prompt</li>\n                      <li><strong>AI returns perfect bundle JSON</strong> tailored to your code!</li>\n                      <li><strong>Go to Config tab</strong> → Paste the JSON → Apply!</li>\n                    </ol>\n                  </div>\n\n                  <div>\n                    <h4 className=\"text-xs font-medium mb-2\">Step 1: Copy AI Prompt & Master Bundle</h4>\n                    <div className=\"space-y-3\">\n                      <div className=\"bg-card border rounded-lg p-4\">\n                        <div className=\"flex items-center justify-between mb-2\">\n                          <span className=\"text-primary text-xs\">🤖 Smart Bundle Analysis Prompt</span>\n                          <Button\n                            variant=\"ghost\"\n                            size=\"sm\"\n                            className=\"h-7 text-xs text-muted-foreground hover:text-foreground\"\n                            onClick={copyAiPrompt}\n                          >\n                            {aiPromptCopied ? (\n                              <>\n                                <CheckCircle className=\"w-4 h-4 mr-1\" />\n                                Copied!\n                              </>\n                            ) : (\n                              <>\n                                <Copy className=\"w-4 h-4 mr-1\" />\n                                Copy Prompt\n                              </>\n                            )}\n                          </Button>\n                        </div>\n                        <div className=\"text-muted-foreground text-xs font-normal\">\n                          Intelligent prompt that guides AI to analyze your code structure\n                        </div>\n                      </div>\n\n                      <div className=\"bg-card border rounded-lg p-4\">\n                        <div className=\"flex items-center justify-between mb-2\">\n                          <span className=\"text-primary text-xs\">📦 Master Bundle XML</span>\n                          <div className=\"flex gap-2\">\n                            <Button\n                              variant=\"ghost\"\n                              size=\"sm\"\n                              className=\"h-7 text-xs text-muted-foreground hover:text-foreground\"\n                              onClick={copyMasterBundle}\n                            >\n                              {masterBundleCopied ? (\n                                <>\n                                  <CheckCircle className=\"w-4 h-4 mr-1\" />\n                                  Copied!\n                                </>\n                              ) : (\n                                <>\n                                  <Copy className=\"w-4 h-4 mr-1\" />\n                                  Copy XML\n                                </>\n                              )}\n                            </Button>\n                            <Button\n                              variant=\"ghost\"\n                              size=\"sm\"\n                              className=\"h-7 text-xs text-muted-foreground hover:text-foreground\"\n                              onClick={downloadMasterBundle}\n                            >\n                              <Download className=\"w-4 h-4 mr-1\" />\n                              Download\n                            </Button>\n                          </div>\n                        </div>\n                        <div className=\"text-muted-foreground text-xs font-normal\">\n                          Your complete codebase bundle for AI analysis\n                        </div>\n                      </div>\n                    </div>\n                  </div>\n\n                  <div className=\"bg-accent/50 p-4 rounded-lg border\">\n                    <h4 className=\"text-xs font-medium text-foreground mb-2\">🚀 Complete AI Workflow:</h4>\n                    <ol className=\"text-xs text-muted-foreground font-normal space-y-1 list-decimal list-inside\">\n                      <li><strong>Copy the prompt above</strong> → Paste into Claude/ChatGPT</li>\n                      <li><strong>Copy/download master bundle</strong> → Add to your AI conversation</li>\n                      <li><strong>AI analyzes your code</strong> → Returns perfect bundle configuration</li>\n                      <li><strong>Go to Config tab</strong> → Paste AI's JSON → Apply configuration</li>\n                      <li><strong>🎉 Optimized bundles ready!</strong> → Tailored to your project structure</li>\n                    </ol>\n                  </div>\n\n                  <div className=\"grid md:grid-cols-2 gap-4\">\n                    <div className=\"space-y-3\">\n                      <h4 className=\"text-xs font-medium\">What AI Analyzes:</h4>\n                      <div className=\"text-xs space-y-1 text-muted-foreground font-normal\">\n                        <div>🗂️ <strong>File organization patterns</strong></div>\n                        <div>🔗 <strong>Import/dependency relationships</strong></div>\n                        <div>⚙️ <strong>Technology stack detection</strong></div>\n                        <div>📁 <strong>Logical grouping opportunities</strong></div>\n                      </div>\n                    </div>\n\n                    <div className=\"space-y-3\">\n                      <h4 className=\"text-xs font-medium\">AI Suggests Bundles Like:</h4>\n                      <div className=\"text-xs space-y-1 text-muted-foreground font-normal\">\n                        <div>🎨 <strong>frontend</strong> - Components, pages, styles</div>\n                        <div>🔌 <strong>api</strong> - Routes, controllers, models</div>\n                        <div>🧪 <strong>tests</strong> - All test files</div>\n                        <div>⚙️ <strong>config</strong> - Configuration files</div>\n                      </div>\n                    </div>\n                  </div>\n\n                  <Alert>\n                    <AlertTriangle className=\"w-4 h-4\" />\n                    <AlertDescription>\n                      <strong>Why this works so well:</strong> AI understands code patterns and can see relationships\n                      between files that aren't obvious. It creates bundles that actually make sense for your specific project.\n                    </AlertDescription>\n                  </Alert>\n\n                  <div className=\"flex justify-between\">\n                    <Button variant=\"outline\" size=\"sm\" className=\"h-7 text-xs\" onClick={() => setCurrentStep(0)}>Previous</Button>\n                    <Button onClick={() => { markStepComplete('ai-analysis'); setCurrentStep(2); }} size=\"sm\" className=\"h-7 text-xs\">\n                      Continue to Bundle Management <ArrowRight className=\"w-3 h-3 ml-1\" />\n                    </Button>\n                  </div>\n                </CardContent>\n              </Card>\n            )}\n\n            {/* Step 3: Create/Manage Bundles */}\n            {currentStep === 2 && (\n              <Card>\n                <CardHeader>\n                  <CardTitle className=\"flex items-center gap-2 text-sm font-medium\">\n                    <FolderOpen className=\"w-4 h-4\" />\n                    Create & Manage Your Bundles\n                  </CardTitle>\n                </CardHeader>\n                <CardContent className=\"space-y-6\">\n                  <div>\n                    <p className=\"text-xs text-muted-foreground font-normal mb-4\">\n                      Whether you used AI suggestions or want to create bundles manually,\n                      here's how to manage your bundle collection.\n                    </p>\n\n                    <div className=\"bg-accent/50 p-4 rounded-lg border mb-4\">\n                      <h4 className=\"text-xs font-medium text-foreground mb-2\">If you used AI analysis:</h4>\n                      <ol className=\"text-xs text-muted-foreground font-normal space-y-1 list-decimal list-inside\">\n                        <li>Go to the <strong>Config</strong> tab above</li>\n                        <li>Scroll to <strong>\"Paste Bundle Configuration\"</strong></li>\n                        <li>Paste the AI-generated JSON</li>\n                        <li>Click <strong>\"Apply Configuration\"</strong></li>\n                        <li>🎉 Your optimized bundles are ready!</li>\n                      </ol>\n                    </div>\n\n                    <div className=\"bg-accent/50 p-4 rounded-lg border mb-4\">\n                      <h4 className=\"text-xs font-medium text-foreground mb-2\">To create bundles manually:</h4>\n                      <ol className=\"text-xs text-muted-foreground font-normal space-y-1 list-decimal list-inside\">\n                        <li>Go to the <strong>Config</strong> tab above</li>\n                        <li>Click <strong>\"Add New Bundle\"</strong> at the bottom</li>\n                        <li>Name it something meaningful (e.g., \"frontend\", \"api\", \"core\")</li>\n                        <li>Add patterns like <code className=\"bg-muted px-1 rounded\">src/components/**/*</code></li>\n                        <li>Click <strong>\"Create Bundle\"</strong></li>\n                      </ol>\n                    </div>\n\n                    <Alert>\n                      <Sparkles className=\"w-4 h-4\" />\n                      <AlertDescription>\n                        <strong>Pro tip:</strong> You can test patterns before adding them!\n                        Use the \"Pattern Tester\" in the Config tab to see which files match.\n                      </AlertDescription>\n                    </Alert>\n                  </div>\n\n                  <div className=\"space-y-3\">\n                    <h4 className=\"text-xs font-medium\">Popular Manual Bundle Examples:</h4>\n                    <div className=\"grid gap-3\">\n                      <div className=\"bg-muted/50 p-3 rounded-md border\">\n                        <div className=\"font-medium text-xs\">Frontend Bundle</div>\n                        <code className=\"text-xs text-muted-foreground\">src/components/**/* • src/pages/**/* • *.css</code>\n                      </div>\n                      <div className=\"bg-muted/50 p-3 rounded-md border\">\n                        <div className=\"font-medium text-xs\">API Bundle</div>\n                        <code className=\"text-xs text-muted-foreground\">src/api/**/* • src/routes/**/* • src/models/**/*</code>\n                      </div>\n                      <div className=\"bg-muted/50 p-3 rounded-md border\">\n                        <div className=\"font-medium text-xs\">Tests Bundle</div>\n                        <code className=\"text-xs text-muted-foreground\">**/*.test.* • **/*.spec.* • __tests__/**/*</code>\n                      </div>\n                    </div>\n                  </div>\n\n                  <div className=\"flex justify-between\">\n                    <Button variant=\"outline\" size=\"sm\" className=\"h-7 text-xs\" onClick={() => setCurrentStep(1)}>Previous</Button>\n                    <Button onClick={() => { markStepComplete('bundles'); setCurrentStep(3); }} size=\"sm\" className=\"h-7 text-xs\">\n                      Continue to Optimization <ArrowRight className=\"w-3 h-3 ml-1\" />\n                    </Button>\n                  </div>\n                </CardContent>\n              </Card>\n            )}\n\n            {/* Step 4: Optimization */}\n            {currentStep === 3 && (\n              <Card>\n                <CardHeader>\n                  <CardTitle className=\"flex items-center gap-2 text-sm font-medium\">\n                    <Zap className=\"w-4 h-4\" />\n                    Optimize for AI Development\n                  </CardTitle>\n                </CardHeader>\n                <CardContent className=\"space-y-6\">\n                  <div>\n                    <p className=\"text-xs text-muted-foreground font-normal mb-4\">\n                      Now let's make your bundles perfect for AI assistants by controlling what they see.\n                    </p>\n\n                    <div className=\"grid md:grid-cols-2 gap-4\">\n                      <Card className=\"border-border\">\n                        <CardContent className=\"pt-6\">\n                          <Eye className=\"w-8 h-8 text-primary mb-3\" />\n                          <h3 className=\"text-xs font-medium mb-2\">Hidden Files Tab</h3>\n                          <div className=\"text-xs text-muted-foreground font-normal space-y-1\">\n                            <div>• Hide debug files from AI context</div>\n                            <div>• Remove temp/generated files</div>\n                            <div>• Create clean, focused bundles</div>\n                          </div>\n                        </CardContent>\n                      </Card>\n\n                      <Card className=\"border-border\">\n                        <CardContent className=\"pt-6\">\n                          <Sparkles className=\"w-8 h-8 text-primary mb-3\" />\n                          <h3 className=\"text-xs font-medium mb-2\">Cursor Rules Tab</h3>\n                          <div className=\"text-xs text-muted-foreground font-normal space-y-1\">\n                            <div>• Set coding standards</div>\n                            <div>• Define project context</div>\n                            <div>• Guide AI assistant behavior</div>\n                          </div>\n                        </CardContent>\n                      </Card>\n                    </div>\n                  </div>\n\n                  <div className=\"bg-accent/50 p-4 rounded-lg border\">\n                    <h4 className=\"text-xs font-medium text-foreground mb-2\">Try this workflow:</h4>\n                    <ol className=\"text-xs text-muted-foreground font-normal space-y-1 list-decimal list-inside\">\n                      <li>Go to <strong>Hidden Files</strong> tab</li>\n                      <li>Search for \"debug\" or \"test\" files</li>\n                      <li>Hide them from your main bundles</li>\n                      <li>Go to <strong>Cursor Rules</strong> tab</li>\n                      <li>Choose a template that matches your project</li>\n                      <li>Customize the rules for your team's preferences</li>\n                    </ol>\n                  </div>\n\n                  <Alert>\n                    <AlertTriangle className=\"w-4 h-4\" />\n                    <AlertDescription>\n                      <strong>Why this matters:</strong> Clean bundles = better AI responses.\n                      Removing noise helps AI focus on what's actually important in your code.\n                    </AlertDescription>\n                  </Alert>\n\n                  <div className=\"flex justify-between\">\n                    <Button variant=\"outline\" size=\"sm\" className=\"h-7 text-xs\" onClick={() => setCurrentStep(2)}>Previous</Button>\n                    <Button onClick={() => { markStepComplete('optimization'); setCurrentStep(4); }} size=\"sm\" className=\"h-7 text-xs\">\n                      Continue <ArrowRight className=\"w-3 h-3 ml-1\" />\n                    </Button>\n                  </div>\n                </CardContent>\n              </Card>\n            )}\n\n            {/* Step 5: Workflows */}\n            {currentStep === 4 && (\n              <Card>\n                <CardHeader>\n                  <CardTitle className=\"flex items-center gap-2 text-sm font-medium\">\n                    <Play className=\"w-4 h-4\" />\n                    Common Workflows & Next Steps\n                  </CardTitle>\n                </CardHeader>\n                <CardContent className=\"space-y-6\">\n                  <div className=\"grid gap-4\">\n                    <div className=\"bg-accent/50 p-4 rounded-lg border\">\n                      <h4 className=\"text-xs font-medium text-foreground mb-2\">🤖 Using with AI Assistants</h4>\n                      <div className=\"text-xs text-muted-foreground font-normal space-y-1\">\n                        <div>1. Create a focused bundle for your current task</div>\n                        <div>2. Copy the XML from the <strong>Bundles</strong> tab</div>\n                        <div>3. Paste into Claude, ChatGPT, or other AI tools</div>\n                        <div>4. Get more accurate, context-aware responses</div>\n                      </div>\n                    </div>\n\n                    <div className=\"bg-accent/50 p-4 rounded-lg border\">\n                      <h4 className=\"text-xs font-medium text-foreground mb-2\">📁 Organizing Large Projects</h4>\n                      <div className=\"text-xs text-muted-foreground font-normal space-y-1\">\n                        <div>1. Create bundles by feature or team responsibility</div>\n                        <div>2. Use hidden files to exclude work-in-progress code</div>\n                        <div>3. Monitor bundle sizes in the web interface</div>\n                        <div>4. Share specific bundles with team members</div>\n                      </div>\n                    </div>\n\n                    <div className=\"bg-accent/50 p-4 rounded-lg border\">\n                      <h4 className=\"text-xs font-medium text-foreground mb-2\">⚡ Advanced Tips</h4>\n                      <div className=\"text-xs text-muted-foreground font-normal space-y-1\">\n                        <div>• Bundle-specific hiding: Hide files from specific bundles only</div>\n                        <div>• Pattern testing: Use the pattern tester in Config tab</div>\n                        <div>• Real-time updates: Changes appear immediately</div>\n                        <div>• CLI integration: Use commands for automation</div>\n                      </div>\n                    </div>\n                  </div>\n\n                  <div className=\"bg-accent/50 p-4 rounded-lg border\">\n                    <h4 className=\"text-xs font-medium text-foreground mb-2\">🎯 Quick Start Checklist</h4>\n                    <div className=\"text-xs text-muted-foreground font-normal space-y-1\">\n                      <div>✅ Create 2-3 focused bundles</div>\n                      <div>✅ Hide debug/temp files</div>\n                      <div>✅ Set up cursor rules</div>\n                      <div>✅ Copy a bundle and try it with an AI assistant</div>\n                    </div>\n                  </div>\n\n                  <div className=\"flex justify-between\">\n                    <Button variant=\"outline\" size=\"sm\" className=\"h-7 text-xs\" onClick={() => setCurrentStep(3)}>Previous</Button>\n                    <Button onClick={() => markStepComplete('workflows')} size=\"sm\" className=\"h-7 text-xs bg-primary hover:bg-primary/90\">\n                      Get Started! <ExternalLink className=\"w-3 h-3 ml-1\" />\n                    </Button>\n                  </div>\n                </CardContent>\n              </Card>\n            )}\n\n            {/* Quick Reference Card */}\n            <Card>\n              <CardHeader>\n                <CardTitle className=\"text-sm font-medium\">Quick Reference</CardTitle>\n              </CardHeader>\n              <CardContent>\n                <div className=\"grid md:grid-cols-2 gap-4 text-sm\">\n                  <div>\n                    <h4 className=\"text-xs font-medium mb-2\">Web Interface Tabs</h4>\n                    <ul className=\"space-y-1 text-muted-foreground font-normal\">\n                      <li><strong>Bundles</strong> - View and copy bundle content</li>\n                      <li><strong>Files</strong> - Browse your project files</li>\n                      <li><strong>Config</strong> - Create and edit bundles</li>\n                      <li><strong>Hidden</strong> - Control file visibility</li>\n                      <li><strong>Cursor</strong> - Manage AI assistant rules</li>\n                    </ul>\n                  </div>\n                  <div>\n                    <h4 className=\"text-xs font-medium mb-2\">Key Features</h4>\n                    <ul className=\"space-y-1 text-muted-foreground font-normal\">\n                      <li>Real-time file watching and updates</li>\n                      <li>Bundle-specific file hiding</li>\n                      <li>Pattern testing and validation</li>\n                      <li>AI assistant context management</li>\n                      <li>XML export for AI tools</li>\n                    </ul>\n                  </div>\n                </div>\n              </CardContent>\n            </Card>\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/SimpleBundleConfig.tsx\" ext=\".tsx\" role=\"configuration\">\n        <cntx:meta size=\"9309\" modified=\"2025-06-25T06:33:32.771Z\" lines=\"286\" />\n        <cntx:content><![CDATA[import { useState } from 'react'\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'\nimport { Card, CardHeader, CardTitle, CardContent } from './ui/card'\nimport { Button } from './ui/button'\nimport { Input } from './ui/input'\nimport { Badge } from './ui/badge'\nimport { Plus, Save, Trash2, Eye } from 'lucide-react'\nimport { toast } from '@/lib/toast'\n\ninterface BundleConfig {\n  bundles: Record<string, string[]>\n}\n\nconst fetchConfig = async (): Promise<BundleConfig> => {\n  const response = await fetch('http://localhost:3333/api/config')\n  if (!response.ok) throw new Error('Failed to fetch config')\n  return response.json()\n}\n\nconst saveConfig = async (config: BundleConfig): Promise<void> => {\n  const response = await fetch('http://localhost:3333/api/config', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(config)\n  })\n  if (!response.ok) throw new Error('Failed to save config')\n}\n\nconst testPattern = async (pattern: string): Promise<string[]> => {\n  const response = await fetch('http://localhost:3333/api/test-pattern', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ pattern })\n  })\n  if (!response.ok) throw new Error('Failed to test pattern')\n  return response.json()\n}\n\nexport function SimpleBundleConfig() {\n  const queryClient = useQueryClient()\n  const [editingBundle, setEditingBundle] = useState<string | null>(null)\n  const [newBundleName, setNewBundleName] = useState('')\n  const [showAddBundle, setShowAddBundle] = useState(false)\n  const [testingPattern, setTestingPattern] = useState('')\n  const [testResults, setTestResults] = useState<string[]>([])\n\n  const { data: config, isLoading } = useQuery({\n    queryKey: ['config'],\n    queryFn: fetchConfig\n  })\n\n  const saveMutation = useMutation({\n    mutationFn: saveConfig,\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['config'] })\n      queryClient.invalidateQueries({ queryKey: ['bundles'] })\n      setEditingBundle(null)\n      toast.success('Configuration saved!')\n    },\n    onError: (error) => {\n      toast.error(`Failed to save: ${error.message}`)\n    }\n  })\n\n  const handleSave = () => {\n    if (!config) return\n    saveMutation.mutate(config)\n  }\n\n  const handleAddBundle = () => {\n    if (!config || !newBundleName.trim()) return\n    \n    const updatedConfig = {\n      ...config,\n      bundles: {\n        ...config.bundles,\n        [newBundleName]: ['**/*']\n      }\n    }\n    \n    saveMutation.mutate(updatedConfig)\n    setNewBundleName('')\n    setShowAddBundle(false)\n  }\n\n  const handleDeleteBundle = (bundleName: string) => {\n    if (!config) return\n    \n    const { [bundleName]: deleted, ...remainingBundles } = config.bundles\n    const updatedConfig = {\n      ...config,\n      bundles: remainingBundles\n    }\n    \n    saveMutation.mutate(updatedConfig)\n  }\n\n  const handlePatternChange = (bundleName: string, patterns: string[]) => {\n    if (!config) return\n    \n    const updatedConfig = {\n      ...config,\n      bundles: {\n        ...config.bundles,\n        [bundleName]: patterns\n      }\n    }\n    \n    saveMutation.mutate(updatedConfig)\n  }\n\n  const handleTestPattern = async () => {\n    if (!testingPattern.trim()) return\n    \n    try {\n      const results = await testPattern(testingPattern)\n      setTestResults(results)\n    } catch (error) {\n      toast.error('Failed to test pattern')\n    }\n  }\n\n  if (isLoading) {\n    return <div className=\"p-4\">Loading...</div>\n  }\n\n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle className=\"flex items-center justify-between\">\n          Bundle Configuration\n          <Button\n            onClick={handleSave}\n            disabled={saveMutation.isPending}\n            size=\"sm\"\n          >\n            <Save className=\"w-4 h-4 mr-1\" />\n            Save All\n          </Button>\n        </CardTitle>\n      </CardHeader>\n      <CardContent className=\"space-y-6\">\n        {/* Existing Bundles */}\n        <div className=\"space-y-4\">\n          {config && Object.entries(config.bundles).map(([bundleName, patterns]) => (\n            <div key={bundleName} className=\"border rounded-lg p-4\">\n              <div className=\"flex items-center justify-between mb-3\">\n                <h3 className=\"font-medium\">{bundleName}</h3>\n                <div className=\"flex gap-2\">\n                  <Button\n                    variant=\"outline\"\n                    size=\"sm\"\n                    onClick={() => setEditingBundle(editingBundle === bundleName ? null : bundleName)}\n                  >\n                    {editingBundle === bundleName ? 'Done' : 'Edit'}\n                  </Button>\n                  <Button\n                    variant=\"outline\"\n                    size=\"sm\"\n                    onClick={() => handleDeleteBundle(bundleName)}\n                  >\n                    <Trash2 className=\"w-4 h-4\" />\n                  </Button>\n                </div>\n              </div>\n              \n              {editingBundle === bundleName ? (\n                <div className=\"space-y-2\">\n                  {patterns.map((pattern, index) => (\n                    <div key={index} className=\"flex gap-2\">\n                      <Input\n                        value={pattern}\n                        onChange={(e) => {\n                          const newPatterns = [...patterns]\n                          newPatterns[index] = e.target.value\n                          handlePatternChange(bundleName, newPatterns)\n                        }}\n                        placeholder=\"e.g., src/**/*.ts\"\n                      />\n                      {patterns.length > 1 && (\n                        <Button\n                          variant=\"outline\"\n                          size=\"sm\"\n                          onClick={() => {\n                            const newPatterns = patterns.filter((_, i) => i !== index)\n                            handlePatternChange(bundleName, newPatterns)\n                          }}\n                        >\n                          <Trash2 className=\"w-4 h-4\" />\n                        </Button>\n                      )}\n                    </div>\n                  ))}\n                  <Button\n                    variant=\"outline\"\n                    size=\"sm\"\n                    onClick={() => handlePatternChange(bundleName, [...patterns, '**/*'])}\n                  >\n                    <Plus className=\"w-4 h-4 mr-1\" />\n                    Add Pattern\n                  </Button>\n                </div>\n              ) : (\n                <div className=\"flex flex-wrap gap-1\">\n                  {patterns.map((pattern, index) => (\n                    <Badge key={index} variant=\"secondary\">\n                      {pattern}\n                    </Badge>\n                  ))}\n                </div>\n              )}\n            </div>\n          ))}\n        </div>\n\n        {/* Add New Bundle */}\n        {showAddBundle ? (\n          <div className=\"border rounded-lg p-4 bg-muted/50\">\n            <div className=\"space-y-3\">\n              <Input\n                placeholder=\"Bundle name\"\n                value={newBundleName}\n                onChange={(e) => setNewBundleName(e.target.value)}\n              />\n              <div className=\"flex gap-2\">\n                <Button onClick={handleAddBundle} disabled={!newBundleName.trim()}>\n                  Create Bundle\n                </Button>\n                <Button variant=\"outline\" onClick={() => setShowAddBundle(false)}>\n                  Cancel\n                </Button>\n              </div>\n            </div>\n          </div>\n        ) : (\n          <Button\n            variant=\"outline\"\n            onClick={() => setShowAddBundle(true)}\n            className=\"w-full\"\n          >\n            <Plus className=\"w-4 h-4 mr-1\" />\n            Add New Bundle\n          </Button>\n        )}\n\n        {/* Pattern Tester */}\n        <Card>\n          <CardHeader>\n            <CardTitle>Test a Pattern</CardTitle>\n          </CardHeader>\n          <CardContent className=\"space-y-3\">\n            <div className=\"flex gap-2\">\n              <Input\n                placeholder=\"e.g., src/**/*.ts\"\n                value={testingPattern}\n                onChange={(e) => setTestingPattern(e.target.value)}\n              />\n              <Button onClick={handleTestPattern}>\n                <Eye className=\"w-4 h-4 mr-1\" />\n                Test\n              </Button>\n            </div>\n            \n            {testResults.length > 0 && (\n              <div className=\"mt-3\">\n                <p className=\"text-sm text-muted-foreground mb-2\">\n                  Found {testResults.length} files:\n                </p>\n                <div className=\"max-h-32 overflow-y-auto text-xs space-y-1 bg-muted/50 p-2 rounded\">\n                  {testResults.slice(0, 20).map((file, index) => (\n                    <div key={index}>{file}</div>\n                  ))}\n                  {testResults.length > 20 && (\n                    <div className=\"text-muted-foreground\">\n                      ... and {testResults.length - 20} more files\n                    </div>\n                  )}\n                </div>\n              </div>\n            )}\n          </CardContent>\n        </Card>\n      </CardContent>\n    </Card>\n  )\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/theme-provider.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"392\" modified=\"2025-06-25T03:16:23.069Z\" lines=\"15\" />\n        <cntx:content><![CDATA[// web/src/components/theme-provider.tsx\n\"use client\"\n\nimport { ThemeProvider as NextThemesProvider } from \"next-themes\"\nimport { type ReactNode } from \"react\"\n\ninterface ThemeProviderProps {\n  children: ReactNode\n  [key: string]: unknown\n}\n\nexport function ThemeProvider({ children, ...props }: ThemeProviderProps) {\n  return <NextThemesProvider {...props}>{children}</NextThemesProvider>\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/theme-toggle.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"698\" modified=\"2025-06-25T03:28:29.061Z\" lines=\"25\" />\n        <cntx:content><![CDATA[// web/src/components/theme-toggle.tsx\n\"use client\"\n\nimport { Moon, Sun } from \"lucide-react\"\nimport { useTheme } from \"next-themes\"\n\nimport { Button } from \"@/components/ui/button\"\n\nexport function ThemeToggle() {\n  const { theme, setTheme } = useTheme()\n\n  return (\n    <Button\n      variant=\"ghost\"\n      size=\"sm\"\n      onClick={() => setTheme(theme === \"light\" ? \"dark\" : \"light\")}\n      className=\"h-8 w-8 p-0\"\n    >\n      <Sun className=\"h-4 w-4 rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0\" />\n      <Moon className=\"absolute h-4 w-4 rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100\" />\n      <span className=\"sr-only\">Toggle theme</span>\n    </Button>\n  )\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/alert.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"1614\" modified=\"2025-06-06T23:18:00.618Z\" lines=\"67\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst alertVariants = cva(\n  \"relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-card text-card-foreground\",\n        destructive:\n          \"text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nfunction Alert({\n  className,\n  variant,\n  ...props\n}: React.ComponentProps<\"div\"> & VariantProps<typeof alertVariants>) {\n  return (\n    <div\n      data-slot=\"alert\"\n      role=\"alert\"\n      className={cn(alertVariants({ variant }), className)}\n      {...props}\n    />\n  )\n}\n\nfunction AlertTitle({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"alert-title\"\n      className={cn(\n        \"col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction AlertDescription({\n  className,\n  ...props\n}: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"alert-description\"\n      className={cn(\n        \"text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Alert, AlertTitle, AlertDescription }\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/badge.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"1631\" modified=\"2025-06-06T23:02:18.357Z\" lines=\"47\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst badgeVariants = cva(\n  \"inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90\",\n        secondary:\n          \"border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90\",\n        destructive:\n          \"border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60\",\n        outline:\n          \"text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nfunction Badge({\n  className,\n  variant,\n  asChild = false,\n  ...props\n}: React.ComponentProps<\"span\"> &\n  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {\n  const Comp = asChild ? Slot : \"span\"\n\n  return (\n    <Comp\n      data-slot=\"badge\"\n      className={cn(badgeVariants({ variant }), className)}\n      {...props}\n    />\n  )\n}\n\nexport { Badge, badgeVariants }\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/button.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"2123\" modified=\"2025-06-06T23:02:18.326Z\" lines=\"60\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"bg-primary text-primary-foreground shadow-xs hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60\",\n        outline:\n          \"border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50\",\n        secondary:\n          \"bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80\",\n        ghost:\n          \"hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-9 px-4 py-2 has-[>svg]:px-3\",\n        sm: \"h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5\",\n        lg: \"h-10 rounded-md px-6 has-[>svg]:px-4\",\n        icon: \"size-9\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nfunction Button({\n  className,\n  variant,\n  size,\n  asChild = false,\n  ...props\n}: React.ComponentProps<\"button\"> &\n  VariantProps<typeof buttonVariants> & {\n    asChild?: boolean\n  }) {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      data-slot=\"button\"\n      className={cn(buttonVariants({ variant, size, className }))}\n      {...props}\n    />\n  )\n}\n\nexport { Button, buttonVariants }\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/card.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"1989\" modified=\"2025-06-06T22:59:58.927Z\" lines=\"93\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Card({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card\"\n      className={cn(\n        \"bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction CardHeader({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-header\"\n      className={cn(\n        \"@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction CardTitle({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-title\"\n      className={cn(\"leading-none font-semibold\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction CardDescription({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-description\"\n      className={cn(\"text-muted-foreground text-sm\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction CardAction({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-action\"\n      className={cn(\n        \"col-start-2 row-span-2 row-start-1 self-start justify-self-end\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction CardContent({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-content\"\n      className={cn(\"px-6\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction CardFooter({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"card-footer\"\n      className={cn(\"flex items-center px-6 [.border-t]:pt-6\", className)}\n      {...props}\n    />\n  )\n}\n\nexport {\n  Card,\n  CardHeader,\n  CardFooter,\n  CardTitle,\n  CardAction,\n  CardDescription,\n  CardContent,\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/input.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"967\" modified=\"2025-06-06T23:18:00.535Z\" lines=\"22\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Input({ className, type, ...props }: React.ComponentProps<\"input\">) {\n  return (\n    <input\n      type={type}\n      data-slot=\"input\"\n      className={cn(\n        \"file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n        \"focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]\",\n        \"aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Input }\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/label.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"597\" modified=\"2025-06-06T23:18:00.593Z\" lines=\"23\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Label({\n  className,\n  ...props\n}: React.ComponentProps<typeof LabelPrimitive.Root>) {\n  return (\n    <LabelPrimitive.Root\n      data-slot=\"label\"\n      className={cn(\n        \"flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Label }\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/select.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"4353\" modified=\"2025-06-25T16:14:36.394Z\" lines=\"118\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\nimport * as SelectPrimitive from \"@radix-ui/react-select\"\nimport { Check, ChevronDown } from \"lucide-react\"\nimport { cn } from \"@/lib/utils\"\n\nconst Select = SelectPrimitive.Root\n\nconst SelectGroup = SelectPrimitive.Group\n\nconst SelectValue = SelectPrimitive.Value\n\nconst SelectTrigger = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <SelectPrimitive.Icon asChild>\n      <ChevronDown className=\"h-4 w-4 opacity-50\" />\n    </SelectPrimitive.Icon>\n  </SelectPrimitive.Trigger>\n))\nSelectTrigger.displayName = SelectPrimitive.Trigger.displayName\n\nconst SelectContent = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>\n>(({ className, children, position = \"popper\", ...props }, ref) => (\n  <SelectPrimitive.Portal>\n    <SelectPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"relative z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n        position === \"popper\" &&\n          \"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1\",\n        className\n      )}\n      position={position}\n      {...props}\n    >\n      <SelectPrimitive.Viewport\n        className={cn(\n          \"p-1\",\n          position === \"popper\" &&\n            \"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]\"\n        )}\n      >\n        {children}\n      </SelectPrimitive.Viewport>\n    </SelectPrimitive.Content>\n  </SelectPrimitive.Portal>\n))\nSelectContent.displayName = SelectPrimitive.Content.displayName\n\nconst SelectLabel = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Label\n    ref={ref}\n    className={cn(\"py-1.5 pl-8 pr-2 text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nSelectLabel.displayName = SelectPrimitive.Label.displayName\n\nconst SelectItem = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <SelectPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </SelectPrimitive.ItemIndicator>\n    </span>\n\n    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>\n  </SelectPrimitive.Item>\n))\nSelectItem.displayName = SelectPrimitive.Item.displayName\n\nconst SelectSeparator = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nSelectSeparator.displayName = SelectPrimitive.Separator.displayName\n\nexport {\n  Select,\n  SelectGroup,\n  SelectValue,\n  SelectTrigger,\n  SelectContent,\n  SelectLabel,\n  SelectItem,\n  SelectSeparator,\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/sonner.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"1193\" modified=\"2025-06-25T06:26:50.021Z\" lines=\"36\" />\n        <cntx:content><![CDATA[import { useTheme } from \"next-themes\"\nimport { Toaster as Sonner, type ToasterProps } from \"sonner\"\n\nconst Toaster = ({ ...props }: ToasterProps) => {\n  const { theme = \"system\" } = useTheme()\n\n  return (\n    <Sonner\n      theme={theme as ToasterProps[\"theme\"]}\n      className=\"toaster group\"\n      style={\n        {\n          \"--normal-bg\": \"var(--popover)\",\n          \"--normal-text\": \"var(--popover-foreground)\",\n          \"--normal-border\": \"var(--border)\",\n          \"--success-bg\": \"var(--color-success)\",\n          \"--success-text\": \"var(--color-success-foreground)\",\n          \"--success-border\": \"var(--color-success)\",\n          \"--error-bg\": \"var(--destructive)\",\n          \"--error-text\": \"var(--destructive-foreground)\",\n          \"--error-border\": \"var(--destructive)\",\n          \"--info-bg\": \"var(--color-info)\",\n          \"--info-text\": \"var(--color-info-foreground)\",\n          \"--info-border\": \"var(--color-info)\",\n          \"--warning-bg\": \"var(--color-warning)\",\n          \"--warning-text\": \"var(--color-warning-foreground)\",\n          \"--warning-border\": \"var(--color-warning)\",\n        } as React.CSSProperties\n      }\n      {...props}\n    />\n  )\n}\n\nexport { Toaster }\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/tabs.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"1955\" modified=\"2025-06-06T22:59:58.902Z\" lines=\"65\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\nimport * as TabsPrimitive from \"@radix-ui/react-tabs\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Tabs({\n  className,\n  ...props\n}: React.ComponentProps<typeof TabsPrimitive.Root>) {\n  return (\n    <TabsPrimitive.Root\n      data-slot=\"tabs\"\n      className={cn(\"flex flex-col gap-2\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction TabsList({\n  className,\n  ...props\n}: React.ComponentProps<typeof TabsPrimitive.List>) {\n  return (\n    <TabsPrimitive.List\n      data-slot=\"tabs-list\"\n      className={cn(\n        \"bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction TabsTrigger({\n  className,\n  ...props\n}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {\n  return (\n    <TabsPrimitive.Trigger\n      data-slot=\"tabs-trigger\"\n      className={cn(\n        \"data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction TabsContent({\n  className,\n  ...props\n}: React.ComponentProps<typeof TabsPrimitive.Content>) {\n  return (\n    <TabsPrimitive.Content\n      data-slot=\"tabs-content\"\n      className={cn(\"flex-1 outline-none\", className)}\n      {...props}\n    />\n  )\n}\n\nexport { Tabs, TabsList, TabsTrigger, TabsContent }\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/textarea.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"759\" modified=\"2025-06-06T23:18:00.602Z\" lines=\"19\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Textarea({ className, ...props }: React.ComponentProps<\"textarea\">) {\n  return (\n    <textarea\n      data-slot=\"textarea\"\n      className={cn(\n        \"border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Textarea }\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/toast.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"5236\" modified=\"2025-06-25T15:29:16.823Z\" lines=\"132\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\nimport * as ToastPrimitives from \"@radix-ui/react-toast\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { X } from \"lucide-react\"\nimport { cn } from \"@/lib/utils\"\n\nconst toastVariants = cva(\n  \"group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full\",\n  {\n    variants: {\n      variant: {\n        default: \"border bg-background text-foreground\",\n        destructive:\n          \"destructive border-destructive bg-destructive text-destructive-foreground\",\n        success:\n          \"border-[color:var(--color-success)]/20 bg-[color:var(--color-success)]/5 text-[color:var(--color-success)]\",\n        warning:\n          \"border-[color:var(--color-warning)]/20 bg-[color:var(--color-warning)]/5 text-[color:var(--color-warning)]\",\n        info:\n          \"border-[color:var(--color-info)]/20 bg-[color:var(--color-info)]/5 text-[color:var(--color-info)]\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nconst ToastProvider = ToastPrimitives.Provider\n\nconst ToastViewport = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Viewport>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Viewport\n    ref={ref}\n    className={cn(\n      \"fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]\",\n      className\n    )}\n    {...props}\n  />\n))\nToastViewport.displayName = ToastPrimitives.Viewport.displayName\n\nconst Toast = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Root>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &\n    VariantProps<typeof toastVariants>\n>(({ className, variant, ...props }, ref) => {\n  return (\n    <ToastPrimitives.Root\n      ref={ref}\n      className={cn(toastVariants({ variant }), className)}\n      {...props}\n    />\n  )\n})\nToast.displayName = ToastPrimitives.Root.displayName\n\nconst ToastAction = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Action>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Action\n    ref={ref}\n    className={cn(\n      \"inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive\",\n      className\n    )}\n    {...props}\n  />\n))\nToastAction.displayName = ToastPrimitives.Action.displayName\n\nconst ToastClose = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Close>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Close\n    ref={ref}\n    className={cn(\n      \"absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600\",\n      className\n    )}\n    toast-close=\"\"\n    {...props}\n  >\n    <X className=\"h-4 w-4\" />\n  </ToastPrimitives.Close>\n))\nToastClose.displayName = ToastPrimitives.Close.displayName\n\nconst ToastTitle = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Title>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Title\n    ref={ref}\n    className={cn(\"text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nToastTitle.displayName = ToastPrimitives.Title.displayName\n\nconst ToastDescription = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Description>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Description\n    ref={ref}\n    className={cn(\"text-sm opacity-90\", className)}\n    {...props}\n  />\n))\nToastDescription.displayName = ToastPrimitives.Description.displayName\n\ntype ToastProps = React.ComponentPropsWithoutRef<typeof Toast>\n\ntype ToastActionElement = React.ReactElement<typeof ToastAction>\n\nexport {\n  type ToastProps,\n  type ToastActionElement,\n  ToastProvider,\n  ToastViewport,\n  Toast,\n  ToastAction,\n  ToastClose,\n  ToastTitle,\n  ToastDescription,\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/toaster.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"771\" modified=\"2025-06-25T15:29:30.977Z\" lines=\"33\" />\n        <cntx:content><![CDATA[import {\n  Toast,\n  ToastClose,\n  ToastDescription,\n  ToastProvider,\n  ToastTitle,\n  ToastViewport,\n} from \"@/components/ui/toast\"\nimport { useToast } from \"@/hooks/use-toast\"\n\nexport function Toaster() {\n  const { toasts } = useToast()\n\n  return (\n    <ToastProvider>\n      {toasts.map(function ({ id, title, description, action, ...props }) {\n        return (\n          <Toast key={id} {...props}>\n            <div className=\"grid gap-1\">\n              {title && <ToastTitle>{title}</ToastTitle>}\n              {description && (\n                <ToastDescription>{description}</ToastDescription>\n              )}\n            </div>\n            {action}\n            <ToastClose />\n          </Toast>\n        )\n      })}\n      <ToastViewport />\n    </ToastProvider>\n  )\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/utils/buttonHelpers.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"987\" modified=\"2025-06-25T06:22:12.459Z\" lines=\"28\" />\n        <cntx:content><![CDATA[// utils/buttonHelpers.tsx\nimport { Loader2, CheckCircle, AlertCircle } from 'lucide-react'\nimport type { ButtonState } from '../hooks/useButtonFeedback'\n\nexport function getButtonIcon(state: ButtonState, defaultIcon: React.ReactNode) {\n  switch (state) {\n    case 'loading':\n      return <Loader2 className=\"w-4 h-4 animate-spin\" />\n    case 'success':\n      return <CheckCircle className=\"w-4 h-4 text-[color:var(--color-success)]\" />\n    case 'error':\n      return <AlertCircle className=\"w-4 h-4 text-destructive\" />\n    default:\n      return defaultIcon\n  }\n}\n\nexport function getButtonClassName(state: ButtonState, baseClassName = '') {\n  const stateClasses = {\n    loading: 'opacity-75',\n    success: 'border-[color:var(--color-success)]/50 bg-[color:var(--color-success)]/5 text-[color:var(--color-success)]',\n    error: 'border-destructive/50 bg-destructive/5 text-destructive',\n    idle: ''\n  }\n\n  return `transition-all duration-200 ${baseClassName} ${stateClasses[state]}`\n}\n]]></cntx:content>\n      </cntx:file>\n    </cntx:group>\n    <cntx:group type=\"hooks\" description=\"Custom React hooks and state management\">\n      <cntx:file path=\"web/src/hooks/use-toast.ts\" ext=\".ts\">\n        <cntx:meta size=\"3890\" modified=\"2025-06-25T15:26:00.144Z\" lines=\"190\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\nimport type {\n  ToastActionElement,\n  ToastProps,\n} from \"@/components/ui/toast\"\n\nconst TOAST_LIMIT = 3\nconst TOAST_REMOVE_DELAY = 5000\n\ntype ToasterToast = ToastProps & {\n  id: string\n  title?: React.ReactNode\n  description?: React.ReactNode\n  action?: ToastActionElement\n}\n\nconst actionTypes = {\n  ADD_TOAST: \"ADD_TOAST\",\n  UPDATE_TOAST: \"UPDATE_TOAST\",\n  DISMISS_TOAST: \"DISMISS_TOAST\",\n  REMOVE_TOAST: \"REMOVE_TOAST\",\n} as const\n\nlet count = 0\n\nfunction genId() {\n  count = (count + 1) % Number.MAX_SAFE_INTEGER\n  return count.toString()\n}\n\ntype ActionType = typeof actionTypes\n\ntype Action =\n  | {\n      type: ActionType[\"ADD_TOAST\"]\n      toast: ToasterToast\n    }\n  | {\n      type: ActionType[\"UPDATE_TOAST\"]\n      toast: Partial<ToasterToast>\n    }\n  | {\n      type: ActionType[\"DISMISS_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n  | {\n      type: ActionType[\"REMOVE_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n\ninterface State {\n  toasts: ToasterToast[]\n}\n\nconst toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()\n\nconst addToRemoveQueue = (toastId: string) => {\n  if (toastTimeouts.has(toastId)) {\n    return\n  }\n\n  const timeout = setTimeout(() => {\n    toastTimeouts.delete(toastId)\n    dispatch({\n      type: \"REMOVE_TOAST\",\n      toastId: toastId,\n    })\n  }, TOAST_REMOVE_DELAY)\n\n  toastTimeouts.set(toastId, timeout)\n}\n\nexport const reducer = (state: State, action: Action): State => {\n  switch (action.type) {\n    case \"ADD_TOAST\":\n      return {\n        ...state,\n        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),\n      }\n\n    case \"UPDATE_TOAST\":\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === action.toast.id ? { ...t, ...action.toast } : t\n        ),\n      }\n\n    case \"DISMISS_TOAST\": {\n      const { toastId } = action\n\n      // ! Side effects ! - This could be extracted into a dismissToast() action,\n      // but I'll keep it here for simplicity\n      if (toastId) {\n        addToRemoveQueue(toastId)\n      } else {\n        state.toasts.forEach((toast) => {\n          addToRemoveQueue(toast.id)\n        })\n      }\n\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === toastId || toastId === undefined\n            ? {\n                ...t,\n                open: false,\n              }\n            : t\n        ),\n      }\n    }\n    case \"REMOVE_TOAST\":\n      if (action.toastId === undefined) {\n        return {\n          ...state,\n          toasts: [],\n        }\n      }\n      return {\n        ...state,\n        toasts: state.toasts.filter((t) => t.id !== action.toastId),\n      }\n  }\n}\n\nconst listeners: Array<(state: State) => void> = []\n\nlet memoryState: State = { toasts: [] }\n\nfunction dispatch(action: Action) {\n  memoryState = reducer(memoryState, action)\n  listeners.forEach((listener) => {\n    listener(memoryState)\n  })\n}\n\ntype Toast = Omit<ToasterToast, \"id\">\n\nfunction toast({ ...props }: Toast) {\n  const id = genId()\n\n  const update = (props: ToasterToast) =>\n    dispatch({\n      type: \"UPDATE_TOAST\",\n      toast: { ...props, id },\n    })\n  const dismiss = () => dispatch({ type: \"DISMISS_TOAST\", toastId: id })\n\n  dispatch({\n    type: \"ADD_TOAST\",\n    toast: {\n      ...props,\n      id,\n      open: true,\n      onOpenChange: (open) => {\n        if (!open) dismiss()\n      },\n    },\n  })\n\n  return {\n    id: id,\n    dismiss,\n    update,\n  }\n}\n\nfunction useToast() {\n  const [state, setState] = React.useState<State>(memoryState)\n\n  React.useEffect(() => {\n    listeners.push(setState)\n    return () => {\n      const index = listeners.indexOf(setState)\n      if (index > -1) {\n        listeners.splice(index, 1)\n      }\n    }\n  }, [state])\n\n  return {\n    ...state,\n    toast,\n    dismiss: (toastId?: string) => dispatch({ type: \"DISMISS_TOAST\", toastId }),\n  }\n}\n\nexport { useToast, toast }]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/hooks/useButtonFeedback.ts\" ext=\".ts\">\n        <cntx:meta size=\"1123\" modified=\"2025-06-07T01:43:23.151Z\" lines=\"42\" />\n        <cntx:content><![CDATA[// hooks/useButtonFeedback.ts\nimport { useState } from 'react'\n\nexport type ButtonState = 'idle' | 'loading' | 'success' | 'error'\n\nexport function useButtonFeedback() {\n  const [buttonStates, setButtonStates] = useState<Record<string, ButtonState>>(\n    {}\n  )\n\n  const setButtonState = (key: string, state: ButtonState) => {\n    setButtonStates((prev) => ({ ...prev, [key]: state }))\n\n    // Auto-clear success/error states\n    if (state === 'success') {\n      setTimeout(() => {\n        setButtonStates((prev) => ({ ...prev, [key]: 'idle' }))\n      }, 2000)\n    } else if (state === 'error') {\n      setTimeout(() => {\n        setButtonStates((prev) => ({ ...prev, [key]: 'idle' }))\n      }, 3000)\n    }\n  }\n\n  const getButtonState = (key: string): ButtonState => {\n    return buttonStates[key] || 'idle'\n  }\n\n  const isLoading = (key: string) => getButtonState(key) === 'loading'\n  const isSuccess = (key: string) => getButtonState(key) === 'success'\n  const isError = (key: string) => getButtonState(key) === 'error'\n\n  return {\n    setButtonState,\n    getButtonState,\n    isLoading,\n    isSuccess,\n    isError,\n  }\n}\n]]></cntx:content>\n      </cntx:file>\n    </cntx:group>\n    <cntx:group type=\"utilities\" description=\"Helper functions, utilities, and shared libraries\">\n      <cntx:file path=\"web/src/lib/toast.ts\" ext=\".ts\">\n        <cntx:meta size=\"709\" modified=\"2025-06-25T06:31:06.099Z\" lines=\"32\" />\n        <cntx:content><![CDATA[import { toast as baseToast } from \"@/hooks/use-toast\"\n\nexport const toast = {\n  success: (message: string, description?: string) => {\n    return baseToast({\n      variant: \"success\",\n      title: message,\n      description,\n    })\n  },\n  error: (message: string, description?: string) => {\n    return baseToast({\n      variant: \"destructive\",\n      title: message,\n      description,\n    })\n  },\n  info: (message: string, description?: string) => {\n    return baseToast({\n      variant: \"info\",\n      title: message,\n      description,\n    })\n  },\n  warning: (message: string, description?: string) => {\n    return baseToast({\n      variant: \"warning\", \n      title: message,\n      description,\n    })\n  },\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/lib/utils.ts\" ext=\".ts\">\n        <cntx:meta size=\"166\" modified=\"2025-06-06T22:59:49.030Z\" lines=\"7\" />\n        <cntx:content><![CDATA[import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n]]></cntx:content>\n      </cntx:file>\n    </cntx:group>\n    <cntx:group type=\"other\" description=\"Additional project files\">\n      <cntx:file path=\"web/src/vite-env.d.ts\" ext=\".ts\">\n        <cntx:meta size=\"38\" modified=\"2025-06-06T22:55:53.337Z\" lines=\"2\" />\n        <cntx:content><![CDATA[/// <reference types=\"vite/client\" />\n]]></cntx:content>\n      </cntx:file>\n    </cntx:group>\n  </cntx:files>\n</cntx:bundle>",
    "lastGenerated": "2025-06-26T23:06:23.733Z",
    "size": 283336
  },
  "ui-components": {
    "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<cntx:bundle xmlns:cntx=\"https://cntx.dev/schema\" name=\"ui-components\" generated=\"2025-06-26T23:00:14.460Z\">\n  <cntx:project>\n    <cntx:name>cntx-ui</cntx:name>\n    <cntx:version>2.0.12</cntx:version>\n    <cntx:description>File context management tool with web UI and MCP server for AI development workflows - bundle project files for LLM consumption</cntx:description>\n  </cntx:project>\n  <cntx:overview>\n    <cntx:purpose>User interface components and design system elements</cntx:purpose>\n    <cntx:file-types>\n      <cntx:type name=\"components\" count=\"7\" />\n    </cntx:file-types>\n  </cntx:overview>\n  <cntx:files count=\"7\">\n    <cntx:group type=\"components\" description=\"React/UI components and interface elements\">\n      <cntx:file path=\"web/src/components/ui/button.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"2123\" modified=\"2025-06-06T23:02:18.326Z\" lines=\"60\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"bg-primary text-primary-foreground shadow-xs hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60\",\n        outline:\n          \"border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50\",\n        secondary:\n          \"bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80\",\n        ghost:\n          \"hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-9 px-4 py-2 has-[>svg]:px-3\",\n        sm: \"h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5\",\n        lg: \"h-10 rounded-md px-6 has-[>svg]:px-4\",\n        icon: \"size-9\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nfunction Button({\n  className,\n  variant,\n  size,\n  asChild = false,\n  ...props\n}: React.ComponentProps<\"button\"> &\n  VariantProps<typeof buttonVariants> & {\n    asChild?: boolean\n  }) {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      data-slot=\"button\"\n      className={cn(buttonVariants({ variant, size, className }))}\n      {...props}\n    />\n  )\n}\n\nexport { Button, buttonVariants }\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/input.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"967\" modified=\"2025-06-06T23:18:00.535Z\" lines=\"22\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Input({ className, type, ...props }: React.ComponentProps<\"input\">) {\n  return (\n    <input\n      type={type}\n      data-slot=\"input\"\n      className={cn(\n        \"file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n        \"focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]\",\n        \"aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Input }\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/select.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"4353\" modified=\"2025-06-25T16:14:36.394Z\" lines=\"118\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\nimport * as SelectPrimitive from \"@radix-ui/react-select\"\nimport { Check, ChevronDown } from \"lucide-react\"\nimport { cn } from \"@/lib/utils\"\n\nconst Select = SelectPrimitive.Root\n\nconst SelectGroup = SelectPrimitive.Group\n\nconst SelectValue = SelectPrimitive.Value\n\nconst SelectTrigger = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <SelectPrimitive.Icon asChild>\n      <ChevronDown className=\"h-4 w-4 opacity-50\" />\n    </SelectPrimitive.Icon>\n  </SelectPrimitive.Trigger>\n))\nSelectTrigger.displayName = SelectPrimitive.Trigger.displayName\n\nconst SelectContent = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>\n>(({ className, children, position = \"popper\", ...props }, ref) => (\n  <SelectPrimitive.Portal>\n    <SelectPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"relative z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n        position === \"popper\" &&\n          \"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1\",\n        className\n      )}\n      position={position}\n      {...props}\n    >\n      <SelectPrimitive.Viewport\n        className={cn(\n          \"p-1\",\n          position === \"popper\" &&\n            \"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]\"\n        )}\n      >\n        {children}\n      </SelectPrimitive.Viewport>\n    </SelectPrimitive.Content>\n  </SelectPrimitive.Portal>\n))\nSelectContent.displayName = SelectPrimitive.Content.displayName\n\nconst SelectLabel = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Label\n    ref={ref}\n    className={cn(\"py-1.5 pl-8 pr-2 text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nSelectLabel.displayName = SelectPrimitive.Label.displayName\n\nconst SelectItem = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <SelectPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </SelectPrimitive.ItemIndicator>\n    </span>\n\n    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>\n  </SelectPrimitive.Item>\n))\nSelectItem.displayName = SelectPrimitive.Item.displayName\n\nconst SelectSeparator = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nSelectSeparator.displayName = SelectPrimitive.Separator.displayName\n\nexport {\n  Select,\n  SelectGroup,\n  SelectValue,\n  SelectTrigger,\n  SelectContent,\n  SelectLabel,\n  SelectItem,\n  SelectSeparator,\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/tabs.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"1955\" modified=\"2025-06-06T22:59:58.902Z\" lines=\"65\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\nimport * as TabsPrimitive from \"@radix-ui/react-tabs\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Tabs({\n  className,\n  ...props\n}: React.ComponentProps<typeof TabsPrimitive.Root>) {\n  return (\n    <TabsPrimitive.Root\n      data-slot=\"tabs\"\n      className={cn(\"flex flex-col gap-2\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction TabsList({\n  className,\n  ...props\n}: React.ComponentProps<typeof TabsPrimitive.List>) {\n  return (\n    <TabsPrimitive.List\n      data-slot=\"tabs-list\"\n      className={cn(\n        \"bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction TabsTrigger({\n  className,\n  ...props\n}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {\n  return (\n    <TabsPrimitive.Trigger\n      data-slot=\"tabs-trigger\"\n      className={cn(\n        \"data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction TabsContent({\n  className,\n  ...props\n}: React.ComponentProps<typeof TabsPrimitive.Content>) {\n  return (\n    <TabsPrimitive.Content\n      data-slot=\"tabs-content\"\n      className={cn(\"flex-1 outline-none\", className)}\n      {...props}\n    />\n  )\n}\n\nexport { Tabs, TabsList, TabsTrigger, TabsContent }\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/textarea.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"759\" modified=\"2025-06-06T23:18:00.602Z\" lines=\"19\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Textarea({ className, ...props }: React.ComponentProps<\"textarea\">) {\n  return (\n    <textarea\n      data-slot=\"textarea\"\n      className={cn(\n        \"border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Textarea }\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/toast.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"5236\" modified=\"2025-06-25T15:29:16.823Z\" lines=\"132\" />\n        <cntx:content><![CDATA[import * as React from \"react\"\nimport * as ToastPrimitives from \"@radix-ui/react-toast\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { X } from \"lucide-react\"\nimport { cn } from \"@/lib/utils\"\n\nconst toastVariants = cva(\n  \"group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full\",\n  {\n    variants: {\n      variant: {\n        default: \"border bg-background text-foreground\",\n        destructive:\n          \"destructive border-destructive bg-destructive text-destructive-foreground\",\n        success:\n          \"border-[color:var(--color-success)]/20 bg-[color:var(--color-success)]/5 text-[color:var(--color-success)]\",\n        warning:\n          \"border-[color:var(--color-warning)]/20 bg-[color:var(--color-warning)]/5 text-[color:var(--color-warning)]\",\n        info:\n          \"border-[color:var(--color-info)]/20 bg-[color:var(--color-info)]/5 text-[color:var(--color-info)]\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nconst ToastProvider = ToastPrimitives.Provider\n\nconst ToastViewport = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Viewport>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Viewport\n    ref={ref}\n    className={cn(\n      \"fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]\",\n      className\n    )}\n    {...props}\n  />\n))\nToastViewport.displayName = ToastPrimitives.Viewport.displayName\n\nconst Toast = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Root>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &\n    VariantProps<typeof toastVariants>\n>(({ className, variant, ...props }, ref) => {\n  return (\n    <ToastPrimitives.Root\n      ref={ref}\n      className={cn(toastVariants({ variant }), className)}\n      {...props}\n    />\n  )\n})\nToast.displayName = ToastPrimitives.Root.displayName\n\nconst ToastAction = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Action>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Action\n    ref={ref}\n    className={cn(\n      \"inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive\",\n      className\n    )}\n    {...props}\n  />\n))\nToastAction.displayName = ToastPrimitives.Action.displayName\n\nconst ToastClose = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Close>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Close\n    ref={ref}\n    className={cn(\n      \"absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600\",\n      className\n    )}\n    toast-close=\"\"\n    {...props}\n  >\n    <X className=\"h-4 w-4\" />\n  </ToastPrimitives.Close>\n))\nToastClose.displayName = ToastPrimitives.Close.displayName\n\nconst ToastTitle = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Title>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Title\n    ref={ref}\n    className={cn(\"text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nToastTitle.displayName = ToastPrimitives.Title.displayName\n\nconst ToastDescription = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Description>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Description\n    ref={ref}\n    className={cn(\"text-sm opacity-90\", className)}\n    {...props}\n  />\n))\nToastDescription.displayName = ToastPrimitives.Description.displayName\n\ntype ToastProps = React.ComponentPropsWithoutRef<typeof Toast>\n\ntype ToastActionElement = React.ReactElement<typeof ToastAction>\n\nexport {\n  type ToastProps,\n  type ToastActionElement,\n  ToastProvider,\n  ToastViewport,\n  Toast,\n  ToastAction,\n  ToastClose,\n  ToastTitle,\n  ToastDescription,\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/src/components/ui/toaster.tsx\" ext=\".tsx\">\n        <cntx:meta size=\"771\" modified=\"2025-06-25T15:29:30.977Z\" lines=\"33\" />\n        <cntx:content><![CDATA[import {\n  Toast,\n  ToastClose,\n  ToastDescription,\n  ToastProvider,\n  ToastTitle,\n  ToastViewport,\n} from \"@/components/ui/toast\"\nimport { useToast } from \"@/hooks/use-toast\"\n\nexport function Toaster() {\n  const { toasts } = useToast()\n\n  return (\n    <ToastProvider>\n      {toasts.map(function ({ id, title, description, action, ...props }) {\n        return (\n          <Toast key={id} {...props}>\n            <div className=\"grid gap-1\">\n              {title && <ToastTitle>{title}</ToastTitle>}\n              {description && (\n                <ToastDescription>{description}</ToastDescription>\n              )}\n            </div>\n            {action}\n            <ToastClose />\n          </Toast>\n        )\n      })}\n      <ToastViewport />\n    </ToastProvider>\n  )\n}]]></cntx:content>\n      </cntx:file>\n    </cntx:group>\n  </cntx:files>\n</cntx:bundle>",
    "lastGenerated": "2025-06-26T23:00:14.461Z",
    "size": 18503
  },
  "config": {
    "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<cntx:bundle xmlns:cntx=\"https://cntx.dev/schema\" name=\"config\" generated=\"2025-06-26T23:00:14.472Z\">\n  <cntx:project>\n    <cntx:name>cntx-ui</cntx:name>\n    <cntx:version>2.0.12</cntx:version>\n    <cntx:description>File context management tool with web UI and MCP server for AI development workflows - bundle project files for LLM consumption</cntx:description>\n  </cntx:project>\n  <cntx:overview>\n    <cntx:purpose>Configuration files, settings, and environment setup</cntx:purpose>\n    <cntx:file-types>\n      <cntx:type name=\"components\" count=\"1\" />\n      <cntx:type name=\"configuration\" count=\"9\" />\n      <cntx:type name=\"tests\" count=\"1\" />\n      <cntx:type name=\"other\" count=\"2\" />\n    </cntx:file-types>\n    <cntx:entry-points>\n      <cntx:file>web/tsconfig.app.json</cntx:file>\n    </cntx:entry-points>\n  </cntx:overview>\n  <cntx:files count=\"13\">\n    <cntx:group type=\"entry-points\" description=\"Main entry files for this bundle\">\n      <cntx:file path=\"web/tsconfig.app.json\" ext=\".json\" role=\"main-component\">\n        <cntx:meta size=\"756\" modified=\"2025-06-26T17:24:03.858Z\" lines=\"33\" />\n        <cntx:content><![CDATA[{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/*\": [\n        \"./src/*\"\n      ]\n    },\n    \"tsBuildInfoFile\": \"./node_modules/.tmp/tsconfig.app.tsbuildinfo\",\n    \"target\": \"ES2020\",\n    \"useDefineForClassFields\": true,\n    \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"],\n    \"module\": \"ESNext\",\n    \"skipLibCheck\": true,\n\n    /* Bundler mode */\n    \"moduleResolution\": \"bundler\",\n    \"allowImportingTsExtensions\": true,\n    \"verbatimModuleSyntax\": true,\n    \"moduleDetection\": \"force\",\n    \"noEmit\": true,\n    \"jsx\": \"react-jsx\",\n\n    /* Linting */\n    \"strict\": false,\n    \"noUnusedLocals\": false,\n    \"noUnusedParameters\": false,\n    \"noFallthroughCasesInSwitch\": true,\n    \"noUncheckedSideEffectImports\": true\n  },\n  \"include\": [\"src\"]\n}\n]]></cntx:content>\n      </cntx:file>\n    </cntx:group>\n    <cntx:group type=\"components\" description=\"React/UI components and interface elements\">\n      <cntx:file path=\"web/components.json\" ext=\".json\">\n        <cntx:meta size=\"423\" modified=\"2025-06-06T22:59:43.333Z\" lines=\"21\" />\n        <cntx:content><![CDATA[{\n  \"$schema\": \"https://ui.shadcn.com/schema.json\",\n  \"style\": \"new-york\",\n  \"rsc\": false,\n  \"tsx\": true,\n  \"tailwind\": {\n    \"config\": \"\",\n    \"css\": \"src/index.css\",\n    \"baseColor\": \"slate\",\n    \"cssVariables\": true,\n    \"prefix\": \"\"\n  },\n  \"aliases\": {\n    \"components\": \"@/components\",\n    \"utils\": \"@/lib/utils\",\n    \"ui\": \"@/components/ui\",\n    \"lib\": \"@/lib\",\n    \"hooks\": \"@/hooks\"\n  },\n  \"iconLibrary\": \"lucide\"\n}]]></cntx:content>\n      </cntx:file>\n    </cntx:group>\n    <cntx:group type=\"configuration\" description=\"Configuration files, settings, and build configs\">\n      <cntx:file path=\"mcp-config-example.json\" ext=\".json\" role=\"configuration\">\n        <cntx:meta size=\"129\" modified=\"2025-06-18T12:09:04.597Z\" lines=\"9\" />\n        <cntx:content><![CDATA[{\n  \"mcpServers\": {\n    \"cntx-ui\": {\n      \"command\": \"cntx-ui\",\n      \"args\": [\"mcp\"],\n      \"cwd\": \"{{projectDir}}\"\n    }\n  }\n}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"package.json\" ext=\".json\" role=\"package-config\">\n        <cntx:meta size=\"1451\" modified=\"2025-06-26T18:47:25.767Z\" lines=\"60\" />\n        <cntx:content><![CDATA[{\n  \"name\": \"cntx-ui\",\n  \"type\": \"module\",\n  \"version\": \"2.0.12\",\n  \"description\": \"File context management tool with web UI and MCP server for AI development workflows - bundle project files for LLM consumption\",\n  \"keywords\": [\n    \"ai-development\",\n    \"mcp-server\",\n    \"file-bundling\",\n    \"context-management\",\n    \"llm-tools\",\n    \"claude-desktop\",\n    \"model-context-protocol\",\n    \"file-aggregation\",\n    \"project-context\",\n    \"ai-workflow\",\n    \"codebase-bundling\",\n    \"development-tools\",\n    \"websocket\",\n    \"react\",\n    \"cli-tool\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/nothingdao/cntx-ui.git\"\n  },\n  \"author\": \"whaleen\",\n  \"license\": \"MIT\",\n  \"bin\": {\n    \"cntx-ui\": \"./bin/cntx-ui.js\"\n  },\n  \"files\": [\n    \"bin/cntx-ui.js\",\n    \"server.js\",\n    \"lib/\",\n    \"README.md\",\n    \"web/dist\",\n    \"mcp-config-example.json\"\n  ],\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  },\n  \"scripts\": {\n    \"dev\": \"node server.js\",\n    \"build\": \"cd web && npm install && npm run build\",\n    \"build:web\": \"cd web && npm install && npm run build\",\n    \"dev:web\": \"cd web && npm run dev\",\n    \"prebuild\": \"npm run build:web\",\n    \"prepublishOnly\": \"npm run build:web\",\n    \"test:local\": \"npm pack && npm install -g ./cntx-ui-2.0.0.tgz\"\n  },\n  \"dependencies\": {\n    \"glob\": \"^8.1.0\",\n    \"tree-sitter\": \"^0.21.1\",\n    \"tree-sitter-javascript\": \"^0.23.1\",\n    \"tree-sitter-typescript\": \"^0.23.2\",\n    \"ws\": \"^8.13.0\"\n  }\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"test-mcp.json\" ext=\".json\">\n        <cntx:meta size=\"153\" modified=\"2025-06-25T01:57:16.148Z\" lines=\"1\" />\n        <cntx:content><![CDATA[{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"initialize\",\"params\":{\"protocolVersion\":\"2024-11-05\",\"capabilities\":{},\"clientInfo\":{\"name\":\"test\",\"version\":\"1.0.0\"}}}]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/eslint.config.js\" ext=\".js\" role=\"configuration\">\n        <cntx:meta size=\"734\" modified=\"2025-06-06T22:55:53.330Z\" lines=\"29\" />\n        <cntx:content><![CDATA[import js from '@eslint/js'\nimport globals from 'globals'\nimport reactHooks from 'eslint-plugin-react-hooks'\nimport reactRefresh from 'eslint-plugin-react-refresh'\nimport tseslint from 'typescript-eslint'\n\nexport default tseslint.config(\n  { ignores: ['dist'] },\n  {\n    extends: [js.configs.recommended, ...tseslint.configs.recommended],\n    files: ['**/*.{ts,tsx}'],\n    languageOptions: {\n      ecmaVersion: 2020,\n      globals: globals.browser,\n    },\n    plugins: {\n      'react-hooks': reactHooks,\n      'react-refresh': reactRefresh,\n    },\n    rules: {\n      ...reactHooks.configs.recommended.rules,\n      'react-refresh/only-export-components': [\n        'warn',\n        { allowConstantExport: true },\n      ],\n    },\n  },\n)\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/package.json\" ext=\".json\" role=\"package-config\">\n        <cntx:meta size=\"1218\" modified=\"2025-06-25T16:13:53.050Z\" lines=\"46\" />\n        <cntx:content><![CDATA[{\n  \"name\": \"web\",\n  \"private\": true,\n  \"version\": \"0.0.0\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"vite\",\n    \"build\": \"tsc -b && vite build\",\n    \"lint\": \"eslint .\",\n    \"preview\": \"vite preview\"\n  },\n  \"dependencies\": {\n    \"@radix-ui/react-label\": \"^2.1.7\",\n    \"@radix-ui/react-select\": \"^2.2.5\",\n    \"@radix-ui/react-slot\": \"^1.2.3\",\n    \"@radix-ui/react-tabs\": \"^1.1.12\",\n    \"@radix-ui/react-toast\": \"^1.2.14\",\n    \"@tailwindcss/vite\": \"^4.1.8\",\n    \"@tanstack/react-query\": \"^5.80.6\",\n    \"class-variance-authority\": \"^0.7.1\",\n    \"clsx\": \"^2.1.1\",\n    \"lucide-react\": \"^0.513.0\",\n    \"next-themes\": \"^0.4.6\",\n    \"react\": \"^19.1.0\",\n    \"react-dom\": \"^19.1.0\",\n    \"sonner\": \"^2.0.5\",\n    \"tailwind-merge\": \"^3.3.0\",\n    \"tailwindcss\": \"^4.1.8\"\n  },\n  \"devDependencies\": {\n    \"@eslint/js\": \"^9.25.0\",\n    \"@types/node\": \"^22.15.30\",\n    \"@types/react\": \"^19.1.2\",\n    \"@types/react-dom\": \"^19.1.2\",\n    \"@vitejs/plugin-react\": \"^4.4.1\",\n    \"eslint\": \"^9.25.0\",\n    \"eslint-plugin-react-hooks\": \"^5.2.0\",\n    \"eslint-plugin-react-refresh\": \"^0.4.19\",\n    \"globals\": \"^16.0.0\",\n    \"tw-animate-css\": \"^1.3.4\",\n    \"typescript\": \"~5.8.3\",\n    \"typescript-eslint\": \"^8.30.1\",\n    \"vite\": \"^6.3.5\"\n  }\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/tsconfig.json\" ext=\".json\" role=\"configuration\">\n        <cntx:meta size=\"214\" modified=\"2025-06-06T22:58:20.358Z\" lines=\"14\" />\n        <cntx:content><![CDATA[{\n  \"files\": [],\n  \"references\": [\n    { \"path\": \"./tsconfig.app.json\" },\n    { \"path\": \"./tsconfig.node.json\" }\n  ],\n   \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/*\": [\"./src/*\"]\n    }\n  }\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/tsconfig.node.json\" ext=\".json\" role=\"configuration\">\n        <cntx:meta size=\"598\" modified=\"2025-06-07T02:03:31.047Z\" lines=\"25\" />\n        <cntx:content><![CDATA[{\n  \"compilerOptions\": {\n    \"tsBuildInfoFile\": \"./node_modules/.tmp/tsconfig.node.tsbuildinfo\",\n    \"target\": \"ES2022\",\n    \"lib\": [\"ES2023\"],\n    \"module\": \"ESNext\",\n    \"skipLibCheck\": true,\n\n    /* Bundler mode */\n    \"moduleResolution\": \"bundler\",\n    \"allowImportingTsExtensions\": true,\n    \"verbatimModuleSyntax\": true,\n    \"moduleDetection\": \"force\",\n    \"noEmit\": true,\n\n    /* Linting */\n    \"strict\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"noUncheckedSideEffectImports\": true\n  },\n  \"include\": [\"vite.config.ts\"]\n}\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/vite.config.ts\" ext=\".ts\" role=\"configuration\">\n        <cntx:meta size=\"833\" modified=\"2025-06-07T02:03:25.557Z\" lines=\"36\" />\n        <cntx:content><![CDATA[import path from 'path'\nimport tailwindcss from '@tailwindcss/vite'\nimport react from '@vitejs/plugin-react'\nimport { defineConfig } from 'vite'\n\n// https://vite.dev/config/\nexport default defineConfig({\n  plugins: [react(), tailwindcss()],\n  base: './', // Important: Use relative paths for serving from any location\n  build: {\n    outDir: 'dist',\n    assetsDir: 'assets',\n    sourcemap: false, // Reduce bundle size\n    rollupOptions: {\n      output: {\n        manualChunks: undefined, // Keep everything in one chunk for simplicity\n      },\n    },\n  },\n  resolve: {\n    alias: {\n      '@': path.resolve(__dirname, './src'),\n    },\n  },\n  server: {\n    port: 5173,\n    proxy: {\n      // Proxy API calls during development\n      '/api': {\n        target: 'http://localhost:3333',\n        changeOrigin: true,\n      },\n    },\n  },\n})\n]]></cntx:content>\n      </cntx:file>\n    </cntx:group>\n    <cntx:group type=\"tests\" description=\"Test files and testing utilities\">\n      <cntx:file path=\"test-local.sh\" ext=\".sh\">\n        <cntx:meta size=\"2975\" modified=\"2025-06-07T02:05:09.889Z\" lines=\"134\" />\n        <cntx:content><![CDATA[#!/bin/bash\n\n# test-local.sh - Script to test cntx-ui locally before publishing\n\nset -e\n\necho \"🧪 Testing cntx-ui locally...\"\n\n# Create a temporary test directory\nTEST_DIR=\"/tmp/cntx-ui-test-$(date +%s)\"\necho \"📁 Creating test directory: $TEST_DIR\"\nmkdir -p \"$TEST_DIR\"\n\n# Create a simple test project\ncd \"$TEST_DIR\"\necho \"📝 Creating test project files...\"\n\n# Create package.json\ncat > package.json << 'EOF'\n{\n  \"name\": \"test-project\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"echo 'dev script'\"\n  }\n}\nEOF\n\n# Create some test files\nmkdir -p src/components src/api docs\necho \"export const hello = 'world'\" > src/index.js\necho \"export const Component = () => <div>Hello</div>\" > src/components/App.jsx\necho \"export const api = () => 'api'\" > src/api/routes.js\necho \"# Test Project\" > README.md\necho \"# Documentation\" > docs/guide.md\n\necho \"✅ Test project created with files:\"\nfind . -type f -name \"*.js\" -o -name \"*.jsx\" -o -name \"*.json\" -o -name \"*.md\" | sort\n\n# Initialize cntx-ui\necho \"🚀 Initializing cntx-ui...\"\ncntx-ui init\n\n# Check if files were created\necho \"🔍 Checking generated files...\"\nif [ -f \".cntx/config.json\" ]; then\n    echo \"✅ Config file created\"\n    cat .cntx/config.json\nelse\n    echo \"❌ Config file not created\"\n    exit 1\nfi\n\nif [ -f \".cntxignore\" ]; then\n    echo \"✅ Ignore file created\"\nelse\n    echo \"❌ Ignore file not created\"\n    exit 1\nfi\n\nif [ -f \".cursorrules\" ]; then\n    echo \"✅ Cursor rules created\"\nelse\n    echo \"❌ Cursor rules not created\"\n    exit 1\nfi\n\n# Test bundle generation\necho \"📦 Testing bundle generation...\"\ncntx-ui bundle master\n\nif [ -f \".cntx/bundles.json\" ]; then\n    echo \"✅ Bundles generated\"\nelse\n    echo \"❌ Bundles not generated\"\n    exit 1\nfi\n\n# Test status command\necho \"📊 Testing status command...\"\ncntx-ui status\n\n# Start server in background and test web interface\necho \"🌐 Testing web server...\"\necho \"Starting server on port 8899...\"\n\n# Kill any existing process on port 8899\nlsof -ti:8899 | xargs kill -9 2>/dev/null || true\n\n# Start server in background\ncntx-ui watch 8899 &\nSERVER_PID=$!\n\n# Wait for server to start\nsleep 3\n\n# Test API endpoints\necho \"🔌 Testing API endpoints...\"\n\n# Test bundles endpoint\nif curl -s http://localhost:8899/api/bundles > /dev/null; then\n    echo \"✅ API endpoint working\"\nelse\n    echo \"❌ API endpoint not working\"\n    kill $SERVER_PID 2>/dev/null\n    exit 1\nfi\n\n# Test web interface\nif curl -s http://localhost:8899/ | grep -q \"cntx-ui\"; then\n    echo \"✅ Web interface accessible\"\nelse\n    echo \"⚠️  Web interface not available (this is OK if web wasn't built)\"\nfi\n\n# Stop server\necho \"🛑 Stopping server...\"\nkill $SERVER_PID 2>/dev/null || true\n\n# Cleanup\necho \"🧹 Cleaning up...\"\ncd /\nrm -rf \"$TEST_DIR\"\n\necho \"\"\necho \"🎉 All tests passed!\"\necho \"✅ cntx-ui is working correctly\"\necho \"\"\necho \"🚀 Ready to publish!\"\necho \"   Run: npm publish\"\necho \"   Or: npm publish --tag beta\"\necho \"\"\n]]></cntx:content>\n      </cntx:file>\n    </cntx:group>\n    <cntx:group type=\"other\" description=\"Additional project files\">\n      <cntx:file path=\"build.sh\" ext=\".sh\">\n        <cntx:meta size=\"2029\" modified=\"2025-06-07T02:04:41.966Z\" lines=\"83\" />\n        <cntx:content><![CDATA[#!/bin/bash\n\n# build.sh - Script to build and test cntx-ui with web interface\n\nset -e  # Exit on any error\n\necho \"🏗️  Building cntx-ui with web interface...\"\n\n# Check if we're in the right directory\nif [ ! -f \"package.json\" ] || [ ! -d \"web\" ]; then\n    echo \"❌ Error: Please run this script from the cntx-ui root directory\"\n    exit 1\nfi\n\n# Clean previous builds\necho \"🧹 Cleaning previous builds...\"\nrm -rf web/dist\nrm -rf *.tgz\n\n# Install root dependencies\necho \"📦 Installing root dependencies...\"\nnpm install\n\n# Build web interface\necho \"🌐 Building web interface...\"\ncd web\nnpm install\nnpm run build\ncd ..\n\n# Verify build\nif [ ! -d \"web/dist\" ]; then\n    echo \"❌ Error: Web build failed - dist directory not found\"\n    exit 1\nfi\n\necho \"✅ Web interface built successfully\"\necho \"📁 Files in web/dist:\"\nls -la web/dist/\n\n# Test build locally\necho \"🧪 Testing local build...\"\nnpm pack\n\n# Get the package file name\nPACKAGE_FILE=$(ls cntx-ui-*.tgz | head -n 1)\n\nif [ -z \"$PACKAGE_FILE\" ]; then\n    echo \"❌ Error: Package file not found\"\n    exit 1\nfi\n\necho \"📦 Created package: $PACKAGE_FILE\"\necho \"📏 Package size: $(du -h $PACKAGE_FILE | cut -f1)\"\n\n# Optional: Test install locally\nread -p \"🤔 Test install locally? (y/N): \" -n 1 -r\necho\nif [[ $REPLY =~ ^[Yy]$ ]]; then\n    echo \"🔧 Installing locally for testing...\"\n    npm install -g ./$PACKAGE_FILE\n    \n    echo \"✅ Installed! Test with:\"\n    echo \"   mkdir test-project && cd test-project\"\n    echo \"   cntx-ui init\"\n    echo \"   cntx-ui watch\"\n    echo \"   # Then visit http://localhost:3333\"\nfi\n\necho \"\"\necho \"🎉 Build complete!\"\necho \"\"\necho \"📋 Next steps:\"\necho \"   1. Test the package locally (if not done above)\"\necho \"   2. If everything works, publish with: npm publish\"\necho \"   3. Or publish as beta: npm publish --tag beta\"\necho \"\"\necho \"🔍 To test in another project:\"\necho \"   mkdir /tmp/test-project && cd /tmp/test-project\"\necho \"   npm install -g $PWD/$PACKAGE_FILE\"\necho \"   cntx-ui init && cntx-ui watch\"\necho \"\"\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"examples/claude-mcp-setup.sh\" ext=\".sh\">\n        <cntx:meta size=\"1380\" modified=\"2025-06-25T02:21:03.315Z\" lines=\"45\" />\n        <cntx:content><![CDATA[#!/bin/bash\n# Copy this script to your project root and run it to set up cntx-ui MCP for Claude Desktop\n\nPROJECT_DIR=\"$(pwd)\"\nPROJECT_NAME=\"$(basename \"$PROJECT_DIR\")\"\nCONFIG_FILE=\"$HOME/Library/Application Support/Claude/claude_desktop_config.json\"\n\n# Create config directory if it doesn't exist\nmkdir -p \"$(dirname \"$CONFIG_FILE\")\"\n\n# Read existing config or create empty one\nif [ -f \"$CONFIG_FILE\" ]; then\n    EXISTING_CONFIG=$(cat \"$CONFIG_FILE\")\nelse\n    EXISTING_CONFIG='{\"mcpServers\":{}}'\nfi\n\n# Use Node.js to merge the configs properly\nnode -e \"\nconst fs = require('fs');\nconst config = $EXISTING_CONFIG;\n\nif (!config.mcpServers) config.mcpServers = {};\n\n// Add this project's MCP server\nconfig.mcpServers['cntx-ui-$PROJECT_NAME'] = {\n    'command': 'npx',\n    'args': ['cntx-ui', 'mcp'],\n    'cwd': '$PROJECT_DIR'\n};\n\nfs.writeFileSync('$CONFIG_FILE', JSON.stringify(config, null, 2));\n\"\n\necho \"✅ Added cntx-ui-$PROJECT_NAME MCP server for: $PROJECT_DIR\"\necho \"📋 Your Claude Desktop config now includes multiple projects:\"\nnode -e \"\nconst config = JSON.parse(require('fs').readFileSync('$CONFIG_FILE', 'utf8'));\nObject.keys(config.mcpServers || {}).forEach(name => {\n    if (name.startsWith('cntx-ui-')) {\n        console.log('  • ' + name + ': ' + config.mcpServers[name].cwd);\n    }\n});\n\"\necho \"🔄 Please restart Claude Desktop to use the updated configuration\"]]></cntx:content>\n      </cntx:file>\n    </cntx:group>\n  </cntx:files>\n</cntx:bundle>",
    "lastGenerated": "2025-06-26T23:00:14.476Z",
    "size": 17161
  },
  "docs": {
    "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<cntx:bundle xmlns:cntx=\"https://cntx.dev/schema\" name=\"docs\" generated=\"2025-06-26T23:00:14.487Z\">\n  <cntx:project>\n    <cntx:name>cntx-ui</cntx:name>\n    <cntx:version>2.0.12</cntx:version>\n    <cntx:description>File context management tool with web UI and MCP server for AI development workflows - bundle project files for LLM consumption</cntx:description>\n  </cntx:project>\n  <cntx:overview>\n    <cntx:purpose>Documentation, README files, and project guides</cntx:purpose>\n    <cntx:file-types>\n      <cntx:type name=\"documentation\" count=\"3\" />\n    </cntx:file-types>\n  </cntx:overview>\n  <cntx:files count=\"3\">\n    <cntx:group type=\"documentation\" description=\"README files, docs, and guides\">\n      <cntx:file path=\"README.md\" ext=\".md\" role=\"documentation\">\n        <cntx:meta size=\"8016\" modified=\"2025-06-25T02:56:05.734Z\" lines=\"372\" />\n        <cntx:content><![CDATA[# cntx-ui\n\nMinimal file bundling and tagging tool for AI development with web interface.\n\n## Features\n\n- File bundling and organization for AI development workflows\n- Web-based UI for managing bundles and configurations\n- **Model Context Protocol (MCP) server** for AI integration\n- Hidden files management\n- Cursor rules integration\n- WebSocket-based real-time updates\n- CLI tools for automation\n\n## Installation\n\n### Global Installation (Recommended)\n\n```bash\nnpm install -g cntx-ui\n```\n\n### Local Development Installation\n\n```bash\ngit clone https://github.com/nothingdao/cntx-ui.git\ncd cntx-ui\nnpm install\n```\n\n## Usage\n\n### Initialize a Project\n\n```bash\n# Initialize cntx-ui in your project\ncntx-ui init\n\n# Start the web interface\ncntx-ui watch\n\n# Visit http://localhost:3333 to access the web UI\n```\n\n### CLI Commands\n\n```bash\n# Generate bundles\ncntx-ui bundle <name>\n\n# Check project status\ncntx-ui status\n\n# Start web server on custom port\ncntx-ui watch [port]\n\n# Start web server with MCP status tracking\ncntx-ui watch --with-mcp\n\n# Start MCP server for AI integration\ncntx-ui mcp\n\n# Add project to Claude Desktop MCP configuration\ncntx-ui setup-mcp\n```\n\n### MCP Integration\n\ncntx-ui can function as an MCP (Model Context Protocol) server, providing AI tools with direct access to your project bundles:\n\n```bash\n# Start MCP server\ncntx-ui mcp\n```\n\n**Available MCP Resources:**\n- `cntx://bundle/<name>` - Access any bundle as XML content\n- `cntx://file/<path>` - Access individual project files\n\n**Available MCP Tools:**\n- `list_bundles` - List all available bundles\n- `get_bundle` - Retrieve specific bundle content  \n- `generate_bundle` - Regenerate a bundle\n- `get_file_tree` - Get project file structure\n- `get_project_status` - Get current project status\n\n## Development\n\n### Prerequisites\n\n- Node.js >= 18.0.0\n- npm\n\n### Setup Development Environment\n\n1. **Clone and install dependencies:**\n   ```bash\n   git clone https://github.com/nothingdao/cntx-ui.git\n   cd cntx-ui\n   npm install\n   ```\n\n2. **Install web dependencies:**\n   ```bash\n   cd web\n   npm install\n   cd ..\n   ```\n\n### Development Workflow\n\n#### Running in Development Mode\n\n1. **Start the backend server:**\n   ```bash\n   npm run dev\n   ```\n\n2. **Start the frontend development server:**\n   ```bash\n   npm run dev:web\n   ```\n   \n   The web interface will be available at `http://localhost:5173` (Vite dev server)\n\n#### Building the Project\n\n1. **Build web interface only:**\n   ```bash\n   npm run build:web\n   ```\n\n2. **Build entire project:**\n   ```bash\n   npm run build\n   ```\n\n3. **Automated build with validation:**\n   ```bash\n   ./build.sh\n   ```\n\n### Project Structure\n\n```\ncntx-ui/\n├── bin/                    # CLI executable\n├── web/                    # React frontend\n│   ├── src/\n│   │   ├── components/     # React components\n│   │   ├── hooks/          # Custom hooks\n│   │   ├── utils/          # Utility functions\n│   │   └── lib/            # Libraries and configurations\n│   ├── dist/               # Built frontend (generated)\n│   └── package.json        # Frontend dependencies\n├── server.js               # WebSocket server\n├── package.json            # Main package configuration\n├── build.sh                # Build automation script\n└── test-local.sh           # Local testing script\n```\n\n### Available Scripts\n\n| Script | Description |\n|--------|-------------|\n| `npm run dev` | Start backend server |\n| `npm run dev:web` | Start frontend dev server |\n| `npm run build` | Build entire project |\n| `npm run build:web` | Build frontend only |\n| `npm test:local` | Install and test package locally |\n\n## MCP Server Setup\n\n### Quick Setup with setup-mcp Command\n\nThe easiest way to configure cntx-ui for Claude Desktop:\n\n```bash\n# Navigate to your project directory\ncd /path/to/your/project\n\n# Initialize cntx-ui if not already done\ncntx-ui init\n\n# Add this project to Claude Desktop MCP configuration\ncntx-ui setup-mcp\n```\n\nThis automatically adds your project to Claude Desktop's configuration file and allows you to work with multiple projects simultaneously.\n\n### Claude Desktop Integration\n\n#### Multi-Project Setup (Recommended)\n\nYou can use cntx-ui across multiple projects by running `setup-mcp` in each project directory:\n\n```bash\n# Project 1\ncd /Users/you/project1\ncntx-ui setup-mcp\n\n# Project 2  \ncd /Users/you/project2\ncntx-ui setup-mcp\n```\n\nThis creates entries in your Claude Desktop config (`~/Library/Application Support/Claude/claude_desktop_config.json`):\n\n```json\n{\n  \"mcpServers\": {\n    \"cntx-ui-project1\": {\n      \"command\": \"sh\",\n      \"args\": [\"-c\", \"cd /Users/you/project1 && node /path/to/cntx-ui/bin/cntx-ui.js mcp\"],\n      \"cwd\": \"/Users/you/project1\"\n    },\n    \"cntx-ui-project2\": {\n      \"command\": \"sh\", \n      \"args\": [\"-c\", \"cd /Users/you/project2 && node /path/to/cntx-ui/bin/cntx-ui.js mcp\"],\n      \"cwd\": \"/Users/you/project2\"\n    }\n  }\n}\n```\n\n#### Manual Configuration\n\nFor manual setup, add to your Claude Desktop configuration:\n\n```json\n{\n  \"mcpServers\": {\n    \"cntx-ui-projectname\": {\n      \"command\": \"sh\",\n      \"args\": [\"-c\", \"cd /path/to/your/project && cntx-ui mcp\"],\n      \"cwd\": \"/path/to/your/project\"\n    }\n  }\n}\n```\n\n### Other MCP Clients\n\nFor other MCP-compatible clients, use:\n- **Command**: `cntx-ui mcp`\n- **Transport**: stdio\n- **Working Directory**: Your project root\n\n### MCP Workflow\n\n1. **Setup**: Run `cntx-ui setup-mcp` in each project you want to use with Claude Desktop\n2. **Visual Configuration**: Use `cntx-ui watch` to configure bundles via web UI\n3. **AI Integration**: AI clients connect via MCP to access bundles across all configured projects\n4. **Real-time Updates**: Changes in web UI immediately available to AI tools\n5. **Multi-Project**: Claude Desktop can access bundles from all configured projects simultaneously\n\n## Testing\n\n### Local Testing\n\n1. **Run automated test suite:**\n   ```bash\n   ./test-local.sh\n   ```\n\n2. **Manual testing:**\n   ```bash\n   # Build and pack\n   npm run build\n   npm pack\n   \n   # Install globally for testing\n   npm install -g ./cntx-ui-*.tgz\n   \n   # Test in a new project\n   mkdir test-project && cd test-project\n   cntx-ui init\n   cntx-ui watch\n   ```\n\n### Test Coverage\n\nThe test suite covers:\n- Project initialization\n- Bundle generation\n- Web server functionality\n- API endpoints\n- File management operations\n\n## Publishing\n\n### Prerequisites for Publishing\n\n- npm account with publish permissions\n- Clean git working directory\n- All tests passing\n\n### Publishing Steps\n\n1. **Update version:**\n   ```bash\n   npm version patch  # or minor/major\n   ```\n\n2. **Build and validate:**\n   ```bash\n   ./build.sh\n   ```\n\n3. **Test locally:**\n   ```bash\n   ./test-local.sh\n   ```\n\n4. **Publish to npm:**\n   ```bash\n   # Stable release\n   npm publish\n   \n   # Beta release\n   npm publish --tag beta\n   ```\n\n### Automated Publishing Workflow\n\nUse the build script for a complete workflow:\n\n```bash\n./build.sh\n# Follow prompts for local testing\n# If tests pass, run: npm publish\n```\n\n## Configuration\n\n### Environment Variables\n\n- `PORT` - Override default server port (default: 3333)\n- `NODE_ENV` - Set environment (development/production)\n\n### Project Configuration\n\ncntx-ui creates these files in your project:\n- `.cntx/config.json` - Main configuration\n- `.cntxignore` - Files to ignore\n- `.cursorrules` - Cursor editor rules\n\n## Contributing\n\n1. Fork the repository\n2. Create a feature branch\n3. Make changes following the existing code style\n4. Run tests: `./test-local.sh`\n5. Submit a pull request\n\n## Technology Stack\n\n- **Backend:** Node.js, WebSocket (ws)\n- **Frontend:** React 19, TypeScript, Vite\n- **UI:** Tailwind CSS, Radix UI\n- **State Management:** TanStack Query\n- **Build Tools:** Vite, TypeScript compiler\n\n## License\n\nMIT\n\n## Support\n\n- GitHub Issues: [Report bugs or request features](https://github.com/nothingdao/cntx-ui/issues)\n- Documentation: Check the web interface for detailed usage guides\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"VISION.md\" ext=\".md\">\n        <cntx:meta size=\"3524\" modified=\"2025-06-26T16:23:26.175Z\" lines=\"111\" />\n        <cntx:content><![CDATA[We're building the interface layer between human mental models and machine understanding of codebases.\n\n## The Complete Knowledge Graph\n\nWhat we're really creating is a traversable knowledge graph for AI agents:\n\n```\n// The full context system an AI agent can navigate:\n{\n  project: {\n    fileTree: rawFileStructure,           // Raw filesystem\n    bundles: humanDefinedCollections,     // Explicit human organization\n    chunks: aiDiscoveredPatterns,         // Machine-learned semantic groups\n    aiRules: contextualInstructions,      // How to work with this code\n    metadata: projectUnderstanding        // What this codebase \"does\"\n  }\n}\n```\n\n## Multi-Layer Understanding System\n\nLayer 1: Raw Structure (File Tree)\n\n- Physical organization\n- What files exist, where they are\n\nLayer 2: Human Intent (Bundles)\n\n- \"These files should be considered together\"\n- Explicit human curation for specific purposes\n\nLayer 3: Machine Discovery (Semantic Chunks)\n\n- \"These files naturally cluster together\"\n- AI-discovered relationships and patterns\n\nLayer 4: Working Instructions (AI Rules + Context)\n\n- \"When working on X, consider Y\"\n- How to navigate and modify the code effectively\n\n## The Human ↔ Machine Interface\n\nThis becomes a bidirectional translation layer:\n\nHuman → Machine:\n\n- \"I'm working on authentication\" → AI gets auth chunks + related bundles +\n  security rules\n- \"This is an e-commerce app\" → AI understands domain context for better\n  suggestions\n- \"These files are related\" → Creates explicit bundle relationships\n\nMachine → Human:\n\n- AI discovers \"payment processing is tightly coupled across 12 files\"\n- AI suggests \"these utility functions could be shared between features\"\n- AI provides \"here's what your codebase is primarily about\" overview\n\nOngoing Repository Intelligence\n\nAs the tool runs continuously, it builds living documentation:\n\n```\n// Repository understanding that evolves:\n{\n  codebasePersonality: {\n    primaryPurpose: \"E-commerce platform with React frontend\",\n    architecturalPatterns: [\"feature-based organization\", \"custom hooks\npattern\"],\n    complexityHotspots: [\"payment processing\", \"user authentication\"],\n    evolutionTrends: [\"moving from REST to GraphQL\", \"adding TypeScript\ngradually\"]\n  },\n\n  workingMemory: {\n    recentChanges: \"Auth system refactored last week\",\n    emergingPatterns: \"New utilities being created for form handling\",\n    maintenanceNeeds: \"Several components showing high complexity\"\n  }\n}\n```\n\n## The \"What Is This Codebase About?\" Dashboard\n\nUsers get a high-level strategic view:\n\n- Semantic Map: Visual representation of chunks and relationships\n- Complexity Overview: Where the hard problems live\n- Evolution Tracking: How the code is changing over time\n- AI Recommendations: Suggested improvements and organizational changes\n- Context Preparation: Pre-built knowledge packages for different types of AI\n  assistance\n\nThis creates a self-documenting, AI-optimized codebase where both humans and\nmachines can quickly understand:\n\n1. What this code does\n2. How it's organized\n3. Where to make changes\n4. How different parts relate\n5. What context an AI agent needs to help effectively\n\nThe tool becomes the source of truth for codebase understanding, continuously\nlearning and improving its model of the project while giving humans control\nover the organizational principles.\n\nThis is exactly the kind of human-AI collaboration interface that will become\nessential as codebases get more complex and AI assistance becomes more\nsophisticated.\n]]></cntx:content>\n      </cntx:file>\n      <cntx:file path=\"web/README.md\" ext=\".md\" role=\"documentation\">\n        <cntx:meta size=\"1942\" modified=\"2025-06-06T22:55:53.329Z\" lines=\"55\" />\n        <cntx:content><![CDATA[# React + TypeScript + Vite\n\nThis template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.\n\nCurrently, two official plugins are available:\n\n- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh\n- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh\n\n## Expanding the ESLint configuration\n\nIf you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:\n\n```js\nexport default tseslint.config({\n  extends: [\n    // Remove ...tseslint.configs.recommended and replace with this\n    ...tseslint.configs.recommendedTypeChecked,\n    // Alternatively, use this for stricter rules\n    ...tseslint.configs.strictTypeChecked,\n    // Optionally, add this for stylistic rules\n    ...tseslint.configs.stylisticTypeChecked,\n  ],\n  languageOptions: {\n    // other options...\n    parserOptions: {\n      project: ['./tsconfig.node.json', './tsconfig.app.json'],\n      tsconfigRootDir: import.meta.dirname,\n    },\n  },\n})\n```\n\nYou can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:\n\n```js\n// eslint.config.js\nimport reactX from 'eslint-plugin-react-x'\nimport reactDom from 'eslint-plugin-react-dom'\n\nexport default tseslint.config({\n  plugins: {\n    // Add the react-x and react-dom plugins\n    'react-x': reactX,\n    'react-dom': reactDom,\n  },\n  rules: {\n    // other rules...\n    // Enable its recommended typescript rules\n    ...reactX.configs['recommended-typescript'].rules,\n    ...reactDom.configs.recommended.rules,\n  },\n})\n```\n]]></cntx:content>\n      </cntx:file>\n    </cntx:group>\n  </cntx:files>\n</cntx:bundle>",
    "lastGenerated": "2025-06-26T23:00:14.488Z",
    "size": 14903
  }
}